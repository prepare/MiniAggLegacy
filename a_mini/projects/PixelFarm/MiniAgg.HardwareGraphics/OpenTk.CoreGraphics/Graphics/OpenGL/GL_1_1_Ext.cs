#region License
//
// The Open Toolkit Library License
//
// Copyright (c) 2006 - 2009 the Open Toolkit library.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to 
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
#endregion

#if  ENABLE_DESKTOP_OPENGL
namespace OpenTK.Graphics.OpenGL
{
    using System;
    using System.Text;
    using System.Runtime.InteropServices;
#pragma warning disable 3019
#pragma warning disable 1591
#pragma warning disable 1572
#pragma warning disable 1573

    partial class GL
    {
        public static partial class Ext
        {
            [AutoGenerated(Category = "ExtLightTexture", Version = "1.1", EntryPoint = "glApplyTextureEXT")]
            public static
            void ApplyTexture(OpenTK.Graphics.OpenGL.ExtLightTexture mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glApplyTextureEXT((OpenTK.Graphics.OpenGL.ExtLightTexture)mode);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if textures are loaded in texture memory
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be queried.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be queried.
            /// </para>
            /// </param>
            /// <param name="residences">
            /// <para>
            /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glAreTexturesResidentEXT")]
            public static
            bool AreTexturesResident(Int32 n, Int32[] textures, [OutAttribute] bool[] residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = textures)
                        fixed (bool* residences_ptr = residences)
                        {
                            return Delegates.glAreTexturesResidentEXT((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if textures are loaded in texture memory
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be queried.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be queried.
            /// </para>
            /// </param>
            /// <param name="residences">
            /// <para>
            /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glAreTexturesResidentEXT")]
            public static
            bool AreTexturesResident(Int32 n, ref Int32 textures, [OutAttribute] out bool residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = &textures)
                        fixed (bool* residences_ptr = &residences)
                        {
                            bool retval = Delegates.glAreTexturesResidentEXT((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                            residences = *residences_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if textures are loaded in texture memory
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be queried.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be queried.
            /// </para>
            /// </param>
            /// <param name="residences">
            /// <para>
            /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glAreTexturesResidentEXT")]
            public static
            unsafe bool AreTexturesResident(Int32 n, Int32* textures, [OutAttribute] bool* residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glAreTexturesResidentEXT((Int32)n, (UInt32*)textures, (bool*)residences);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if textures are loaded in texture memory
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be queried.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be queried.
            /// </para>
            /// </param>
            /// <param name="residences">
            /// <para>
            /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glAreTexturesResidentEXT")]
            public static
            bool AreTexturesResident(Int32 n, UInt32[] textures, [OutAttribute] bool[] residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = textures)
                        fixed (bool* residences_ptr = residences)
                        {
                            return Delegates.glAreTexturesResidentEXT((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if textures are loaded in texture memory
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be queried.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be queried.
            /// </para>
            /// </param>
            /// <param name="residences">
            /// <para>
            /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glAreTexturesResidentEXT")]
            public static
            bool AreTexturesResident(Int32 n, ref UInt32 textures, [OutAttribute] out bool residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = &textures)
                        fixed (bool* residences_ptr = &residences)
                        {
                            bool retval = Delegates.glAreTexturesResidentEXT((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                            residences = *residences_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if textures are loaded in texture memory
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be queried.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be queried.
            /// </para>
            /// </param>
            /// <param name="residences">
            /// <para>
            /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glAreTexturesResidentEXT")]
            public static
            unsafe bool AreTexturesResident(Int32 n, UInt32* textures, [OutAttribute] bool* residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glAreTexturesResidentEXT((Int32)n, (UInt32*)textures, (bool*)residences);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render a vertex using the specified vertex array element
            /// </summary>
            /// <param name="i">
            /// <para>
            /// Specifies an index into the enabled vertex data arrays.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glArrayElementEXT")]
            public static
            void ArrayElement(Int32 i)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glArrayElementEXT((Int32)i);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBeginTransformFeedbackEXT")]
            public static
            void BeginTransformFeedback(OpenTK.Graphics.OpenGL.ExtTransformFeedback primitiveMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginTransformFeedbackEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)primitiveMode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBeginVertexShaderEXT")]
            public static
            void BeginVertexShader()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginVertexShaderEXT();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBindBufferBaseEXT")]
            public static
            void BindBufferBase(OpenTK.Graphics.OpenGL.ExtTransformFeedback target, Int32 index, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferBaseEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)target, (UInt32)index, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBindBufferBaseEXT")]
            public static
            void BindBufferBase(OpenTK.Graphics.OpenGL.ExtTransformFeedback target, UInt32 index, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferBaseEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)target, (UInt32)index, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBindBufferOffsetEXT")]
            public static
            void BindBufferOffset(OpenTK.Graphics.OpenGL.ExtTransformFeedback target, Int32 index, Int32 buffer, IntPtr offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferOffsetEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBindBufferOffsetEXT")]
            public static
            void BindBufferOffset(OpenTK.Graphics.OpenGL.ExtTransformFeedback target, UInt32 index, UInt32 buffer, IntPtr offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferOffsetEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBindBufferRangeEXT")]
            public static
            void BindBufferRange(OpenTK.Graphics.OpenGL.ExtTransformFeedback target, Int32 index, Int32 buffer, IntPtr offset, IntPtr size)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferRangeEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glBindBufferRangeEXT")]
            public static
            void BindBufferRange(OpenTK.Graphics.OpenGL.ExtTransformFeedback target, UInt32 index, UInt32 buffer, IntPtr offset, IntPtr size)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferRangeEXT((OpenTK.Graphics.OpenGL.ExtTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glBindFragDataLocationEXT")]
            public static
            void BindFragDataLocation(Int32 program, Int32 color, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindFragDataLocationEXT((UInt32)program, (UInt32)color, (String)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glBindFragDataLocationEXT")]
            public static
            void BindFragDataLocation(UInt32 program, UInt32 color, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindFragDataLocationEXT((UInt32)program, (UInt32)color, (String)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glBindFramebufferEXT")]
            public static
            void BindFramebuffer(OpenTK.Graphics.OpenGL.FramebufferTarget target, Int32 framebuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindFramebufferEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (UInt32)framebuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glBindFramebufferEXT")]
            public static
            void BindFramebuffer(OpenTK.Graphics.OpenGL.FramebufferTarget target, UInt32 framebuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindFramebufferEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (UInt32)framebuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindLightParameterEXT")]
            public static
            Int32 BindLightParameter(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glBindLightParameterEXT((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindMaterialParameterEXT")]
            public static
            Int32 BindMaterialParameter(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glBindMaterialParameterEXT((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glBindMultiTextureEXT")]
            public static
            void BindMultiTexture(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindMultiTextureEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)texture);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glBindMultiTextureEXT")]
            public static
            void BindMultiTexture(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, UInt32 texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindMultiTextureEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)texture);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindParameterEXT")]
            public static
            Int32 BindParameter(OpenTK.Graphics.OpenGL.ExtVertexShader value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glBindParameterEXT((OpenTK.Graphics.OpenGL.ExtVertexShader)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glBindRenderbufferEXT")]
            public static
            void BindRenderbuffer(OpenTK.Graphics.OpenGL.RenderbufferTarget target, Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindRenderbufferEXT((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glBindRenderbufferEXT")]
            public static
            void BindRenderbuffer(OpenTK.Graphics.OpenGL.RenderbufferTarget target, UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindRenderbufferEXT((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindTexGenParameterEXT")]
            public static
            Int32 BindTexGenParameter(OpenTK.Graphics.OpenGL.TextureUnit unit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glBindTexGenParameterEXT((OpenTK.Graphics.OpenGL.TextureUnit)unit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Bind a named texture to a texturing target
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="texture">
            /// <para>
            /// Specifies the name of a texture.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glBindTextureEXT")]
            public static
            void BindTexture(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindTextureEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)texture);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Bind a named texture to a texturing target
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="texture">
            /// <para>
            /// Specifies the name of a texture.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glBindTextureEXT")]
            public static
            void BindTexture(OpenTK.Graphics.OpenGL.TextureTarget target, UInt32 texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindTextureEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)texture);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindTextureUnitParameterEXT")]
            public static
            Int32 BindTextureUnitParameter(OpenTK.Graphics.OpenGL.TextureUnit unit, OpenTK.Graphics.OpenGL.ExtVertexShader value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glBindTextureUnitParameterEXT((OpenTK.Graphics.OpenGL.TextureUnit)unit, (OpenTK.Graphics.OpenGL.ExtVertexShader)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindVertexShaderEXT")]
            public static
            void BindVertexShader(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindVertexShaderEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glBindVertexShaderEXT")]
            public static
            void BindVertexShader(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindVertexShaderEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bEXT")]
            public static
            void Binormal3(Byte bx, Byte by, Byte bz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3bEXT((SByte)bx, (SByte)by, (SByte)bz);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bEXT")]
            public static
            void Binormal3(SByte bx, SByte by, SByte bz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3bEXT((SByte)bx, (SByte)by, (SByte)bz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bvEXT")]
            public static
            void Binormal3(Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glBinormal3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bvEXT")]
            public static
            void Binormal3(ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glBinormal3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bvEXT")]
            public static
            unsafe void Binormal3(Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3bvEXT((SByte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bvEXT")]
            public static
            void Binormal3(SByte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = v)
                        {
                            Delegates.glBinormal3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bvEXT")]
            public static
            void Binormal3(ref SByte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = &v)
                        {
                            Delegates.glBinormal3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3bvEXT")]
            public static
            unsafe void Binormal3(SByte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3bvEXT((SByte*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3dEXT")]
            public static
            void Binormal3(Double bx, Double by, Double bz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3dEXT((Double)bx, (Double)by, (Double)bz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3dvEXT")]
            public static
            void Binormal3(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glBinormal3dvEXT((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3dvEXT")]
            public static
            void Binormal3(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glBinormal3dvEXT((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3dvEXT")]
            public static
            unsafe void Binormal3(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3dvEXT((Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3fEXT")]
            public static
            void Binormal3(Single bx, Single by, Single bz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3fEXT((Single)bx, (Single)by, (Single)bz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3fvEXT")]
            public static
            void Binormal3(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glBinormal3fvEXT((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3fvEXT")]
            public static
            void Binormal3(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glBinormal3fvEXT((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3fvEXT")]
            public static
            unsafe void Binormal3(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3fvEXT((Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3iEXT")]
            public static
            void Binormal3(Int32 bx, Int32 by, Int32 bz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3iEXT((Int32)bx, (Int32)by, (Int32)bz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3ivEXT")]
            public static
            void Binormal3(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glBinormal3ivEXT((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3ivEXT")]
            public static
            void Binormal3(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glBinormal3ivEXT((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3ivEXT")]
            public static
            unsafe void Binormal3(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3ivEXT((Int32*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3sEXT")]
            public static
            void Binormal3(Int16 bx, Int16 by, Int16 bz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3sEXT((Int16)bx, (Int16)by, (Int16)bz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3svEXT")]
            public static
            void Binormal3(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glBinormal3svEXT((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3svEXT")]
            public static
            void Binormal3(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glBinormal3svEXT((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormal3svEXT")]
            public static
            unsafe void Binormal3(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormal3svEXT((Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormalPointerEXT")]
            public static
            void BinormalPointer(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBinormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormalPointerEXT")]
            public static
            void BinormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBinormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormalPointerEXT")]
            public static
            void BinormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBinormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormalPointerEXT")]
            public static
            void BinormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBinormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glBinormalPointerEXT")]
            public static
            void BinormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBinormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the blend color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// specify the components of GL_BLEND_COLOR
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtBlendColor", Version = "1.0", EntryPoint = "glBlendColorEXT")]
            public static
            void BlendColor(Single red, Single green, Single blue, Single alpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendColorEXT((Single)red, (Single)green, (Single)blue, (Single)alpha);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the equation used for both the RGB blend equation and the Alpha blend equation
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtBlendMinmax", Version = "1.0", EntryPoint = "glBlendEquationEXT")]
            public static
            void BlendEquation(OpenTK.Graphics.OpenGL.ExtBlendMinmax mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendEquationEXT((OpenTK.Graphics.OpenGL.ExtBlendMinmax)mode);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the RGB blend equation and the alpha blend equation separately
            /// </summary>
            /// <param name="modeRGB">
            /// <para>
            /// specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
            /// </para>
            /// </param>
            /// <param name="modeAlpha">
            /// <para>
            /// specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtBlendEquationSeparate", Version = "1.2", EntryPoint = "glBlendEquationSeparateEXT")]
            public static
            void BlendEquationSeparate(OpenTK.Graphics.OpenGL.ExtBlendEquationSeparate modeRGB, OpenTK.Graphics.OpenGL.ExtBlendEquationSeparate modeAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendEquationSeparateEXT((OpenTK.Graphics.OpenGL.ExtBlendEquationSeparate)modeRGB, (OpenTK.Graphics.OpenGL.ExtBlendEquationSeparate)modeAlpha);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify pixel arithmetic for RGB and alpha components separately
            /// </summary>
            /// <param name="srcRGB">
            /// <para>
            /// Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
            /// </para>
            /// </param>
            /// <param name="dstRGB">
            /// <para>
            /// Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
            /// </para>
            /// </param>
            /// <param name="srcAlpha">
            /// <para>
            /// Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.
            /// </para>
            /// </param>
            /// <param name="dstAlpha">
            /// <para>
            /// Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtBlendFuncSeparate", Version = "1.0", EntryPoint = "glBlendFuncSeparateEXT")]
            public static
            void BlendFuncSeparate(OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate sfactorRGB, OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate dfactorRGB, OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate sfactorAlpha, OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate dfactorAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendFuncSeparateEXT((OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate)sfactorRGB, (OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate)dfactorRGB, (OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate)sfactorAlpha, (OpenTK.Graphics.OpenGL.ExtBlendFuncSeparate)dfactorAlpha);
#if DEBUG
                }
#endif
            }


            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glCheckFramebufferStatusEXT")]
            public static
            OpenTK.Graphics.OpenGL.FramebufferErrorCode CheckFramebufferStatus(OpenTK.Graphics.OpenGL.FramebufferTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glCheckFramebufferStatusEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCheckNamedFramebufferStatusEXT")]
            public static
            OpenTK.Graphics.OpenGL.ExtDirectStateAccess CheckNamedFramebufferStatus(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glCheckNamedFramebufferStatusEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferTarget)target);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCheckNamedFramebufferStatusEXT")]
            public static
            OpenTK.Graphics.OpenGL.ExtDirectStateAccess CheckNamedFramebufferStatus(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glCheckNamedFramebufferStatusEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferTarget)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glClearColorIiEXT")]
            public static
            void ClearColorI(Int32 red, Int32 green, Int32 blue, Int32 alpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClearColorIiEXT((Int32)red, (Int32)green, (Int32)blue, (Int32)alpha);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glClearColorIuiEXT")]
            public static
            void ClearColorI(UInt32 red, UInt32 green, UInt32 blue, UInt32 alpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClearColorIuiEXT((UInt32)red, (UInt32)green, (UInt32)blue, (UInt32)alpha);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glClientAttribDefaultEXT")]
            public static
            void ClientAttribDefault(OpenTK.Graphics.OpenGL.ClientAttribMask mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClientAttribDefaultEXT((OpenTK.Graphics.OpenGL.ClientAttribMask)mask);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glColorMaskIndexedEXT")]
            public static
            void ColorMaskIndexed(Int32 index, bool r, bool g, bool b, bool a)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorMaskIndexedEXT((UInt32)index, (bool)r, (bool)g, (bool)b, (bool)a);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glColorMaskIndexedEXT")]
            public static
            void ColorMaskIndexed(UInt32 index, bool r, bool g, bool b, bool a)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorMaskIndexedEXT((UInt32)index, (bool)r, (bool)g, (bool)b, (bool)a);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glColorPointerEXT")]
            public static
            void ColorPointer(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, Int32 count, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glColorPointerEXT")]
            public static
            void ColorPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glColorPointerEXT")]
            public static
            void ColorPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glColorPointerEXT")]
            public static
            void ColorPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glColorPointerEXT")]
            public static
            void ColorPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Respecify a portion of a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// The starting index of the portion of the color table to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The number of table entries to replace.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtColorSubtable", Version = "1.2", EntryPoint = "glColorSubTableEXT")]
            public static
            void ColorSubTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 count, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorSubTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)count, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Respecify a portion of a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// The starting index of the portion of the color table to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The number of table entries to replace.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtColorSubtable", Version = "1.2", EntryPoint = "glColorSubTableEXT")]
            public static
            void ColorSubTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 count, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] data)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorSubTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)count, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Respecify a portion of a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// The starting index of the portion of the color table to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The number of table entries to replace.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtColorSubtable", Version = "1.2", EntryPoint = "glColorSubTableEXT")]
            public static
            void ColorSubTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 count, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] data)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorSubTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)count, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Respecify a portion of a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// The starting index of the portion of the color table to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The number of table entries to replace.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtColorSubtable", Version = "1.2", EntryPoint = "glColorSubTableEXT")]
            public static
            void ColorSubTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 count, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] data)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorSubTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)count, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Respecify a portion of a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// The starting index of the portion of the color table to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// The number of table entries to replace.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to replace the specified region of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtColorSubtable", Version = "1.2", EntryPoint = "glColorSubTableEXT")]
            public static
            void ColorSubTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 count, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 data)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorSubTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)count, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T5)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glColorTableEXT")]
            public static
            void ColorTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalFormat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr table)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalFormat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glColorTableEXT")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalFormat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalFormat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glColorTableEXT")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalFormat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalFormat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glColorTableEXT")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalFormat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalFormat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glColorTableEXT")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalFormat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalFormat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                        table = (T5)table_ptr.Target;
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage1DEXT")]
            public static
            void CompressedMultiTexImage1D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage1DEXT")]
            public static
            void CompressedMultiTexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage1DEXT")]
            public static
            void CompressedMultiTexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage1DEXT")]
            public static
            void CompressedMultiTexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage1DEXT")]
            public static
            void CompressedMultiTexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T7)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage2DEXT")]
            public static
            void CompressedMultiTexImage2D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage2DEXT")]
            public static
            void CompressedMultiTexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage2DEXT")]
            public static
            void CompressedMultiTexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage2DEXT")]
            public static
            void CompressedMultiTexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage2DEXT")]
            public static
            void CompressedMultiTexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T8)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage3DEXT")]
            public static
            void CompressedMultiTexImage3D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage3DEXT")]
            public static
            void CompressedMultiTexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage3DEXT")]
            public static
            void CompressedMultiTexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage3DEXT")]
            public static
            void CompressedMultiTexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[,,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexImage3DEXT")]
            public static
            void CompressedMultiTexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T9 bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T9)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage1DEXT")]
            public static
            void CompressedMultiTexSubImage1D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage1DEXT")]
            public static
            void CompressedMultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage1DEXT")]
            public static
            void CompressedMultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage1DEXT")]
            public static
            void CompressedMultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage1DEXT")]
            public static
            void CompressedMultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T7 bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T7)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage2DEXT")]
            public static
            void CompressedMultiTexSubImage2D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage2DEXT")]
            public static
            void CompressedMultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage2DEXT")]
            public static
            void CompressedMultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage2DEXT")]
            public static
            void CompressedMultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[,,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage2DEXT")]
            public static
            void CompressedMultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T9 bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T9)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage3DEXT")]
            public static
            void CompressedMultiTexSubImage3D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage3DEXT")]
            public static
            void CompressedMultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage3DEXT")]
            public static
            void CompressedMultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[,] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage3DEXT")]
            public static
            void CompressedMultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[,,] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedMultiTexSubImage3DEXT")]
            public static
            void CompressedMultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T11 bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T11)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T7)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage1DEXT")]
            public static
            void CompressedTextureImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T7)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T8)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage2DEXT")]
            public static
            void CompressedTextureImage2D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 bits)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T8)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[,,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T9 bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T9)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T9[,,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureImage3DEXT")]
            public static
            void CompressedTextureImage3D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T9 bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T9)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T7 bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T7)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage1DEXT")]
            public static
            void CompressedTextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T7 bits)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T7)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[,,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T9 bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T9)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T9[,,] bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage2DEXT")]
            public static
            void CompressedTextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T9 bits)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T9)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[,] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[,,] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T11 bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T11)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr bits)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[,] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T11[,,] bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCompressedTextureSubImage3DEXT")]
            public static
            void CompressedTextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T11 bits)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle bits_ptr = GCHandle.Alloc(bits, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)bits_ptr.AddrOfPinnedObject());
                        bits = (T11)bits_ptr.Target;
                    }
                    finally
                    {
                        bits_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a one-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_1D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter1DEXT")]
            public static
            void ConvolutionFilter1D(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr image)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glConvolutionFilter1DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a one-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_1D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter1DEXT")]
            public static
            void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] image)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter1DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a one-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_1D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter1DEXT")]
            public static
            void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] image)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter1DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a one-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_1D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter1DEXT")]
            public static
            void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] image)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter1DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a one-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_1D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter1DEXT")]
            public static
            void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 image)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter1DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                        image = (T5)image_ptr.Target;
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The height of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter2DEXT")]
            public static
            void ConvolutionFilter2D(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr image)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glConvolutionFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The height of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter2DEXT")]
            public static
            void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] image)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The height of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter2DEXT")]
            public static
            void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] image)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The height of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter2DEXT")]
            public static
            void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] image)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The height of the pixel array referenced by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionFilter2DEXT")]
            public static
            void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 image)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glConvolutionFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                        image = (T6)image_ptr.Target;
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
            /// </para>
            /// <para>
            /// 
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionParameterfEXT")]
            public static
            void ConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glConvolutionParameterfEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Single)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
            /// </para>
            /// <para>
            /// 
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionParameterfvEXT")]
            public static
            void ConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glConvolutionParameterfvEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
            /// </para>
            /// <para>
            /// 
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionParameterfvEXT")]
            public static
            unsafe void ConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glConvolutionParameterfvEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
            /// </para>
            /// <para>
            /// 
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionParameteriEXT")]
            public static
            void ConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glConvolutionParameteriEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Int32)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
            /// </para>
            /// <para>
            /// 
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionParameterivEXT")]
            public static
            void ConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glConvolutionParameterivEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
            /// </para>
            /// <para>
            /// 
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glConvolutionParameterivEXT")]
            public static
            unsafe void ConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glConvolutionParameterivEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Respecify a portion of a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// The starting index of the portion of the color table to be replaced.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// The window coordinates of the left corner of the row of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of table entries to replace.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtColorSubtable", Version = "1.2", EntryPoint = "glCopyColorSubTableEXT")]
            public static
            void CopyColorSubTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyColorSubTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy pixels into a one-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_1D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array to copy.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glCopyConvolutionFilter1DEXT")]
            public static
            void CopyConvolutionFilter1D(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyConvolutionFilter1DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy pixels into a two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel array to copy.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The height of the pixel array to copy.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glCopyConvolutionFilter2DEXT")]
            public static
            void CopyConvolutionFilter2D(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyConvolutionFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyMultiTexImage1DEXT")]
            public static
            void CopyMultiTexImage1D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 x, Int32 y, Int32 width, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)border);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyMultiTexImage2DEXT")]
            public static
            void CopyMultiTexImage2D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyMultiTexSubImage1DEXT")]
            public static
            void CopyMultiTexSubImage1D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyMultiTexSubImage2DEXT")]
            public static
            void CopyMultiTexSubImage2D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyMultiTexSubImage3DEXT")]
            public static
            void CopyMultiTexSubImage3D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy pixels into a 1D texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the left corner of the row of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. Must be 0 or 2 sup n + 2 ( border ) for some integer . The height of the texture image is 1.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtCopyTexture", Version = "1.0", EntryPoint = "glCopyTexImage1DEXT")]
            public static
            void CopyTexImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)border);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy pixels into a 2D texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image. Must be 0 or 2 sup n + 2 ( border ) for some integer .
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image. Must be 0 or 2 sup m + 2 ( border ) for some integer .
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtCopyTexture", Version = "1.0", EntryPoint = "glCopyTexImage2DEXT")]
            public static
            void CopyTexImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy a one-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies the texel offset within the texture array.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the left corner of the row of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtCopyTexture", Version = "1.0", EntryPoint = "glCopyTexSubImage1DEXT")]
            public static
            void CopyTexSubImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy a two-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtCopyTexture", Version = "1.0", EntryPoint = "glCopyTexSubImage2DEXT")]
            public static
            void CopyTexSubImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtCopyTexture", Version = "1.0", EntryPoint = "glCopyTexSubImage3DEXT")]
            public static
            void CopyTexSubImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureImage1DEXT")]
            public static
            void CopyTextureImage1D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 x, Int32 y, Int32 width, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)border);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureImage1DEXT")]
            public static
            void CopyTextureImage1D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 x, Int32 y, Int32 width, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)border);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureImage2DEXT")]
            public static
            void CopyTextureImage2D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureImage2DEXT")]
            public static
            void CopyTextureImage2D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureSubImage1DEXT")]
            public static
            void CopyTextureSubImage1D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureSubImage1DEXT")]
            public static
            void CopyTextureSubImage1D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureSubImage2DEXT")]
            public static
            void CopyTextureSubImage2D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureSubImage2DEXT")]
            public static
            void CopyTextureSubImage2D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureSubImage3DEXT")]
            public static
            void CopyTextureSubImage3D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glCopyTextureSubImage3DEXT")]
            public static
            void CopyTextureSubImage3D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCullVertex", Version = "1.1", EntryPoint = "glCullParameterdvEXT")]
            public static
            void CullParameter(OpenTK.Graphics.OpenGL.ExtCullVertex pname, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glCullParameterdvEXT((OpenTK.Graphics.OpenGL.ExtCullVertex)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCullVertex", Version = "1.1", EntryPoint = "glCullParameterdvEXT")]
            public static
            void CullParameter(OpenTK.Graphics.OpenGL.ExtCullVertex pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glCullParameterdvEXT((OpenTK.Graphics.OpenGL.ExtCullVertex)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCullVertex", Version = "1.1", EntryPoint = "glCullParameterdvEXT")]
            public static
            unsafe void CullParameter(OpenTK.Graphics.OpenGL.ExtCullVertex pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCullParameterdvEXT((OpenTK.Graphics.OpenGL.ExtCullVertex)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCullVertex", Version = "1.1", EntryPoint = "glCullParameterfvEXT")]
            public static
            void CullParameter(OpenTK.Graphics.OpenGL.ExtCullVertex pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glCullParameterfvEXT((OpenTK.Graphics.OpenGL.ExtCullVertex)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCullVertex", Version = "1.1", EntryPoint = "glCullParameterfvEXT")]
            public static
            void CullParameter(OpenTK.Graphics.OpenGL.ExtCullVertex pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glCullParameterfvEXT((OpenTK.Graphics.OpenGL.ExtCullVertex)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCullVertex", Version = "1.1", EntryPoint = "glCullParameterfvEXT")]
            public static
            unsafe void CullParameter(OpenTK.Graphics.OpenGL.ExtCullVertex pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCullParameterfvEXT((OpenTK.Graphics.OpenGL.ExtCullVertex)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteFramebuffersEXT")]
            public static
            void DeleteFramebuffers(Int32 n, Int32[] framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* framebuffers_ptr = framebuffers)
                        {
                            Delegates.glDeleteFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteFramebuffersEXT")]
            public static
            void DeleteFramebuffers(Int32 n, ref Int32 framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* framebuffers_ptr = &framebuffers)
                        {
                            Delegates.glDeleteFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteFramebuffersEXT")]
            public static
            unsafe void DeleteFramebuffers(Int32 n, Int32* framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFramebuffersEXT((Int32)n, (UInt32*)framebuffers);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteFramebuffersEXT")]
            public static
            void DeleteFramebuffers(Int32 n, UInt32[] framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* framebuffers_ptr = framebuffers)
                        {
                            Delegates.glDeleteFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteFramebuffersEXT")]
            public static
            void DeleteFramebuffers(Int32 n, ref UInt32 framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* framebuffers_ptr = &framebuffers)
                        {
                            Delegates.glDeleteFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteFramebuffersEXT")]
            public static
            unsafe void DeleteFramebuffers(Int32 n, UInt32* framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFramebuffersEXT((Int32)n, (UInt32*)framebuffers);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteRenderbuffersEXT")]
            public static
            void DeleteRenderbuffers(Int32 n, Int32[] renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* renderbuffers_ptr = renderbuffers)
                        {
                            Delegates.glDeleteRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteRenderbuffersEXT")]
            public static
            void DeleteRenderbuffers(Int32 n, ref Int32 renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* renderbuffers_ptr = &renderbuffers)
                        {
                            Delegates.glDeleteRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteRenderbuffersEXT")]
            public static
            unsafe void DeleteRenderbuffers(Int32 n, Int32* renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteRenderbuffersEXT")]
            public static
            void DeleteRenderbuffers(Int32 n, UInt32[] renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* renderbuffers_ptr = renderbuffers)
                        {
                            Delegates.glDeleteRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteRenderbuffersEXT")]
            public static
            void DeleteRenderbuffers(Int32 n, ref UInt32 renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* renderbuffers_ptr = &renderbuffers)
                        {
                            Delegates.glDeleteRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glDeleteRenderbuffersEXT")]
            public static
            unsafe void DeleteRenderbuffers(Int32 n, UInt32* renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named textures
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be deleted.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array of textures to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glDeleteTexturesEXT")]
            public static
            void DeleteTextures(Int32 n, Int32[] textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = textures)
                        {
                            Delegates.glDeleteTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named textures
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be deleted.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array of textures to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glDeleteTexturesEXT")]
            public static
            void DeleteTextures(Int32 n, ref Int32 textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = &textures)
                        {
                            Delegates.glDeleteTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named textures
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be deleted.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array of textures to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glDeleteTexturesEXT")]
            public static
            unsafe void DeleteTextures(Int32 n, Int32* textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteTexturesEXT((Int32)n, (UInt32*)textures);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named textures
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be deleted.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array of textures to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glDeleteTexturesEXT")]
            public static
            void DeleteTextures(Int32 n, UInt32[] textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = textures)
                        {
                            Delegates.glDeleteTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named textures
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be deleted.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array of textures to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glDeleteTexturesEXT")]
            public static
            void DeleteTextures(Int32 n, ref UInt32 textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = &textures)
                        {
                            Delegates.glDeleteTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named textures
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be deleted.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array of textures to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glDeleteTexturesEXT")]
            public static
            unsafe void DeleteTextures(Int32 n, UInt32* textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteTexturesEXT((Int32)n, (UInt32*)textures);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glDeleteVertexShaderEXT")]
            public static
            void DeleteVertexShader(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteVertexShaderEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glDeleteVertexShaderEXT")]
            public static
            void DeleteVertexShader(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteVertexShaderEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDepthBoundsTest", Version = "1.2", EntryPoint = "glDepthBoundsEXT")]
            public static
            void DepthBounds(Double zmin, Double zmax)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDepthBoundsEXT((Double)zmin, (Double)zmax);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glDisableClientStateIndexedEXT")]
            public static
            void DisableClientStateIndexed(OpenTK.Graphics.OpenGL.EnableCap array, Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableClientStateIndexedEXT((OpenTK.Graphics.OpenGL.EnableCap)array, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glDisableClientStateIndexedEXT")]
            public static
            void DisableClientStateIndexed(OpenTK.Graphics.OpenGL.EnableCap array, UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableClientStateIndexedEXT((OpenTK.Graphics.OpenGL.EnableCap)array, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glDisableIndexedEXT")]
            public static
            void DisableIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableIndexedEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glDisableIndexedEXT")]
            public static
            void DisableIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableIndexedEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glDisableVariantClientStateEXT")]
            public static
            void DisableVariantClientState(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableVariantClientStateEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glDisableVariantClientStateEXT")]
            public static
            void DisableVariantClientState(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableVariantClientStateEXT((UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Specifies the starting index in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of indices to be rendered.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glDrawArraysEXT")]
            public static
            void DrawArrays(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 first, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawArraysEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)first, (Int32)count);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawInstanced", Version = "2.0", EntryPoint = "glDrawArraysInstancedEXT")]
            public static
            void DrawArraysInstanced(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawArraysInstancedEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)start, (Int32)count, (Int32)primcount);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedEXT")]
            public static
            void DrawElementsInstanced(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedEXT")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedEXT")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedEXT")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedEXT")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        indices = (T3)indices_ptr.Target;
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                        indices = (T5)indices_ptr.Target;
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="start">
            /// <para>
            /// Specifies the minimum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="end">
            /// <para>
            /// Specifies the maximum array index contained in indices.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements to be rendered.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawRangeElements", Version = "1.1", EntryPoint = "glDrawRangeElementsEXT")]
            public static
            void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawRangeElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                        indices = (T5)indices_ptr.Target;
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of edge flags
            /// </summary>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glEdgeFlagPointerEXT")]
            public static
            void EdgeFlagPointer(Int32 stride, Int32 count, bool[] pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* pointer_ptr = pointer)
                        {
                            Delegates.glEdgeFlagPointerEXT((Int32)stride, (Int32)count, (bool*)pointer_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of edge flags
            /// </summary>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glEdgeFlagPointerEXT")]
            public static
            void EdgeFlagPointer(Int32 stride, Int32 count, ref bool pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* pointer_ptr = &pointer)
                        {
                            Delegates.glEdgeFlagPointerEXT((Int32)stride, (Int32)count, (bool*)pointer_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of edge flags
            /// </summary>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glEdgeFlagPointerEXT")]
            public static
            unsafe void EdgeFlagPointer(Int32 stride, Int32 count, bool* pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEdgeFlagPointerEXT((Int32)stride, (Int32)count, (bool*)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glEnableClientStateIndexedEXT")]
            public static
            void EnableClientStateIndexed(OpenTK.Graphics.OpenGL.EnableCap array, Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableClientStateIndexedEXT((OpenTK.Graphics.OpenGL.EnableCap)array, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glEnableClientStateIndexedEXT")]
            public static
            void EnableClientStateIndexed(OpenTK.Graphics.OpenGL.EnableCap array, UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableClientStateIndexedEXT((OpenTK.Graphics.OpenGL.EnableCap)array, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glEnableIndexedEXT")]
            public static
            void EnableIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableIndexedEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glEnableIndexedEXT")]
            public static
            void EnableIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableIndexedEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glEnableVariantClientStateEXT")]
            public static
            void EnableVariantClientState(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableVariantClientStateEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glEnableVariantClientStateEXT")]
            public static
            void EnableVariantClientState(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableVariantClientStateEXT((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glEndTransformFeedbackEXT")]
            public static
            void EndTransformFeedback()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndTransformFeedbackEXT();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glEndVertexShaderEXT")]
            public static
            void EndVertexShader()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndVertexShaderEXT();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glExtractComponentEXT")]
            public static
            void ExtractComponent(Int32 res, Int32 src, Int32 num)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glExtractComponentEXT((UInt32)res, (UInt32)src, (UInt32)num);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glExtractComponentEXT")]
            public static
            void ExtractComponent(UInt32 res, UInt32 src, UInt32 num)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glExtractComponentEXT((UInt32)res, (UInt32)src, (UInt32)num);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current fog coordinates
            /// </summary>
            /// <param name="coord">
            /// <para>
            /// Specify the fog distance.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoorddEXT")]
            public static
            void FogCoord(Double coord)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoorddEXT((Double)coord);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current fog coordinates
            /// </summary>
            /// <param name="coord">
            /// <para>
            /// Specify the fog distance.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoorddvEXT")]
            public static
            unsafe void FogCoord(Double* coord)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoorddvEXT((Double*)coord);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current fog coordinates
            /// </summary>
            /// <param name="coord">
            /// <para>
            /// Specify the fog distance.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordfEXT")]
            public static
            void FogCoord(Single coord)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoordfEXT((Single)coord);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current fog coordinates
            /// </summary>
            /// <param name="coord">
            /// <para>
            /// Specify the fog distance.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordfvEXT")]
            public static
            unsafe void FogCoord(Single* coord)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoordfvEXT((Single*)coord);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of fog coordinates
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordPointerEXT")]
            public static
            void FogCoordPointer(OpenTK.Graphics.OpenGL.ExtFogCoord type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoordPointerEXT((OpenTK.Graphics.OpenGL.ExtFogCoord)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of fog coordinates
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordPointerEXT")]
            public static
            void FogCoordPointer<T2>(OpenTK.Graphics.OpenGL.ExtFogCoord type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerEXT((OpenTK.Graphics.OpenGL.ExtFogCoord)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of fog coordinates
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordPointerEXT")]
            public static
            void FogCoordPointer<T2>(OpenTK.Graphics.OpenGL.ExtFogCoord type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerEXT((OpenTK.Graphics.OpenGL.ExtFogCoord)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of fog coordinates
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordPointerEXT")]
            public static
            void FogCoordPointer<T2>(OpenTK.Graphics.OpenGL.ExtFogCoord type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerEXT((OpenTK.Graphics.OpenGL.ExtFogCoord)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of fog coordinates
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtFogCoord", Version = "1.1", EntryPoint = "glFogCoordPointerEXT")]
            public static
            void FogCoordPointer<T2>(OpenTK.Graphics.OpenGL.ExtFogCoord type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerEXT((OpenTK.Graphics.OpenGL.ExtFogCoord)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBufferEXT")]
            public static
            void FramebufferDrawBuffer(Int32 framebuffer, OpenTK.Graphics.OpenGL.DrawBufferMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferDrawBufferEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.DrawBufferMode)mode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBufferEXT")]
            public static
            void FramebufferDrawBuffer(UInt32 framebuffer, OpenTK.Graphics.OpenGL.DrawBufferMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferDrawBufferEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.DrawBufferMode)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBuffersEXT")]
            public static
            void FramebufferDrawBuffers(Int32 framebuffer, Int32 n, OpenTK.Graphics.OpenGL.DrawBufferMode[] bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.DrawBufferMode* bufs_ptr = bufs)
                        {
                            Delegates.glFramebufferDrawBuffersEXT((UInt32)framebuffer, (Int32)n, (OpenTK.Graphics.OpenGL.DrawBufferMode*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBuffersEXT")]
            public static
            void FramebufferDrawBuffers(Int32 framebuffer, Int32 n, ref OpenTK.Graphics.OpenGL.DrawBufferMode bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.DrawBufferMode* bufs_ptr = &bufs)
                        {
                            Delegates.glFramebufferDrawBuffersEXT((UInt32)framebuffer, (Int32)n, (OpenTK.Graphics.OpenGL.DrawBufferMode*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBuffersEXT")]
            public static
            unsafe void FramebufferDrawBuffers(Int32 framebuffer, Int32 n, OpenTK.Graphics.OpenGL.DrawBufferMode* bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferDrawBuffersEXT((UInt32)framebuffer, (Int32)n, (OpenTK.Graphics.OpenGL.DrawBufferMode*)bufs);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBuffersEXT")]
            public static
            void FramebufferDrawBuffers(UInt32 framebuffer, Int32 n, OpenTK.Graphics.OpenGL.DrawBufferMode[] bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.DrawBufferMode* bufs_ptr = bufs)
                        {
                            Delegates.glFramebufferDrawBuffersEXT((UInt32)framebuffer, (Int32)n, (OpenTK.Graphics.OpenGL.DrawBufferMode*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBuffersEXT")]
            public static
            void FramebufferDrawBuffers(UInt32 framebuffer, Int32 n, ref OpenTK.Graphics.OpenGL.DrawBufferMode bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.DrawBufferMode* bufs_ptr = &bufs)
                        {
                            Delegates.glFramebufferDrawBuffersEXT((UInt32)framebuffer, (Int32)n, (OpenTK.Graphics.OpenGL.DrawBufferMode*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferDrawBuffersEXT")]
            public static
            unsafe void FramebufferDrawBuffers(UInt32 framebuffer, Int32 n, OpenTK.Graphics.OpenGL.DrawBufferMode* bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferDrawBuffersEXT((UInt32)framebuffer, (Int32)n, (OpenTK.Graphics.OpenGL.DrawBufferMode*)bufs);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferReadBufferEXT")]
            public static
            void FramebufferReadBuffer(Int32 framebuffer, OpenTK.Graphics.OpenGL.ReadBufferMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferReadBufferEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ReadBufferMode)mode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glFramebufferReadBufferEXT")]
            public static
            void FramebufferReadBuffer(UInt32 framebuffer, OpenTK.Graphics.OpenGL.ReadBufferMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferReadBufferEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ReadBufferMode)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferRenderbufferEXT")]
            public static
            void FramebufferRenderbuffer(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.RenderbufferTarget renderbuffertarget, Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferRenderbufferEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferRenderbufferEXT")]
            public static
            void FramebufferRenderbuffer(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.RenderbufferTarget renderbuffertarget, UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferRenderbufferEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferTexture1DEXT")]
            public static
            void FramebufferTexture1D(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTexture1DEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferTexture1DEXT")]
            public static
            void FramebufferTexture1D(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTexture1DEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferTexture2DEXT")]
            public static
            void FramebufferTexture2D(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTexture2DEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferTexture2DEXT")]
            public static
            void FramebufferTexture2D(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTexture2DEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferTexture3DEXT")]
            public static
            void FramebufferTexture3D(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, Int32 texture, Int32 level, Int32 zoffset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTexture3DEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level, (Int32)zoffset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glFramebufferTexture3DEXT")]
            public static
            void FramebufferTexture3D(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, UInt32 texture, Int32 level, Int32 zoffset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTexture3DEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level, (Int32)zoffset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glFramebufferTextureEXT")]
            public static
            void FramebufferTexture(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glFramebufferTextureEXT")]
            public static
            void FramebufferTexture(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glFramebufferTextureFaceEXT")]
            public static
            void FramebufferTextureFace(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level, OpenTK.Graphics.OpenGL.TextureTarget face)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureFaceEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.TextureTarget)face);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glFramebufferTextureFaceEXT")]
            public static
            void FramebufferTextureFace(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level, OpenTK.Graphics.OpenGL.TextureTarget face)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureFaceEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.TextureTarget)face);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glFramebufferTextureLayerEXT")]
            public static
            void FramebufferTextureLayer(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 layer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureLayerEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glFramebufferTextureLayerEXT")]
            public static
            void FramebufferTextureLayer(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 layer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureLayerEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenerateMipmapEXT")]
            public static
            void GenerateMipmap(OpenTK.Graphics.OpenGL.GenerateMipmapTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenerateMipmapEXT((OpenTK.Graphics.OpenGL.GenerateMipmapTarget)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGenerateMultiTexMipmapEXT")]
            public static
            void GenerateMultiTexMipmap(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenerateMultiTexMipmapEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGenerateTextureMipmapEXT")]
            public static
            void GenerateTextureMipmap(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenerateTextureMipmapEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGenerateTextureMipmapEXT")]
            public static
            void GenerateTextureMipmap(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenerateTextureMipmapEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenFramebuffersEXT")]
            public static
            void GenFramebuffers(Int32 n, [OutAttribute] Int32[] framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* framebuffers_ptr = framebuffers)
                        {
                            Delegates.glGenFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenFramebuffersEXT")]
            public static
            void GenFramebuffers(Int32 n, [OutAttribute] out Int32 framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* framebuffers_ptr = &framebuffers)
                        {
                            Delegates.glGenFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                            framebuffers = *framebuffers_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenFramebuffersEXT")]
            public static
            unsafe void GenFramebuffers(Int32 n, [OutAttribute] Int32* framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenFramebuffersEXT((Int32)n, (UInt32*)framebuffers);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenFramebuffersEXT")]
            public static
            void GenFramebuffers(Int32 n, [OutAttribute] UInt32[] framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* framebuffers_ptr = framebuffers)
                        {
                            Delegates.glGenFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenFramebuffersEXT")]
            public static
            void GenFramebuffers(Int32 n, [OutAttribute] out UInt32 framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* framebuffers_ptr = &framebuffers)
                        {
                            Delegates.glGenFramebuffersEXT((Int32)n, (UInt32*)framebuffers_ptr);
                            framebuffers = *framebuffers_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenFramebuffersEXT")]
            public static
            unsafe void GenFramebuffers(Int32 n, [OutAttribute] UInt32* framebuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenFramebuffersEXT((Int32)n, (UInt32*)framebuffers);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenRenderbuffersEXT")]
            public static
            void GenRenderbuffers(Int32 n, [OutAttribute] Int32[] renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* renderbuffers_ptr = renderbuffers)
                        {
                            Delegates.glGenRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenRenderbuffersEXT")]
            public static
            void GenRenderbuffers(Int32 n, [OutAttribute] out Int32 renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* renderbuffers_ptr = &renderbuffers)
                        {
                            Delegates.glGenRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                            renderbuffers = *renderbuffers_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenRenderbuffersEXT")]
            public static
            unsafe void GenRenderbuffers(Int32 n, [OutAttribute] Int32* renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenRenderbuffersEXT")]
            public static
            void GenRenderbuffers(Int32 n, [OutAttribute] UInt32[] renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* renderbuffers_ptr = renderbuffers)
                        {
                            Delegates.glGenRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenRenderbuffersEXT")]
            public static
            void GenRenderbuffers(Int32 n, [OutAttribute] out UInt32 renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* renderbuffers_ptr = &renderbuffers)
                        {
                            Delegates.glGenRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers_ptr);
                            renderbuffers = *renderbuffers_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGenRenderbuffersEXT")]
            public static
            unsafe void GenRenderbuffers(Int32 n, [OutAttribute] UInt32* renderbuffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenRenderbuffersEXT((Int32)n, (UInt32*)renderbuffers);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGenSymbolsEXT")]
            public static
            Int32 GenSymbol(OpenTK.Graphics.OpenGL.ExtVertexShader datatype, OpenTK.Graphics.OpenGL.ExtVertexShader storagetype, OpenTK.Graphics.OpenGL.ExtVertexShader range, Int32 components)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenSymbolsEXT((OpenTK.Graphics.OpenGL.ExtVertexShader)datatype, (OpenTK.Graphics.OpenGL.ExtVertexShader)storagetype, (OpenTK.Graphics.OpenGL.ExtVertexShader)range, (UInt32)components);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGenSymbolsEXT")]
            public static
            Int32 GenSymbol(OpenTK.Graphics.OpenGL.ExtVertexShader datatype, OpenTK.Graphics.OpenGL.ExtVertexShader storagetype, OpenTK.Graphics.OpenGL.ExtVertexShader range, UInt32 components)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenSymbolsEXT((OpenTK.Graphics.OpenGL.ExtVertexShader)datatype, (OpenTK.Graphics.OpenGL.ExtVertexShader)storagetype, (OpenTK.Graphics.OpenGL.ExtVertexShader)range, (UInt32)components);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate texture names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of texture names to be generated.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array in which the generated texture names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glGenTexturesEXT")]
            public static
            void GenTextures(Int32 n, [OutAttribute] Int32[] textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = textures)
                        {
                            Delegates.glGenTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate texture names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of texture names to be generated.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array in which the generated texture names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glGenTexturesEXT")]
            public static
            void GenTextures(Int32 n, [OutAttribute] out Int32 textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = &textures)
                        {
                            Delegates.glGenTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                            textures = *textures_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate texture names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of texture names to be generated.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array in which the generated texture names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glGenTexturesEXT")]
            public static
            unsafe void GenTextures(Int32 n, [OutAttribute] Int32* textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenTexturesEXT((Int32)n, (UInt32*)textures);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate texture names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of texture names to be generated.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array in which the generated texture names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glGenTexturesEXT")]
            public static
            void GenTextures(Int32 n, [OutAttribute] UInt32[] textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = textures)
                        {
                            Delegates.glGenTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate texture names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of texture names to be generated.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array in which the generated texture names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glGenTexturesEXT")]
            public static
            void GenTextures(Int32 n, [OutAttribute] out UInt32 textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = &textures)
                        {
                            Delegates.glGenTexturesEXT((Int32)n, (UInt32*)textures_ptr);
                            textures = *textures_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate texture names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of texture names to be generated.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array in which the generated texture names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glGenTexturesEXT")]
            public static
            unsafe void GenTextures(Int32 n, [OutAttribute] UInt32* textures)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenTexturesEXT((Int32)n, (UInt32*)textures);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGenVertexShadersEXT")]
            public static
            Int32 GenVertexShaders(Int32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenVertexShadersEXT((UInt32)range);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGenVertexShadersEXT")]
            public static
            Int32 GenVertexShaders(UInt32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenVertexShadersEXT((UInt32)range);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glGetBooleanIndexedvEXT")]
            public static
            void GetBooleanIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, Int32 index, [OutAttribute] bool[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = data)
                        {
                            Delegates.glGetBooleanIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index, (bool*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glGetBooleanIndexedvEXT")]
            public static
            void GetBooleanIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, Int32 index, [OutAttribute] out bool data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = &data)
                        {
                            Delegates.glGetBooleanIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index, (bool*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glGetBooleanIndexedvEXT")]
            public static
            unsafe void GetBooleanIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, Int32 index, [OutAttribute] bool* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetBooleanIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index, (bool*)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glGetBooleanIndexedvEXT")]
            public static
            void GetBooleanIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, UInt32 index, [OutAttribute] bool[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = data)
                        {
                            Delegates.glGetBooleanIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index, (bool*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glGetBooleanIndexedvEXT")]
            public static
            void GetBooleanIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, UInt32 index, [OutAttribute] out bool data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = &data)
                        {
                            Delegates.glGetBooleanIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index, (bool*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glGetBooleanIndexedvEXT")]
            public static
            unsafe void GetBooleanIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, UInt32 index, [OutAttribute] bool* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetBooleanIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index, (bool*)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableEXT")]
            public static
            void GetColorTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableEXT")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableEXT")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableEXT")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableEXT")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableParameterfvEXT")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetColorTableParameterfvEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableParameterfvEXT")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetColorTableParameterfvEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableParameterfvEXT")]
            public static
            unsafe void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetColorTableParameterfvEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableParameterivEXT")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetColorTableParameterivEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableParameterivEXT")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetColorTableParameterivEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtPalettedTexture", Version = "1.1", EntryPoint = "glGetColorTableParameterivEXT")]
            public static
            unsafe void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetColorTableParameterivEXT((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedMultiTexImageEXT")]
            public static
            void GetCompressedMultiTexImage(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [OutAttribute] IntPtr img)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCompressedMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedMultiTexImageEXT")]
            public static
            void GetCompressedMultiTexImage<T3>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedMultiTexImageEXT")]
            public static
            void GetCompressedMultiTexImage<T3>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[,] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedMultiTexImageEXT")]
            public static
            void GetCompressedMultiTexImage<T3>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[,,] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedMultiTexImageEXT")]
            public static
            void GetCompressedMultiTexImage<T3>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] ref T3 img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                        img = (T3)img_ptr.Target;
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [OutAttribute] IntPtr img)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[,] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[,,] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] ref T3 img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                        img = (T3)img_ptr.Target;
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [OutAttribute] IntPtr img)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[,] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] T3[,,] img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetCompressedTextureImageEXT")]
            public static
            void GetCompressedTextureImage<T3>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 lod, [InAttribute, OutAttribute] ref T3 img)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)lod, (IntPtr)img_ptr.AddrOfPinnedObject());
                        img = (T3)img_ptr.Target;
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get current 1D or 2D convolution filter kernel
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="image">
            /// <para>
            /// Pointer to storage for the output image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionFilterEXT")]
            public static
            void GetConvolutionFilter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr image)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetConvolutionFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get current 1D or 2D convolution filter kernel
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="image">
            /// <para>
            /// Pointer to storage for the output image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionFilterEXT")]
            public static
            void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] image)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetConvolutionFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get current 1D or 2D convolution filter kernel
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="image">
            /// <para>
            /// Pointer to storage for the output image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionFilterEXT")]
            public static
            void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] image)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetConvolutionFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get current 1D or 2D convolution filter kernel
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="image">
            /// <para>
            /// Pointer to storage for the output image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionFilterEXT")]
            public static
            void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] image)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetConvolutionFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get current 1D or 2D convolution filter kernel
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="image">
            /// <para>
            /// Pointer to storage for the output image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionFilterEXT")]
            public static
            void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 image)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetConvolutionFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                        image = (T3)image_ptr.Target;
                    }
                    finally
                    {
                        image_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the parameters to be retrieved.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionParameterfvEXT")]
            public static
            void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetConvolutionParameterfvEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the parameters to be retrieved.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionParameterfvEXT")]
            public static
            void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetConvolutionParameterfvEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the parameters to be retrieved.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionParameterfvEXT")]
            public static
            unsafe void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetConvolutionParameterfvEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the parameters to be retrieved.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionParameterivEXT")]
            public static
            void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetConvolutionParameterivEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the parameters to be retrieved.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionParameterivEXT")]
            public static
            void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetConvolutionParameterivEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get convolution parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the parameters to be retrieved.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetConvolutionParameterivEXT")]
            public static
            unsafe void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.ExtConvolution pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetConvolutionParameterivEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.ExtConvolution)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetDoubleIndexedvEXT")]
            public static
            void GetDoubleIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Double[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* data_ptr = data)
                        {
                            Delegates.glGetDoubleIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetDoubleIndexedvEXT")]
            public static
            void GetDoubleIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] out Double data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* data_ptr = &data)
                        {
                            Delegates.glGetDoubleIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetDoubleIndexedvEXT")]
            public static
            unsafe void GetDoubleIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Double* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetDoubleIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetDoubleIndexedvEXT")]
            public static
            void GetDoubleIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Double[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* data_ptr = data)
                        {
                            Delegates.glGetDoubleIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetDoubleIndexedvEXT")]
            public static
            void GetDoubleIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] out Double data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* data_ptr = &data)
                        {
                            Delegates.glGetDoubleIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetDoubleIndexedvEXT")]
            public static
            unsafe void GetDoubleIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Double* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetDoubleIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFloatIndexedvEXT")]
            public static
            void GetFloatIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Single[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = data)
                        {
                            Delegates.glGetFloatIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFloatIndexedvEXT")]
            public static
            void GetFloatIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] out Single data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = &data)
                        {
                            Delegates.glGetFloatIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFloatIndexedvEXT")]
            public static
            unsafe void GetFloatIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Single* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFloatIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFloatIndexedvEXT")]
            public static
            void GetFloatIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Single[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = data)
                        {
                            Delegates.glGetFloatIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFloatIndexedvEXT")]
            public static
            void GetFloatIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] out Single data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = &data)
                        {
                            Delegates.glGetFloatIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFloatIndexedvEXT")]
            public static
            unsafe void GetFloatIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Single* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFloatIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetFragDataLocationEXT")]
            public static
            Int32 GetFragDataLocation(Int32 program, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetFragDataLocationEXT((UInt32)program, (String)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetFragDataLocationEXT")]
            public static
            Int32 GetFragDataLocation(UInt32 program, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetFragDataLocationEXT((UInt32)program, (String)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGetFramebufferAttachmentParameterivEXT")]
            public static
            void GetFramebufferAttachmentParameter(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.FramebufferParameterName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFramebufferAttachmentParameterivEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.FramebufferParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGetFramebufferAttachmentParameterivEXT")]
            public static
            void GetFramebufferAttachmentParameter(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.FramebufferParameterName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFramebufferAttachmentParameterivEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.FramebufferParameterName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGetFramebufferAttachmentParameterivEXT")]
            public static
            unsafe void GetFramebufferAttachmentParameter(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.FramebufferParameterName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFramebufferAttachmentParameterivEXT((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.FramebufferParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFramebufferParameterivEXT")]
            public static
            void GetFramebufferParameter(Int32 framebuffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFramebufferParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFramebufferParameterivEXT")]
            public static
            void GetFramebufferParameter(Int32 framebuffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFramebufferParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFramebufferParameterivEXT")]
            public static
            unsafe void GetFramebufferParameter(Int32 framebuffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFramebufferParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFramebufferParameterivEXT")]
            public static
            void GetFramebufferParameter(UInt32 framebuffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFramebufferParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFramebufferParameterivEXT")]
            public static
            void GetFramebufferParameter(UInt32 framebuffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFramebufferParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetFramebufferParameterivEXT")]
            public static
            unsafe void GetFramebufferParameter(UInt32 framebuffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFramebufferParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned histogram table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramEXT")]
            public static
            void GetHistogram(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr values)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned histogram table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramEXT")]
            public static
            void GetHistogram<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[] values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned histogram table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramEXT")]
            public static
            void GetHistogram<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,] values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned histogram table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramEXT")]
            public static
            void GetHistogram<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,,] values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned histogram table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramEXT")]
            public static
            void GetHistogram<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T4 values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                        values = (T4)values_ptr.Target;
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramParameterfvEXT")]
            public static
            void GetHistogramParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetHistogramParameterfvEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramParameterfvEXT")]
            public static
            void GetHistogramParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetHistogramParameterfvEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the returned values.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramParameterfvEXT")]
            public static
            unsafe void GetHistogramParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetHistogramParameterfvEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramParameterivEXT")]
            public static
            void GetHistogramParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetHistogramParameterivEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramParameterivEXT")]
            public static
            void GetHistogramParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetHistogramParameterivEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get histogram parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Pointer to storage for the returned values.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetHistogramParameterivEXT")]
            public static
            unsafe void GetHistogramParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetHistogramParameterivEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minimum and maximum pixel values
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxEXT")]
            public static
            void GetMinmax(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr values)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minimum and maximum pixel values
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxEXT")]
            public static
            void GetMinmax<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[] values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minimum and maximum pixel values
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxEXT")]
            public static
            void GetMinmax<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,] values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minimum and maximum pixel values
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxEXT")]
            public static
            void GetMinmax<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,,] values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minimum and maximum pixel values
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="reset">
            /// <para>
            /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="types">
            /// <para>
            /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="values">
            /// <para>
            /// A pointer to storage for the returned values.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxEXT")]
            public static
            void GetMinmax<T4>(OpenTK.Graphics.OpenGL.ExtHistogram target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T4 values)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                        values = (T4)values_ptr.Target;
                    }
                    finally
                    {
                        values_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minmax parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to storage for the retrieved parameters.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxParameterfvEXT")]
            public static
            void GetMinmaxParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMinmaxParameterfvEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minmax parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to storage for the retrieved parameters.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxParameterfvEXT")]
            public static
            void GetMinmaxParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMinmaxParameterfvEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minmax parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to storage for the retrieved parameters.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxParameterfvEXT")]
            public static
            unsafe void GetMinmaxParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMinmaxParameterfvEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minmax parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to storage for the retrieved parameters.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxParameterivEXT")]
            public static
            void GetMinmaxParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMinmaxParameterivEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minmax parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to storage for the retrieved parameters.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxParameterivEXT")]
            public static
            void GetMinmaxParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMinmaxParameterivEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get minmax parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to storage for the retrieved parameters.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glGetMinmaxParameterivEXT")]
            public static
            unsafe void GetMinmaxParameter(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.ExtHistogram pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMinmaxParameterivEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.ExtHistogram)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexEnvfvEXT")]
            public static
            void GetMultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexEnvfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexEnvfvEXT")]
            public static
            void GetMultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexEnvfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexEnvfvEXT")]
            public static
            unsafe void GetMultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexEnvfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexEnvivEXT")]
            public static
            void GetMultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexEnvivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexEnvivEXT")]
            public static
            void GetMultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexEnvivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexEnvivEXT")]
            public static
            unsafe void GetMultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexEnvivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGendvEXT")]
            public static
            void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexGendvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGendvEXT")]
            public static
            void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexGendvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGendvEXT")]
            public static
            unsafe void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexGendvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGenfvEXT")]
            public static
            void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexGenfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGenfvEXT")]
            public static
            void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexGenfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGenfvEXT")]
            public static
            unsafe void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexGenfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGenivEXT")]
            public static
            void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexGenivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGenivEXT")]
            public static
            void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexGenivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexGenivEXT")]
            public static
            unsafe void GetMultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexGenivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexImageEXT")]
            public static
            void GetMultiTexImage(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexImageEXT")]
            public static
            void GetMultiTexImage<T5>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexImageEXT")]
            public static
            void GetMultiTexImage<T5>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexImageEXT")]
            public static
            void GetMultiTexImage<T5>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexImageEXT")]
            public static
            void GetMultiTexImage<T5>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMultiTexImageEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T5)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexLevelParameterfvEXT")]
            public static
            void GetMultiTexLevelParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexLevelParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexLevelParameterfvEXT")]
            public static
            void GetMultiTexLevelParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexLevelParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexLevelParameterfvEXT")]
            public static
            unsafe void GetMultiTexLevelParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexLevelParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexLevelParameterivEXT")]
            public static
            void GetMultiTexLevelParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexLevelParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexLevelParameterivEXT")]
            public static
            void GetMultiTexLevelParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexLevelParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexLevelParameterivEXT")]
            public static
            unsafe void GetMultiTexLevelParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexLevelParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterfvEXT")]
            public static
            void GetMultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterfvEXT")]
            public static
            void GetMultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterfvEXT")]
            public static
            unsafe void GetMultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterIivEXT")]
            public static
            void GetMultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterIivEXT")]
            public static
            void GetMultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterIivEXT")]
            public static
            unsafe void GetMultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterIuivEXT")]
            public static
            void GetMultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterIuivEXT")]
            public static
            void GetMultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterIuivEXT")]
            public static
            unsafe void GetMultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterivEXT")]
            public static
            void GetMultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMultiTexParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterivEXT")]
            public static
            void GetMultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMultiTexParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetMultiTexParameterivEXT")]
            public static
            unsafe void GetMultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultiTexParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferParameterivEXT")]
            public static
            void GetNamedBufferParameter(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedBufferParameterivEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferParameterivEXT")]
            public static
            void GetNamedBufferParameter(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedBufferParameterivEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferParameterivEXT")]
            public static
            unsafe void GetNamedBufferParameter(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedBufferParameterivEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferParameterivEXT")]
            public static
            void GetNamedBufferParameter(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedBufferParameterivEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferParameterivEXT")]
            public static
            void GetNamedBufferParameter(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedBufferParameterivEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferParameterivEXT")]
            public static
            unsafe void GetNamedBufferParameter(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedBufferParameterivEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] IntPtr @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                        @params = (T2)@params_ptr.Target;
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] IntPtr @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferPointervEXT")]
            public static
            void GetNamedBufferPointer<T2>(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferPointervEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                        @params = (T2)@params_ptr.Target;
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData(Int32 buffer, IntPtr offset, IntPtr size, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData(UInt32 buffer, IntPtr offset, IntPtr size, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedBufferSubDataEXT")]
            public static
            void GetNamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedFramebufferAttachmentParameterivEXT")]
            public static
            void GetNamedFramebufferAttachmentParameter(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedFramebufferAttachmentParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedFramebufferAttachmentParameterivEXT")]
            public static
            void GetNamedFramebufferAttachmentParameter(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedFramebufferAttachmentParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedFramebufferAttachmentParameterivEXT")]
            public static
            unsafe void GetNamedFramebufferAttachmentParameter(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedFramebufferAttachmentParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedFramebufferAttachmentParameterivEXT")]
            public static
            void GetNamedFramebufferAttachmentParameter(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedFramebufferAttachmentParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedFramebufferAttachmentParameterivEXT")]
            public static
            void GetNamedFramebufferAttachmentParameter(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedFramebufferAttachmentParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedFramebufferAttachmentParameterivEXT")]
            public static
            unsafe void GetNamedFramebufferAttachmentParameter(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedFramebufferAttachmentParameterivEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramivEXT")]
            public static
            void GetNamedProgram(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramivEXT")]
            public static
            unsafe void GetNamedProgram(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramivEXT")]
            public static
            void GetNamedProgram(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramivEXT")]
            public static
            unsafe void GetNamedProgram(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterdvEXT")]
            public static
            void GetNamedProgramLocalParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterdvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterdvEXT")]
            public static
            void GetNamedProgramLocalParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterdvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterdvEXT")]
            public static
            unsafe void GetNamedProgramLocalParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterdvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterdvEXT")]
            public static
            void GetNamedProgramLocalParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterdvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterdvEXT")]
            public static
            void GetNamedProgramLocalParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterdvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterdvEXT")]
            public static
            unsafe void GetNamedProgramLocalParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterdvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterfvEXT")]
            public static
            void GetNamedProgramLocalParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterfvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterfvEXT")]
            public static
            void GetNamedProgramLocalParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterfvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterfvEXT")]
            public static
            unsafe void GetNamedProgramLocalParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterfvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterfvEXT")]
            public static
            void GetNamedProgramLocalParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterfvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterfvEXT")]
            public static
            void GetNamedProgramLocalParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterfvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterfvEXT")]
            public static
            unsafe void GetNamedProgramLocalParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterfvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIivEXT")]
            public static
            void GetNamedProgramLocalParameterI(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterIivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIivEXT")]
            public static
            void GetNamedProgramLocalParameterI(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterIivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIivEXT")]
            public static
            unsafe void GetNamedProgramLocalParameterI(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterIivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIivEXT")]
            public static
            void GetNamedProgramLocalParameterI(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterIivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIivEXT")]
            public static
            void GetNamedProgramLocalParameterI(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterIivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIivEXT")]
            public static
            unsafe void GetNamedProgramLocalParameterI(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterIivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIuivEXT")]
            public static
            void GetNamedProgramLocalParameterI(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedProgramLocalParameterIuivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIuivEXT")]
            public static
            void GetNamedProgramLocalParameterI(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedProgramLocalParameterIuivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramLocalParameterIuivEXT")]
            public static
            unsafe void GetNamedProgramLocalParameterI(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramLocalParameterIuivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T3[] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T3[,] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T3[,,] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] ref T3 @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T3)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [OutAttribute] IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T3[] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T3[,] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] T3[,,] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedProgramStringEXT")]
            public static
            void GetNamedProgramString<T3>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess pname, [InAttribute, OutAttribute] ref T3 @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T3)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedRenderbufferParameterivEXT")]
            public static
            void GetNamedRenderbufferParameter(Int32 renderbuffer, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedRenderbufferParameterivEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedRenderbufferParameterivEXT")]
            public static
            void GetNamedRenderbufferParameter(Int32 renderbuffer, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedRenderbufferParameterivEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedRenderbufferParameterivEXT")]
            public static
            unsafe void GetNamedRenderbufferParameter(Int32 renderbuffer, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedRenderbufferParameterivEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedRenderbufferParameterivEXT")]
            public static
            void GetNamedRenderbufferParameter(UInt32 renderbuffer, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetNamedRenderbufferParameterivEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedRenderbufferParameterivEXT")]
            public static
            void GetNamedRenderbufferParameter(UInt32 renderbuffer, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetNamedRenderbufferParameterivEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetNamedRenderbufferParameterivEXT")]
            public static
            unsafe void GetNamedRenderbufferParameter(UInt32 renderbuffer, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetNamedRenderbufferParameterivEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [InAttribute, OutAttribute] T2[] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [InAttribute, OutAttribute] T2[,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [InAttribute, OutAttribute] T2[,,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, [InAttribute, OutAttribute] ref T2 data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [InAttribute, OutAttribute] T2[] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [InAttribute, OutAttribute] T2[,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [InAttribute, OutAttribute] T2[,,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetPointerIndexedvEXT")]
            public static
            void GetPointerIndexed<T2>(OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, [InAttribute, OutAttribute] ref T2 data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointerIndexedvEXT((OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glGetPointervEXT")]
            public static
            void GetPointer(OpenTK.Graphics.OpenGL.GetPointervPName pname, [OutAttribute] IntPtr @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPointervEXT((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glGetPointervEXT")]
            public static
            void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] T1[] @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointervEXT((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glGetPointervEXT")]
            public static
            void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] T1[,] @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointervEXT((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glGetPointervEXT")]
            public static
            void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] T1[,,] @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointervEXT((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glGetPointervEXT")]
            public static
            void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] ref T1 @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPointervEXT((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                        @params = (T1)@params_ptr.Target;
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGetRenderbufferParameterivEXT")]
            public static
            void GetRenderbufferParameter(OpenTK.Graphics.OpenGL.RenderbufferTarget target, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetRenderbufferParameterivEXT((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGetRenderbufferParameterivEXT")]
            public static
            void GetRenderbufferParameter(OpenTK.Graphics.OpenGL.RenderbufferTarget target, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetRenderbufferParameterivEXT((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glGetRenderbufferParameterivEXT")]
            public static
            unsafe void GetRenderbufferParameter(OpenTK.Graphics.OpenGL.RenderbufferTarget target, OpenTK.Graphics.OpenGL.RenderbufferParameterName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetRenderbufferParameterivEXT((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (OpenTK.Graphics.OpenGL.RenderbufferParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [OutAttribute] IntPtr span)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[] span)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,] span)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,,] span)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] ref T5 span)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                        span = (T5)span_ptr.Target;
                    }
                    finally
                    {
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[] column, [InAttribute, OutAttribute] T5[,,] span)
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,] column, [InAttribute, OutAttribute] T5[,,] span)
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] ref T4 column, [InAttribute, OutAttribute] T5[,,] span)
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                        column = (T4)column_ptr.Target;
                    }
                    finally
                    {
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
                where T3 : struct
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
                where T3 : struct
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
                where T3 : struct
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get separable convolution filter kernel images
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to storage for the row filter image.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to storage for the column filter image.
            /// </para>
            /// </param>
            /// <param name="span">
            /// <para>
            /// Pointer to storage for the span filter image (currently unused).
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glGetSeparableFilterEXT")]
            public static
            void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
                where T3 : struct
                where T4 : struct
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetSeparableFilterEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                        row = (T3)row_ptr.Target;
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                        span_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glGetTexParameterIivEXT")]
            public static
            void GetTexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glGetTexParameterIivEXT")]
            public static
            void GetTexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glGetTexParameterIivEXT")]
            public static
            unsafe void GetTexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glGetTexParameterIuivEXT")]
            public static
            void GetTexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glGetTexParameterIuivEXT")]
            public static
            void GetTexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glGetTexParameterIuivEXT")]
            public static
            unsafe void GetTexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T5)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureImageEXT")]
            public static
            void GetTextureImage<T5>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 pixels)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTextureImageEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T5)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterfvEXT")]
            public static
            void GetTextureLevelParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetTextureLevelParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterfvEXT")]
            public static
            void GetTextureLevelParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureLevelParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterfvEXT")]
            public static
            unsafe void GetTextureLevelParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureLevelParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterfvEXT")]
            public static
            void GetTextureLevelParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetTextureLevelParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterfvEXT")]
            public static
            void GetTextureLevelParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureLevelParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterfvEXT")]
            public static
            unsafe void GetTextureLevelParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureLevelParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterivEXT")]
            public static
            void GetTextureLevelParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureLevelParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterivEXT")]
            public static
            void GetTextureLevelParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureLevelParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterivEXT")]
            public static
            unsafe void GetTextureLevelParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureLevelParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterivEXT")]
            public static
            void GetTextureLevelParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureLevelParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterivEXT")]
            public static
            void GetTextureLevelParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureLevelParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureLevelParameterivEXT")]
            public static
            unsafe void GetTextureLevelParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureLevelParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterfvEXT")]
            public static
            void GetTextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterfvEXT")]
            public static
            void GetTextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterfvEXT")]
            public static
            unsafe void GetTextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterfvEXT")]
            public static
            void GetTextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterfvEXT")]
            public static
            void GetTextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterfvEXT")]
            public static
            unsafe void GetTextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIivEXT")]
            public static
            void GetTextureParameterI(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIivEXT")]
            public static
            void GetTextureParameterI(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIivEXT")]
            public static
            unsafe void GetTextureParameterI(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIivEXT")]
            public static
            void GetTextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIivEXT")]
            public static
            void GetTextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIivEXT")]
            public static
            unsafe void GetTextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIuivEXT")]
            public static
            void GetTextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterIuivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIuivEXT")]
            public static
            void GetTextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterIuivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterIuivEXT")]
            public static
            unsafe void GetTextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterIuivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterivEXT")]
            public static
            void GetTextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterivEXT")]
            public static
            void GetTextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterivEXT")]
            public static
            unsafe void GetTextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterivEXT")]
            public static
            void GetTextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterivEXT")]
            public static
            void GetTextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glGetTextureParameterivEXT")]
            public static
            unsafe void GetTextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glGetTransformFeedbackVaryingEXT")]
            public static
            void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.ExtTransformFeedback type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.ExtTransformFeedback* type_ptr = &type)
                        {
                            Delegates.glGetTransformFeedbackVaryingEXT((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.ExtTransformFeedback*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glGetTransformFeedbackVaryingEXT")]
            public static
            unsafe void GetTransformFeedbackVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.ExtTransformFeedback* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTransformFeedbackVaryingEXT((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.ExtTransformFeedback*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glGetTransformFeedbackVaryingEXT")]
            public static
            void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.ExtTransformFeedback type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.ExtTransformFeedback* type_ptr = &type)
                        {
                            Delegates.glGetTransformFeedbackVaryingEXT((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.ExtTransformFeedback*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glGetTransformFeedbackVaryingEXT")]
            public static
            unsafe void GetTransformFeedbackVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.ExtTransformFeedback* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTransformFeedbackVaryingEXT((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.ExtTransformFeedback*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtBindableUniform", Version = "2.0", EntryPoint = "glGetUniformBufferSizeEXT")]
            public static
            Int32 GetUniformBufferSize(Int32 program, Int32 location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetUniformBufferSizeEXT((UInt32)program, (Int32)location);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtBindableUniform", Version = "2.0", EntryPoint = "glGetUniformBufferSizeEXT")]
            public static
            Int32 GetUniformBufferSize(UInt32 program, Int32 location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetUniformBufferSizeEXT((UInt32)program, (Int32)location);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtBindableUniform", Version = "2.0", EntryPoint = "glGetUniformOffsetEXT")]
            public static
            IntPtr GetUniformOffset(Int32 program, Int32 location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetUniformOffsetEXT((UInt32)program, (Int32)location);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtBindableUniform", Version = "2.0", EntryPoint = "glGetUniformOffsetEXT")]
            public static
            IntPtr GetUniformOffset(UInt32 program, Int32 location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetUniformOffsetEXT((UInt32)program, (Int32)location);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetUniformuivEXT")]
            public static
            void GetUniform(Int32 program, Int32 location, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetUniformuivEXT((UInt32)program, (Int32)location, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetUniformuivEXT")]
            public static
            void GetUniform(Int32 program, Int32 location, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetUniformuivEXT((UInt32)program, (Int32)location, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetUniformuivEXT")]
            public static
            unsafe void GetUniform(Int32 program, Int32 location, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetUniformuivEXT((UInt32)program, (Int32)location, (UInt32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetUniformuivEXT")]
            public static
            void GetUniform(UInt32 program, Int32 location, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetUniformuivEXT((UInt32)program, (Int32)location, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetUniformuivEXT")]
            public static
            void GetUniform(UInt32 program, Int32 location, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetUniformuivEXT((UInt32)program, (Int32)location, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glGetUniformuivEXT")]
            public static
            unsafe void GetUniform(UInt32 program, Int32 location, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetUniformuivEXT((UInt32)program, (Int32)location, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantBooleanvEXT")]
            public static
            void GetVariantBoolean(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] bool[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = data)
                        {
                            Delegates.glGetVariantBooleanvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (bool*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantBooleanvEXT")]
            public static
            void GetVariantBoolean(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] out bool data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = &data)
                        {
                            Delegates.glGetVariantBooleanvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (bool*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantBooleanvEXT")]
            public static
            unsafe void GetVariantBoolean(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] bool* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantBooleanvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (bool*)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantBooleanvEXT")]
            public static
            void GetVariantBoolean(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] bool[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = data)
                        {
                            Delegates.glGetVariantBooleanvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (bool*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantBooleanvEXT")]
            public static
            void GetVariantBoolean(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] out bool data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* data_ptr = &data)
                        {
                            Delegates.glGetVariantBooleanvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (bool*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantBooleanvEXT")]
            public static
            unsafe void GetVariantBoolean(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] bool* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantBooleanvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (bool*)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantFloatvEXT")]
            public static
            void GetVariantFloat(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Single[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = data)
                        {
                            Delegates.glGetVariantFloatvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Single*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantFloatvEXT")]
            public static
            void GetVariantFloat(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] out Single data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = &data)
                        {
                            Delegates.glGetVariantFloatvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Single*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantFloatvEXT")]
            public static
            unsafe void GetVariantFloat(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Single* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantFloatvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Single*)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantFloatvEXT")]
            public static
            void GetVariantFloat(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Single[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = data)
                        {
                            Delegates.glGetVariantFloatvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Single*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantFloatvEXT")]
            public static
            void GetVariantFloat(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] out Single data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* data_ptr = &data)
                        {
                            Delegates.glGetVariantFloatvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Single*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantFloatvEXT")]
            public static
            unsafe void GetVariantFloat(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Single* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantFloatvEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Single*)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantIntegervEXT")]
            public static
            void GetVariantInteger(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Int32[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* data_ptr = data)
                        {
                            Delegates.glGetVariantIntegervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Int32*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantIntegervEXT")]
            public static
            void GetVariantInteger(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] out Int32 data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* data_ptr = &data)
                        {
                            Delegates.glGetVariantIntegervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Int32*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantIntegervEXT")]
            public static
            unsafe void GetVariantInteger(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Int32* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantIntegervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Int32*)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantIntegervEXT")]
            public static
            void GetVariantInteger(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Int32[] data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* data_ptr = data)
                        {
                            Delegates.glGetVariantIntegervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Int32*)data_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantIntegervEXT")]
            public static
            void GetVariantInteger(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] out Int32 data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* data_ptr = &data)
                        {
                            Delegates.glGetVariantIntegervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Int32*)data_ptr);
                            data = *data_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantIntegervEXT")]
            public static
            unsafe void GetVariantInteger(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] Int32* data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantIntegervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (Int32*)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] T2[] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] T2[,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] T2[,,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] ref T2 data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] T2[] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] T2[,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] T2[,,] data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glGetVariantPointervEXT")]
            public static
            void GetVariantPointer<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader value, [InAttribute, OutAttribute] ref T2 data)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVariantPointervEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)value, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glGetVertexAttribIivEXT")]
            public static
            void GetVertexAttribI(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram4 pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribIivEXT((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram4)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glGetVertexAttribIivEXT")]
            public static
            unsafe void GetVertexAttribI(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram4 pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribIivEXT((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram4)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glGetVertexAttribIivEXT")]
            public static
            void GetVertexAttribI(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram4 pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribIivEXT((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram4)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glGetVertexAttribIivEXT")]
            public static
            unsafe void GetVertexAttribI(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram4 pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribIivEXT((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram4)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glGetVertexAttribIuivEXT")]
            public static
            void GetVertexAttribI(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram4 pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribIuivEXT((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram4)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glGetVertexAttribIuivEXT")]
            public static
            unsafe void GetVertexAttribI(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram4 pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribIuivEXT((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram4)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define histogram table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the histogram table. Must be a power of 2.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="sink">
            /// <para>
            /// If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glHistogramEXT")]
            public static
            void Histogram(OpenTK.Graphics.OpenGL.ExtHistogram target, Int32 width, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, bool sink)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (Int32)width, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (bool)sink);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtIndexFunc", Version = "1.1", EntryPoint = "glIndexFuncEXT")]
            public static
            void IndexFunc(OpenTK.Graphics.OpenGL.ExtIndexFunc func, Single @ref)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glIndexFuncEXT((OpenTK.Graphics.OpenGL.ExtIndexFunc)func, (Single)@ref);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtIndexMaterial", Version = "1.1", EntryPoint = "glIndexMaterialEXT")]
            public static
            void IndexMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.ExtIndexMaterial mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glIndexMaterialEXT((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.ExtIndexMaterial)mode);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of color indexes
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first index in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glIndexPointerEXT")]
            public static
            void IndexPointer(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, Int32 count, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glIndexPointerEXT((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of color indexes
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first index in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glIndexPointerEXT")]
            public static
            void IndexPointer<T3>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T3[] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerEXT((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of color indexes
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first index in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glIndexPointerEXT")]
            public static
            void IndexPointer<T3>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T3[,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerEXT((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of color indexes
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first index in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glIndexPointerEXT")]
            public static
            void IndexPointer<T3>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T3[,,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerEXT((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of color indexes
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first index in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glIndexPointerEXT")]
            public static
            void IndexPointer<T3>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] ref T3 pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerEXT((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glInsertComponentEXT")]
            public static
            void InsertComponent(Int32 res, Int32 src, Int32 num)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glInsertComponentEXT((UInt32)res, (UInt32)src, (UInt32)num);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glInsertComponentEXT")]
            public static
            void InsertComponent(UInt32 res, UInt32 src, UInt32 num)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glInsertComponentEXT((UInt32)res, (UInt32)src, (UInt32)num);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glIsEnabledIndexedEXT")]
            public static
            bool IsEnabledIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsEnabledIndexedEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDrawBuffers2", Version = "2.0", EntryPoint = "glIsEnabledIndexedEXT")]
            public static
            bool IsEnabledIndexed(OpenTK.Graphics.OpenGL.ExtDrawBuffers2 target, UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsEnabledIndexedEXT((OpenTK.Graphics.OpenGL.ExtDrawBuffers2)target, (UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glIsFramebufferEXT")]
            public static
            bool IsFramebuffer(Int32 framebuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsFramebufferEXT((UInt32)framebuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glIsFramebufferEXT")]
            public static
            bool IsFramebuffer(UInt32 framebuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsFramebufferEXT((UInt32)framebuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glIsRenderbufferEXT")]
            public static
            bool IsRenderbuffer(Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsRenderbufferEXT((UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glIsRenderbufferEXT")]
            public static
            bool IsRenderbuffer(UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsRenderbufferEXT((UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if a name corresponds to a texture
            /// </summary>
            /// <param name="texture">
            /// <para>
            /// Specifies a value that may be the name of a texture.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glIsTextureEXT")]
            public static
            bool IsTexture(Int32 texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsTextureEXT((UInt32)texture);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if a name corresponds to a texture
            /// </summary>
            /// <param name="texture">
            /// <para>
            /// Specifies a value that may be the name of a texture.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glIsTextureEXT")]
            public static
            bool IsTexture(UInt32 texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsTextureEXT((UInt32)texture);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glIsVariantEnabledEXT")]
            public static
            bool IsVariantEnabled(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader cap)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsVariantEnabledEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)cap);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glIsVariantEnabledEXT")]
            public static
            bool IsVariantEnabled(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader cap)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsVariantEnabledEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)cap);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCompiledVertexArray", Version = "1.1", EntryPoint = "glLockArraysEXT")]
            public static
            void LockArrays(Int32 first, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLockArraysEXT((Int32)first, (Int32)count);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMapNamedBufferEXT")]
            public static
            unsafe System.IntPtr MapNamedBuffer(Int32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess access)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glMapNamedBufferEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)access);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMapNamedBufferEXT")]
            public static
            unsafe System.IntPtr MapNamedBuffer(UInt32 buffer, OpenTK.Graphics.OpenGL.ExtDirectStateAccess access)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glMapNamedBufferEXT((UInt32)buffer, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)access);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixFrustumEXT")]
            public static
            void MatrixFrustum(OpenTK.Graphics.OpenGL.MatrixMode mode, Double left, Double right, Double bottom, Double top, Double zNear, Double zFar)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixFrustumEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double)left, (Double)right, (Double)bottom, (Double)top, (Double)zNear, (Double)zFar);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoaddEXT")]
            public static
            void MatrixLoad(OpenTK.Graphics.OpenGL.MatrixMode mode, Double[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = m)
                        {
                            Delegates.glMatrixLoaddEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoaddEXT")]
            public static
            void MatrixLoad(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Double m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = &m)
                        {
                            Delegates.glMatrixLoaddEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoaddEXT")]
            public static
            unsafe void MatrixLoad(OpenTK.Graphics.OpenGL.MatrixMode mode, Double* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixLoaddEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadfEXT")]
            public static
            void MatrixLoad(OpenTK.Graphics.OpenGL.MatrixMode mode, Single[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = m)
                        {
                            Delegates.glMatrixLoadfEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadfEXT")]
            public static
            void MatrixLoad(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Single m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = &m)
                        {
                            Delegates.glMatrixLoadfEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadfEXT")]
            public static
            unsafe void MatrixLoad(OpenTK.Graphics.OpenGL.MatrixMode mode, Single* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixLoadfEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadIdentityEXT")]
            public static
            void MatrixLoadIdentity(OpenTK.Graphics.OpenGL.MatrixMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixLoadIdentityEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadTransposedEXT")]
            public static
            void MatrixLoadTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Double[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = m)
                        {
                            Delegates.glMatrixLoadTransposedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadTransposedEXT")]
            public static
            void MatrixLoadTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Double m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = &m)
                        {
                            Delegates.glMatrixLoadTransposedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadTransposedEXT")]
            public static
            unsafe void MatrixLoadTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Double* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixLoadTransposedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadTransposefEXT")]
            public static
            void MatrixLoadTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Single[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = m)
                        {
                            Delegates.glMatrixLoadTransposefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadTransposefEXT")]
            public static
            void MatrixLoadTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Single m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = &m)
                        {
                            Delegates.glMatrixLoadTransposefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixLoadTransposefEXT")]
            public static
            unsafe void MatrixLoadTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Single* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixLoadTransposefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultdEXT")]
            public static
            void MatrixMult(OpenTK.Graphics.OpenGL.MatrixMode mode, Double[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = m)
                        {
                            Delegates.glMatrixMultdEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultdEXT")]
            public static
            void MatrixMult(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Double m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = &m)
                        {
                            Delegates.glMatrixMultdEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultdEXT")]
            public static
            unsafe void MatrixMult(OpenTK.Graphics.OpenGL.MatrixMode mode, Double* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixMultdEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultfEXT")]
            public static
            void MatrixMult(OpenTK.Graphics.OpenGL.MatrixMode mode, Single[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = m)
                        {
                            Delegates.glMatrixMultfEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultfEXT")]
            public static
            void MatrixMult(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Single m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = &m)
                        {
                            Delegates.glMatrixMultfEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultfEXT")]
            public static
            unsafe void MatrixMult(OpenTK.Graphics.OpenGL.MatrixMode mode, Single* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixMultfEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultTransposedEXT")]
            public static
            void MatrixMultTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Double[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = m)
                        {
                            Delegates.glMatrixMultTransposedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultTransposedEXT")]
            public static
            void MatrixMultTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Double m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = &m)
                        {
                            Delegates.glMatrixMultTransposedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultTransposedEXT")]
            public static
            unsafe void MatrixMultTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Double* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixMultTransposedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultTransposefEXT")]
            public static
            void MatrixMultTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Single[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = m)
                        {
                            Delegates.glMatrixMultTransposefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultTransposefEXT")]
            public static
            void MatrixMultTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, ref Single m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = &m)
                        {
                            Delegates.glMatrixMultTransposefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixMultTransposefEXT")]
            public static
            unsafe void MatrixMultTranspose(OpenTK.Graphics.OpenGL.MatrixMode mode, Single* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixMultTransposefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single*)m);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixOrthoEXT")]
            public static
            void MatrixOrtho(OpenTK.Graphics.OpenGL.MatrixMode mode, Double left, Double right, Double bottom, Double top, Double zNear, Double zFar)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixOrthoEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double)left, (Double)right, (Double)bottom, (Double)top, (Double)zNear, (Double)zFar);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixPopEXT")]
            public static
            void MatrixPop(OpenTK.Graphics.OpenGL.MatrixMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixPopEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixPushEXT")]
            public static
            void MatrixPush(OpenTK.Graphics.OpenGL.MatrixMode mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixPushEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixRotatedEXT")]
            public static
            void MatrixRotate(OpenTK.Graphics.OpenGL.MatrixMode mode, Double angle, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixRotatedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double)angle, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixRotatefEXT")]
            public static
            void MatrixRotate(OpenTK.Graphics.OpenGL.MatrixMode mode, Single angle, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixRotatefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single)angle, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixScaledEXT")]
            public static
            void MatrixScale(OpenTK.Graphics.OpenGL.MatrixMode mode, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixScaledEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixScalefEXT")]
            public static
            void MatrixScale(OpenTK.Graphics.OpenGL.MatrixMode mode, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixScalefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixTranslatedEXT")]
            public static
            void MatrixTranslate(OpenTK.Graphics.OpenGL.MatrixMode mode, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixTranslatedEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMatrixTranslatefEXT")]
            public static
            void MatrixTranslate(OpenTK.Graphics.OpenGL.MatrixMode mode, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixTranslatefEXT((OpenTK.Graphics.OpenGL.MatrixMode)mode, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define minmax table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The minmax table whose parameters are to be set. Must be GL_MINMAX.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="sink">
            /// <para>
            /// If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glMinmaxEXT")]
            public static
            void Minmax(OpenTK.Graphics.OpenGL.ExtHistogram target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, bool sink)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (bool)sink);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawArraysEXT")]
            public static
            void MultiDrawArrays(OpenTK.Graphics.OpenGL.BeginMode mode, [OutAttribute] Int32[] first, [OutAttribute] Int32[] count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = first)
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawArraysEXT")]
            public static
            void MultiDrawArrays(OpenTK.Graphics.OpenGL.BeginMode mode, [OutAttribute] out Int32 first, [OutAttribute] out Int32 count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = &first)
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                            first = *first_ptr;
                            count = *count_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives from array data
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="first">
            /// <para>
            /// Points to an array of starting indices in the enabled arrays.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the number of indices to be rendered.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the first and count
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawArraysEXT")]
            public static
            unsafe void MultiDrawArrays(OpenTK.Graphics.OpenGL.BeginMode mode, [OutAttribute] Int32* first, [OutAttribute] Int32* count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiDrawArraysEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)first, (Int32*)count, (Int32)primcount);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                                indices = (T3)indices_ptr.Target;
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                                indices = (T3)indices_ptr.Target;
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            unsafe void MultiDrawElements(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Render multiple sets of primitives by specifying indices of array data elements
            /// </summary>
            /// <param name="mode">
            /// <para>
            /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Points to an array of the elements counts.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
            /// </para>
            /// </param>
            /// <param name="indices">
            /// <para>
            /// Specifies a pointer to the location where the indices are stored.
            /// </para>
            /// </param>
            /// <param name="primcount">
            /// <para>
            /// Specifies the size of the count array.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtMultiDrawArrays", Version = "1.1", EntryPoint = "glMultiDrawElementsEXT")]
            public static
            unsafe void MultiDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiDrawElementsEXT((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        indices = (T3)indices_ptr.Target;
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexBufferEXT")]
            public static
            void MultiTexBuffer(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexBufferEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexBufferEXT")]
            public static
            void MultiTexBuffer(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexBufferEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexCoordPointerEXT")]
            public static
            void MultiTexCoordPointer(OpenTK.Graphics.OpenGL.TextureUnit texunit, Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoordPointerEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexCoordPointerEXT")]
            public static
            void MultiTexCoordPointer<T4>(OpenTK.Graphics.OpenGL.TextureUnit texunit, Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexCoordPointerEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexCoordPointerEXT")]
            public static
            void MultiTexCoordPointer<T4>(OpenTK.Graphics.OpenGL.TextureUnit texunit, Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexCoordPointerEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexCoordPointerEXT")]
            public static
            void MultiTexCoordPointer<T4>(OpenTK.Graphics.OpenGL.TextureUnit texunit, Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexCoordPointerEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexCoordPointerEXT")]
            public static
            void MultiTexCoordPointer<T4>(OpenTK.Graphics.OpenGL.TextureUnit texunit, Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexCoordPointerEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexEnvfEXT")]
            public static
            void MultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexEnvfEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexEnvfvEXT")]
            public static
            void MultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glMultiTexEnvfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexEnvfvEXT")]
            public static
            unsafe void MultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexEnvfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexEnviEXT")]
            public static
            void MultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexEnviEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexEnvivEXT")]
            public static
            void MultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glMultiTexEnvivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexEnvivEXT")]
            public static
            unsafe void MultiTexEnv(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexEnvivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGendEXT")]
            public static
            void MultiTexGend(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Double param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexGendEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGendvEXT")]
            public static
            void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glMultiTexGendvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGendvEXT")]
            public static
            void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glMultiTexGendvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGendvEXT")]
            public static
            unsafe void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexGendvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGenfEXT")]
            public static
            void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexGenfEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGenfvEXT")]
            public static
            void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glMultiTexGenfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGenfvEXT")]
            public static
            unsafe void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexGenfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGeniEXT")]
            public static
            void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexGeniEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGenivEXT")]
            public static
            void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glMultiTexGenivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexGenivEXT")]
            public static
            unsafe void MultiTexGen(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexGenivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage1DEXT")]
            public static
            void MultiTexImage1D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage1DEXT")]
            public static
            void MultiTexImage1D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage1DEXT")]
            public static
            void MultiTexImage1D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage1DEXT")]
            public static
            void MultiTexImage1D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage1DEXT")]
            public static
            void MultiTexImage1D<T8>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T8)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage2DEXT")]
            public static
            void MultiTexImage2D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage2DEXT")]
            public static
            void MultiTexImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage2DEXT")]
            public static
            void MultiTexImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage2DEXT")]
            public static
            void MultiTexImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage2DEXT")]
            public static
            void MultiTexImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage3DEXT")]
            public static
            void MultiTexImage3D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage3DEXT")]
            public static
            void MultiTexImage3D<T10>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage3DEXT")]
            public static
            void MultiTexImage3D<T10>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage3DEXT")]
            public static
            void MultiTexImage3D<T10>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexImage3DEXT")]
            public static
            void MultiTexImage3D<T10>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T10)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterfEXT")]
            public static
            void MultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexParameterfEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterfvEXT")]
            public static
            void MultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glMultiTexParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterfvEXT")]
            public static
            unsafe void MultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexParameterfvEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameteriEXT")]
            public static
            void MultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexParameteriEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterIivEXT")]
            public static
            void MultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glMultiTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterIivEXT")]
            public static
            void MultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glMultiTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterIivEXT")]
            public static
            unsafe void MultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterIuivEXT")]
            public static
            void MultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glMultiTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterIuivEXT")]
            public static
            void MultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glMultiTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterIuivEXT")]
            public static
            unsafe void MultiTexParameterI(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterivEXT")]
            public static
            void MultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glMultiTexParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexParameterivEXT")]
            public static
            unsafe void MultiTexParameter(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexParameterivEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexRenderbufferEXT")]
            public static
            void MultiTexRenderbuffer(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexRenderbufferEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexRenderbufferEXT")]
            public static
            void MultiTexRenderbuffer(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexRenderbufferEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage1DEXT")]
            public static
            void MultiTexSubImage1D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage1DEXT")]
            public static
            void MultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage1DEXT")]
            public static
            void MultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage1DEXT")]
            public static
            void MultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,,] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage1DEXT")]
            public static
            void MultiTexSubImage1D<T7>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T7 pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T7)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage2DEXT")]
            public static
            void MultiTexSubImage2D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage2DEXT")]
            public static
            void MultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage2DEXT")]
            public static
            void MultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage2DEXT")]
            public static
            void MultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage2DEXT")]
            public static
            void MultiTexSubImage2D<T9>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage3DEXT")]
            public static
            void MultiTexSubImage3D(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage3DEXT")]
            public static
            void MultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage3DEXT")]
            public static
            void MultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[,] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage3DEXT")]
            public static
            void MultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[,,] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glMultiTexSubImage3DEXT")]
            public static
            void MultiTexSubImage3D<T11>(OpenTK.Graphics.OpenGL.TextureUnit texunit, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T11 pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureUnit)texunit, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T11)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData(Int32 buffer, IntPtr size, IntPtr data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(Int32 buffer, IntPtr size, [InAttribute, OutAttribute] T2[] data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(Int32 buffer, IntPtr size, [InAttribute, OutAttribute] T2[,] data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(Int32 buffer, IntPtr size, [InAttribute, OutAttribute] T2[,,] data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(Int32 buffer, IntPtr size, [InAttribute, OutAttribute] ref T2 data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData(UInt32 buffer, IntPtr size, IntPtr data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(UInt32 buffer, IntPtr size, [InAttribute, OutAttribute] T2[] data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(UInt32 buffer, IntPtr size, [InAttribute, OutAttribute] T2[,] data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(UInt32 buffer, IntPtr size, [InAttribute, OutAttribute] T2[,,] data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferDataEXT")]
            public static
            void NamedBufferData<T2>(UInt32 buffer, IntPtr size, [InAttribute, OutAttribute] ref T2 data, OpenTK.Graphics.OpenGL.ExtDirectStateAccess usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferDataEXT((UInt32)buffer, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)usage);
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData(Int32 buffer, IntPtr offset, IntPtr size, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(Int32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData(UInt32 buffer, IntPtr offset, IntPtr size, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedBufferSubDataEXT")]
            public static
            void NamedBufferSubData<T3>(UInt32 buffer, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedBufferSubDataEXT((UInt32)buffer, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferRenderbufferEXT")]
            public static
            void NamedFramebufferRenderbuffer(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.RenderbufferTarget renderbuffertarget, Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferRenderbufferEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferRenderbufferEXT")]
            public static
            void NamedFramebufferRenderbuffer(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.RenderbufferTarget renderbuffertarget, UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferRenderbufferEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.RenderbufferTarget)renderbuffertarget, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTexture1DEXT")]
            public static
            void NamedFramebufferTexture1D(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTexture1DEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTexture1DEXT")]
            public static
            void NamedFramebufferTexture1D(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTexture1DEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTexture2DEXT")]
            public static
            void NamedFramebufferTexture2D(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTexture2DEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTexture2DEXT")]
            public static
            void NamedFramebufferTexture2D(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTexture2DEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTexture3DEXT")]
            public static
            void NamedFramebufferTexture3D(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, Int32 texture, Int32 level, Int32 zoffset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTexture3DEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level, (Int32)zoffset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTexture3DEXT")]
            public static
            void NamedFramebufferTexture3D(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, OpenTK.Graphics.OpenGL.TextureTarget textarget, UInt32 texture, Int32 level, Int32 zoffset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTexture3DEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (OpenTK.Graphics.OpenGL.TextureTarget)textarget, (UInt32)texture, (Int32)level, (Int32)zoffset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTextureEXT")]
            public static
            void NamedFramebufferTexture(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTextureEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTextureEXT")]
            public static
            void NamedFramebufferTexture(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTextureEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTextureFaceEXT")]
            public static
            void NamedFramebufferTextureFace(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level, OpenTK.Graphics.OpenGL.TextureTarget face)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTextureFaceEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.TextureTarget)face);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTextureFaceEXT")]
            public static
            void NamedFramebufferTextureFace(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level, OpenTK.Graphics.OpenGL.TextureTarget face)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTextureFaceEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.TextureTarget)face);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTextureLayerEXT")]
            public static
            void NamedFramebufferTextureLayer(Int32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 layer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTextureLayerEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedFramebufferTextureLayerEXT")]
            public static
            void NamedFramebufferTextureLayer(UInt32 framebuffer, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 layer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedFramebufferTextureLayerEXT((UInt32)framebuffer, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dEXT")]
            public static
            void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4dEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dEXT")]
            public static
            void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4dEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dvEXT")]
            public static
            void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameter4dvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dvEXT")]
            public static
            void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameter4dvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dvEXT")]
            public static
            unsafe void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4dvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dvEXT")]
            public static
            void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameter4dvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dvEXT")]
            public static
            void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameter4dvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4dvEXT")]
            public static
            unsafe void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4dvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fEXT")]
            public static
            void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4fEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fEXT")]
            public static
            void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4fEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fvEXT")]
            public static
            void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameter4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fvEXT")]
            public static
            void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameter4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fvEXT")]
            public static
            unsafe void NamedProgramLocalParameter4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fvEXT")]
            public static
            void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameter4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fvEXT")]
            public static
            void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameter4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameter4fvEXT")]
            public static
            unsafe void NamedProgramLocalParameter4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameter4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4iEXT")]
            public static
            void NamedProgramLocalParameterI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameterI4iEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4iEXT")]
            public static
            void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameterI4iEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4ivEXT")]
            public static
            void NamedProgramLocalParameterI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameterI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4ivEXT")]
            public static
            void NamedProgramLocalParameterI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameterI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4ivEXT")]
            public static
            unsafe void NamedProgramLocalParameterI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameterI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4ivEXT")]
            public static
            void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameterI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4ivEXT")]
            public static
            void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameterI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4ivEXT")]
            public static
            unsafe void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameterI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4uiEXT")]
            public static
            void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameterI4uiEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32)x, (UInt32)y, (UInt32)z, (UInt32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4uivEXT")]
            public static
            void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameterI4uivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4uivEXT")]
            public static
            void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameterI4uivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameterI4uivEXT")]
            public static
            unsafe void NamedProgramLocalParameterI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameterI4uivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameters4fvEXT")]
            public static
            void NamedProgramLocalParameters4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameters4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameters4fvEXT")]
            public static
            void NamedProgramLocalParameters4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameters4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameters4fvEXT")]
            public static
            unsafe void NamedProgramLocalParameters4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameters4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameters4fvEXT")]
            public static
            void NamedProgramLocalParameters4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParameters4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameters4fvEXT")]
            public static
            void NamedProgramLocalParameters4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParameters4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParameters4fvEXT")]
            public static
            unsafe void NamedProgramLocalParameters4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParameters4fvEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4ivEXT")]
            public static
            void NamedProgramLocalParametersI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParametersI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4ivEXT")]
            public static
            void NamedProgramLocalParametersI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParametersI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4ivEXT")]
            public static
            unsafe void NamedProgramLocalParametersI4(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, Int32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParametersI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4ivEXT")]
            public static
            void NamedProgramLocalParametersI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParametersI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4ivEXT")]
            public static
            void NamedProgramLocalParametersI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParametersI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4ivEXT")]
            public static
            unsafe void NamedProgramLocalParametersI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParametersI4ivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4uivEXT")]
            public static
            void NamedProgramLocalParametersI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glNamedProgramLocalParametersI4uivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4uivEXT")]
            public static
            void NamedProgramLocalParametersI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glNamedProgramLocalParametersI4uivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramLocalParametersI4uivEXT")]
            public static
            unsafe void NamedProgramLocalParametersI4(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, UInt32 index, Int32 count, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramLocalParametersI4uivEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (UInt32)index, (Int32)count, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] T4[] @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] T4[,] @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] T4[,,] @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(Int32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] ref T4 @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T4)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] T4[] @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] T4[,] @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] T4[,,] @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedProgramStringEXT")]
            public static
            void NamedProgramString<T4>(UInt32 program, OpenTK.Graphics.OpenGL.ExtDirectStateAccess target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess format, Int32 len, [InAttribute, OutAttribute] ref T4 @string)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNamedProgramStringEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T4)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedRenderbufferStorageEXT")]
            public static
            void NamedRenderbufferStorage(Int32 renderbuffer, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedRenderbufferStorageEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedRenderbufferStorageEXT")]
            public static
            void NamedRenderbufferStorage(UInt32 renderbuffer, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedRenderbufferStorageEXT((UInt32)renderbuffer, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedRenderbufferStorageMultisampleCoverageEXT")]
            public static
            void NamedRenderbufferStorageMultisampleCoverage(Int32 renderbuffer, Int32 coverageSamples, Int32 colorSamples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedRenderbufferStorageMultisampleCoverageEXT((UInt32)renderbuffer, (Int32)coverageSamples, (Int32)colorSamples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedRenderbufferStorageMultisampleCoverageEXT")]
            public static
            void NamedRenderbufferStorageMultisampleCoverage(UInt32 renderbuffer, Int32 coverageSamples, Int32 colorSamples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedRenderbufferStorageMultisampleCoverageEXT((UInt32)renderbuffer, (Int32)coverageSamples, (Int32)colorSamples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedRenderbufferStorageMultisampleEXT")]
            public static
            void NamedRenderbufferStorageMultisample(Int32 renderbuffer, Int32 samples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedRenderbufferStorageMultisampleEXT((UInt32)renderbuffer, (Int32)samples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glNamedRenderbufferStorageMultisampleEXT")]
            public static
            void NamedRenderbufferStorageMultisample(UInt32 renderbuffer, Int32 samples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNamedRenderbufferStorageMultisampleEXT((UInt32)renderbuffer, (Int32)samples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glNormalPointerEXT")]
            public static
            void NormalPointer(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, Int32 count, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glNormalPointerEXT")]
            public static
            void NormalPointer<T3>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T3[] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glNormalPointerEXT")]
            public static
            void NormalPointer<T3>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T3[,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glNormalPointerEXT")]
            public static
            void NormalPointer<T3>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T3[,,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glNormalPointerEXT")]
            public static
            void NormalPointer<T3>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] ref T3 pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtPixelTransform", Version = "1.1", EntryPoint = "glPixelTransformParameterfEXT")]
            public static
            void PixelTransformParameter(OpenTK.Graphics.OpenGL.ExtPixelTransform target, OpenTK.Graphics.OpenGL.ExtPixelTransform pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTransformParameterfEXT((OpenTK.Graphics.OpenGL.ExtPixelTransform)target, (OpenTK.Graphics.OpenGL.ExtPixelTransform)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtPixelTransform", Version = "1.1", EntryPoint = "glPixelTransformParameterfvEXT")]
            public static
            unsafe void PixelTransformParameter(OpenTK.Graphics.OpenGL.ExtPixelTransform target, OpenTK.Graphics.OpenGL.ExtPixelTransform pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTransformParameterfvEXT((OpenTK.Graphics.OpenGL.ExtPixelTransform)target, (OpenTK.Graphics.OpenGL.ExtPixelTransform)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtPixelTransform", Version = "1.1", EntryPoint = "glPixelTransformParameteriEXT")]
            public static
            void PixelTransformParameter(OpenTK.Graphics.OpenGL.ExtPixelTransform target, OpenTK.Graphics.OpenGL.ExtPixelTransform pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTransformParameteriEXT((OpenTK.Graphics.OpenGL.ExtPixelTransform)target, (OpenTK.Graphics.OpenGL.ExtPixelTransform)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtPixelTransform", Version = "1.1", EntryPoint = "glPixelTransformParameterivEXT")]
            public static
            unsafe void PixelTransformParameter(OpenTK.Graphics.OpenGL.ExtPixelTransform target, OpenTK.Graphics.OpenGL.ExtPixelTransform pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTransformParameterivEXT((OpenTK.Graphics.OpenGL.ExtPixelTransform)target, (OpenTK.Graphics.OpenGL.ExtPixelTransform)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPointParameters", Version = "1.0", EntryPoint = "glPointParameterfEXT")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.ExtPointParameters pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterfEXT((OpenTK.Graphics.OpenGL.ExtPointParameters)pname, (Single)param);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPointParameters", Version = "1.0", EntryPoint = "glPointParameterfvEXT")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.ExtPointParameters pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glPointParameterfvEXT((OpenTK.Graphics.OpenGL.ExtPointParameters)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtPointParameters", Version = "1.0", EntryPoint = "glPointParameterfvEXT")]
            public static
            unsafe void PointParameter(OpenTK.Graphics.OpenGL.ExtPointParameters pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterfvEXT((OpenTK.Graphics.OpenGL.ExtPointParameters)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the scale and units used to calculate depth values
            /// </summary>
            /// <param name="factor">
            /// <para>
            /// Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="units">
            /// <para>
            /// Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtPolygonOffset", Version = "1.0", EntryPoint = "glPolygonOffsetEXT")]
            public static
            void PolygonOffset(Single factor, Single bias)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPolygonOffsetEXT((Single)factor, (Single)bias);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set texture residence priority
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="priorities">
            /// <para>
            /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glPrioritizeTexturesEXT")]
            public static
            void PrioritizeTextures(Int32 n, Int32[] textures, Single[] priorities)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = textures)
                        fixed (Single* priorities_ptr = priorities)
                        {
                            Delegates.glPrioritizeTexturesEXT((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set texture residence priority
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="priorities">
            /// <para>
            /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glPrioritizeTexturesEXT")]
            public static
            void PrioritizeTextures(Int32 n, ref Int32 textures, ref Single priorities)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* textures_ptr = &textures)
                        fixed (Single* priorities_ptr = &priorities)
                        {
                            Delegates.glPrioritizeTexturesEXT((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set texture residence priority
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="priorities">
            /// <para>
            /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glPrioritizeTexturesEXT")]
            public static
            unsafe void PrioritizeTextures(Int32 n, Int32* textures, Single* priorities)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPrioritizeTexturesEXT((Int32)n, (UInt32*)textures, (Single*)priorities);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set texture residence priority
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="priorities">
            /// <para>
            /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glPrioritizeTexturesEXT")]
            public static
            void PrioritizeTextures(Int32 n, UInt32[] textures, Single[] priorities)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = textures)
                        fixed (Single* priorities_ptr = priorities)
                        {
                            Delegates.glPrioritizeTexturesEXT((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set texture residence priority
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="priorities">
            /// <para>
            /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glPrioritizeTexturesEXT")]
            public static
            void PrioritizeTextures(Int32 n, ref UInt32 textures, ref Single priorities)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* textures_ptr = &textures)
                        fixed (Single* priorities_ptr = &priorities)
                        {
                            Delegates.glPrioritizeTexturesEXT((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set texture residence priority
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="textures">
            /// <para>
            /// Specifies an array containing the names of the textures to be prioritized.
            /// </para>
            /// </param>
            /// <param name="priorities">
            /// <para>
            /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureObject", Version = "1.0", EntryPoint = "glPrioritizeTexturesEXT")]
            public static
            unsafe void PrioritizeTextures(Int32 n, UInt32* textures, Single* priorities)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPrioritizeTexturesEXT((Int32)n, (UInt32*)textures, (Single*)priorities);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramEnvParameters4fvEXT")]
            public static
            void ProgramEnvParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, Int32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramEnvParameters4fvEXT")]
            public static
            void ProgramEnvParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, Int32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramEnvParameters4fvEXT")]
            public static
            unsafe void ProgramEnvParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, Int32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramEnvParameters4fvEXT")]
            public static
            void ProgramEnvParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, UInt32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramEnvParameters4fvEXT")]
            public static
            void ProgramEnvParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, UInt32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramEnvParameters4fvEXT")]
            public static
            unsafe void ProgramEnvParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, UInt32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramLocalParameters4fvEXT")]
            public static
            void ProgramLocalParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, Int32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramLocalParameters4fvEXT")]
            public static
            void ProgramLocalParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, Int32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramLocalParameters4fvEXT")]
            public static
            unsafe void ProgramLocalParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, Int32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramLocalParameters4fvEXT")]
            public static
            void ProgramLocalParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, UInt32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramLocalParameters4fvEXT")]
            public static
            void ProgramLocalParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, UInt32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuProgramParameters", Version = "1.2", EntryPoint = "glProgramLocalParameters4fvEXT")]
            public static
            unsafe void ProgramLocalParameters4(OpenTK.Graphics.OpenGL.ExtGpuProgramParameters target, UInt32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameters4fvEXT((OpenTK.Graphics.OpenGL.ExtGpuProgramParameters)target, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtGeometryShader4", Version = "2.0", EntryPoint = "glProgramParameteriEXT")]
            public static
            void ProgramParameter(Int32 program, OpenTK.Graphics.OpenGL.ExtGeometryShader4 pname, Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameteriEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtGeometryShader4)pname, (Int32)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGeometryShader4", Version = "2.0", EntryPoint = "glProgramParameteriEXT")]
            public static
            void ProgramParameter(UInt32 program, OpenTK.Graphics.OpenGL.ExtGeometryShader4 pname, Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameteriEXT((UInt32)program, (OpenTK.Graphics.OpenGL.ExtGeometryShader4)pname, (Int32)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fEXT")]
            public static
            void ProgramUniform1(Int32 program, Int32 location, Single v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1fEXT((UInt32)program, (Int32)location, (Single)v0);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Single v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1fEXT((UInt32)program, (Int32)location, (Single)v0);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static
            unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1fvEXT")]
            public static
            unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1iEXT")]
            public static
            void ProgramUniform1(Int32 program, Int32 location, Int32 v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1iEXT((UInt32)program, (Int32)location, (Int32)v0);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1iEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1iEXT((UInt32)program, (Int32)location, (Int32)v0);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static
            void ProgramUniform1(Int32 program, Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static
            unsafe void ProgramUniform1(Int32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1ivEXT")]
            public static
            unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1uiEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, UInt32 v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1uiEXT((UInt32)program, (Int32)location, (UInt32)v0);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glProgramUniform1uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            public static
            void ProgramUniform1(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform1uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform1uivEXT")]
            public static
            unsafe void ProgramUniform1(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform1uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fEXT")]
            public static
            void ProgramUniform2(Int32 program, Int32 location, Single v0, Single v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Single v0, Single v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static
            void ProgramUniform2(Int32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static
            void ProgramUniform2(Int32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static
            unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2fvEXT")]
            public static
            unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2iEXT")]
            public static
            void ProgramUniform2(Int32 program, Int32 location, Int32 v0, Int32 v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2iEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Int32 v0, Int32 v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static
            void ProgramUniform2(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static
            unsafe void ProgramUniform2(Int32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2ivEXT")]
            public static
            unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2uiEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, UInt32 v0, UInt32 v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2uiEXT((UInt32)program, (Int32)location, (UInt32)v0, (UInt32)v1);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glProgramUniform2uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            public static
            void ProgramUniform2(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform2uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform2uivEXT")]
            public static
            unsafe void ProgramUniform2(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform2uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fEXT")]
            public static
            void ProgramUniform3(Int32 program, Int32 location, Single v0, Single v1, Single v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Single v0, Single v1, Single v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static
            unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3fvEXT")]
            public static
            unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3iEXT")]
            public static
            void ProgramUniform3(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3iEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static
            void ProgramUniform3(Int32 program, Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static
            unsafe void ProgramUniform3(Int32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3ivEXT")]
            public static
            unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3uiEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3uiEXT((UInt32)program, (Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glProgramUniform3uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            public static
            void ProgramUniform3(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform3uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform3uivEXT")]
            public static
            unsafe void ProgramUniform3(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform3uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fEXT")]
            public static
            void ProgramUniform4(Int32 program, Int32 location, Single v0, Single v1, Single v2, Single v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2, (Single)v3);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Single v0, Single v1, Single v2, Single v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4fEXT((UInt32)program, (Int32)location, (Single)v0, (Single)v1, (Single)v2, (Single)v3);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static
            unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4fvEXT")]
            public static
            unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4fvEXT((UInt32)program, (Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4iEXT")]
            public static
            void ProgramUniform4(Int32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2, (Int32)v3);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4iEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4iEXT((UInt32)program, (Int32)location, (Int32)v0, (Int32)v1, (Int32)v2, (Int32)v3);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static
            void ProgramUniform4(Int32 program, Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static
            unsafe void ProgramUniform4(Int32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4ivEXT")]
            public static
            unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4ivEXT((UInt32)program, (Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4uiEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4uiEXT((UInt32)program, (Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2, (UInt32)v3);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glProgramUniform4uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            public static
            void ProgramUniform4(UInt32 program, Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glProgramUniform4uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniform4uivEXT")]
            public static
            unsafe void ProgramUniform4(UInt32 program, Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniform4uivEXT((UInt32)program, (Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static
            void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static
            void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static
            unsafe void ProgramUniformMatrix2(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static
            void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static
            void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2fvEXT")]
            public static
            unsafe void ProgramUniformMatrix2(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static
            void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static
            void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static
            unsafe void ProgramUniformMatrix2x3(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static
            void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static
            void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x3fvEXT")]
            public static
            unsafe void ProgramUniformMatrix2x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix2x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static
            void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static
            void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static
            unsafe void ProgramUniformMatrix2x4(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static
            void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static
            void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix2x4fvEXT")]
            public static
            unsafe void ProgramUniformMatrix2x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix2x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static
            void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static
            void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static
            unsafe void ProgramUniformMatrix3(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static
            void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static
            void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3fvEXT")]
            public static
            unsafe void ProgramUniformMatrix3(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static
            void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static
            void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static
            unsafe void ProgramUniformMatrix3x2(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static
            void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static
            void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x2fvEXT")]
            public static
            unsafe void ProgramUniformMatrix3x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix3x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static
            void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static
            void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static
            unsafe void ProgramUniformMatrix3x4(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static
            void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static
            void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix3x4fvEXT")]
            public static
            unsafe void ProgramUniformMatrix3x4(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix3x4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static
            void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static
            void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static
            unsafe void ProgramUniformMatrix4(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static
            void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static
            void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4fvEXT")]
            public static
            unsafe void ProgramUniformMatrix4(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix4fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static
            void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static
            void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static
            unsafe void ProgramUniformMatrix4x2(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static
            void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static
            void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x2fvEXT")]
            public static
            unsafe void ProgramUniformMatrix4x2(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix4x2fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static
            void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static
            void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static
            unsafe void ProgramUniformMatrix4x3(Int32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static
            void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static
            void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glProgramUniformMatrix4x3fvEXT")]
            public static
            unsafe void ProgramUniformMatrix4x3(UInt32 program, Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramUniformMatrix4x3fvEXT((UInt32)program, (Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtProvokingVertex", Version = "2.1", EntryPoint = "glProvokingVertexEXT")]
            public static
            void ProvokingVertex(OpenTK.Graphics.OpenGL.ExtProvokingVertex mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProvokingVertexEXT((OpenTK.Graphics.OpenGL.ExtProvokingVertex)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glPushClientAttribDefaultEXT")]
            public static
            void PushClientAttribDefault(OpenTK.Graphics.OpenGL.ClientAttribMask mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPushClientAttribDefaultEXT((OpenTK.Graphics.OpenGL.ClientAttribMask)mask);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtFramebufferObject", Version = "1.2", EntryPoint = "glRenderbufferStorageEXT")]
            public static
            void RenderbufferStorage(OpenTK.Graphics.OpenGL.RenderbufferTarget target, OpenTK.Graphics.OpenGL.RenderbufferStorage internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glRenderbufferStorageEXT((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (OpenTK.Graphics.OpenGL.RenderbufferStorage)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Reset histogram table entries to zero
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_HISTOGRAM.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glResetHistogramEXT")]
            public static
            void ResetHistogram(OpenTK.Graphics.OpenGL.ExtHistogram target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glResetHistogramEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Reset minmax table entries to initial values
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_MINMAX.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtHistogram", Version = "1.0", EntryPoint = "glResetMinmaxEXT")]
            public static
            void ResetMinmax(OpenTK.Graphics.OpenGL.ExtHistogram target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glResetMinmaxEXT((OpenTK.Graphics.OpenGL.ExtHistogram)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtMultisample", Version = "1.0", EntryPoint = "glSampleMaskEXT")]
            public static
            void SampleMask(Single value, bool invert)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleMaskEXT((Single)value, (bool)invert);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtMultisample", Version = "1.0", EntryPoint = "glSamplePatternEXT")]
            public static
            void SamplePattern(OpenTK.Graphics.OpenGL.ExtMultisample pattern)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSamplePatternEXT((OpenTK.Graphics.OpenGL.ExtMultisample)pattern);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3bEXT")]
            public static
            void SecondaryColor3(SByte red, SByte green, SByte blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3bEXT((SByte)red, (SByte)green, (SByte)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3bvEXT")]
            public static
            void SecondaryColor3(SByte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3bvEXT")]
            public static
            void SecondaryColor3(ref SByte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3bvEXT")]
            public static
            unsafe void SecondaryColor3(SByte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3bvEXT((SByte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3dEXT")]
            public static
            void SecondaryColor3(Double red, Double green, Double blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3dEXT((Double)red, (Double)green, (Double)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3dvEXT")]
            public static
            void SecondaryColor3(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3dvEXT((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3dvEXT")]
            public static
            void SecondaryColor3(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3dvEXT((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3dvEXT")]
            public static
            unsafe void SecondaryColor3(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3dvEXT((Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3fEXT")]
            public static
            void SecondaryColor3(Single red, Single green, Single blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3fEXT((Single)red, (Single)green, (Single)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3fvEXT")]
            public static
            void SecondaryColor3(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3fvEXT((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3fvEXT")]
            public static
            void SecondaryColor3(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3fvEXT((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3fvEXT")]
            public static
            unsafe void SecondaryColor3(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3fvEXT((Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3iEXT")]
            public static
            void SecondaryColor3(Int32 red, Int32 green, Int32 blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3iEXT((Int32)red, (Int32)green, (Int32)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ivEXT")]
            public static
            void SecondaryColor3(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3ivEXT((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ivEXT")]
            public static
            void SecondaryColor3(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3ivEXT((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ivEXT")]
            public static
            unsafe void SecondaryColor3(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3ivEXT((Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3sEXT")]
            public static
            void SecondaryColor3(Int16 red, Int16 green, Int16 blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3sEXT((Int16)red, (Int16)green, (Int16)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3svEXT")]
            public static
            void SecondaryColor3(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3svEXT((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3svEXT")]
            public static
            void SecondaryColor3(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3svEXT((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3svEXT")]
            public static
            unsafe void SecondaryColor3(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3svEXT((Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ubEXT")]
            public static
            void SecondaryColor3(Byte red, Byte green, Byte blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3ubEXT((Byte)red, (Byte)green, (Byte)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ubvEXT")]
            public static
            void SecondaryColor3(Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3ubvEXT((Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ubvEXT")]
            public static
            void SecondaryColor3(ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3ubvEXT((Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3ubvEXT")]
            public static
            unsafe void SecondaryColor3(Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3ubvEXT((Byte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3uiEXT")]
            public static
            void SecondaryColor3(UInt32 red, UInt32 green, UInt32 blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3uiEXT((UInt32)red, (UInt32)green, (UInt32)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3uivEXT")]
            public static
            void SecondaryColor3(UInt32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3uivEXT((UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3uivEXT")]
            public static
            void SecondaryColor3(ref UInt32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3uivEXT((UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3uivEXT")]
            public static
            unsafe void SecondaryColor3(UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3uivEXT((UInt32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3usEXT")]
            public static
            void SecondaryColor3(UInt16 red, UInt16 green, UInt16 blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3usEXT((UInt16)red, (UInt16)green, (UInt16)blue);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3usvEXT")]
            public static
            void SecondaryColor3(UInt16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3usvEXT((UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3usvEXT")]
            public static
            void SecondaryColor3(ref UInt16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3usvEXT((UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current secondary color
            /// </summary>
            /// <param name="red">
            /// <para>
            /// Specify new red, green, and blue values for the current secondary color.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColor3usvEXT")]
            public static
            unsafe void SecondaryColor3(UInt16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3usvEXT((UInt16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of secondary colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColorPointerEXT")]
            public static
            void SecondaryColorPointer(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of secondary colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColorPointerEXT")]
            public static
            void SecondaryColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of secondary colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColorPointerEXT")]
            public static
            void SecondaryColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of secondary colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColorPointerEXT")]
            public static
            void SecondaryColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of secondary colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSecondaryColor", Version = "1.1", EntryPoint = "glSecondaryColorPointerEXT")]
            public static
            void SecondaryColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, IntPtr column)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[] column)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,] column)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,,] column)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] ref T7 column)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                        column = (T7)column_ptr.Target;
                    }
                    finally
                    {
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] row, [InAttribute, OutAttribute] T7[,,] column)
                where T6 : struct
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] row, [InAttribute, OutAttribute] T7[,,] column)
                where T6 : struct
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] row, [InAttribute, OutAttribute] T7[,,] column)
                where T6 : struct
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a separable two-dimensional convolution filter
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_SEPARABLE_2D.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="row">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
            /// </para>
            /// </param>
            /// <param name="column">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtConvolution", Version = "1.0", EntryPoint = "glSeparableFilter2DEXT")]
            public static
            void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.ExtConvolution target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 row, [InAttribute, OutAttribute] T7[,,] column)
                where T6 : struct
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                    GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSeparableFilter2DEXT((OpenTK.Graphics.OpenGL.ExtConvolution)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                        row = (T6)row_ptr.Target;
                    }
                    finally
                    {
                        row_ptr.Free();
                        column_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, IntPtr addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] ref T2 addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                        addr = (T2)addr_ptr.Target;
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, IntPtr addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetInvariantEXT")]
            public static
            void SetInvariant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] ref T2 addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetInvariantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                        addr = (T2)addr_ptr.Target;
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, IntPtr addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(Int32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] ref T2 addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                        addr = (T2)addr_ptr.Target;
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, IntPtr addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] T2[,,] addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSetLocalConstantEXT")]
            public static
            void SetLocalConstant<T2>(UInt32 id, OpenTK.Graphics.OpenGL.ExtVertexShader type, [InAttribute, OutAttribute] ref T2 addr)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle addr_ptr = GCHandle.Alloc(addr, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSetLocalConstantEXT((UInt32)id, (OpenTK.Graphics.OpenGL.ExtVertexShader)type, (IntPtr)addr_ptr.AddrOfPinnedObject());
                        addr = (T2)addr_ptr.Target;
                    }
                    finally
                    {
                        addr_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glShaderOp1EXT")]
            public static
            void ShaderOp1(OpenTK.Graphics.OpenGL.ExtVertexShader op, Int32 res, Int32 arg1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderOp1EXT((OpenTK.Graphics.OpenGL.ExtVertexShader)op, (UInt32)res, (UInt32)arg1);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glShaderOp1EXT")]
            public static
            void ShaderOp1(OpenTK.Graphics.OpenGL.ExtVertexShader op, UInt32 res, UInt32 arg1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderOp1EXT((OpenTK.Graphics.OpenGL.ExtVertexShader)op, (UInt32)res, (UInt32)arg1);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glShaderOp2EXT")]
            public static
            void ShaderOp2(OpenTK.Graphics.OpenGL.ExtVertexShader op, Int32 res, Int32 arg1, Int32 arg2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderOp2EXT((OpenTK.Graphics.OpenGL.ExtVertexShader)op, (UInt32)res, (UInt32)arg1, (UInt32)arg2);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glShaderOp2EXT")]
            public static
            void ShaderOp2(OpenTK.Graphics.OpenGL.ExtVertexShader op, UInt32 res, UInt32 arg1, UInt32 arg2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderOp2EXT((OpenTK.Graphics.OpenGL.ExtVertexShader)op, (UInt32)res, (UInt32)arg1, (UInt32)arg2);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glShaderOp3EXT")]
            public static
            void ShaderOp3(OpenTK.Graphics.OpenGL.ExtVertexShader op, Int32 res, Int32 arg1, Int32 arg2, Int32 arg3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderOp3EXT((OpenTK.Graphics.OpenGL.ExtVertexShader)op, (UInt32)res, (UInt32)arg1, (UInt32)arg2, (UInt32)arg3);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glShaderOp3EXT")]
            public static
            void ShaderOp3(OpenTK.Graphics.OpenGL.ExtVertexShader op, UInt32 res, UInt32 arg1, UInt32 arg2, UInt32 arg3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderOp3EXT((OpenTK.Graphics.OpenGL.ExtVertexShader)op, (UInt32)res, (UInt32)arg1, (UInt32)arg2, (UInt32)arg3);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSwizzleEXT")]
            public static
            void Swizzle(Int32 res, Int32 @in, OpenTK.Graphics.OpenGL.ExtVertexShader outX, OpenTK.Graphics.OpenGL.ExtVertexShader outY, OpenTK.Graphics.OpenGL.ExtVertexShader outZ, OpenTK.Graphics.OpenGL.ExtVertexShader outW)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSwizzleEXT((UInt32)res, (UInt32)@in, (OpenTK.Graphics.OpenGL.ExtVertexShader)outX, (OpenTK.Graphics.OpenGL.ExtVertexShader)outY, (OpenTK.Graphics.OpenGL.ExtVertexShader)outZ, (OpenTK.Graphics.OpenGL.ExtVertexShader)outW);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glSwizzleEXT")]
            public static
            void Swizzle(UInt32 res, UInt32 @in, OpenTK.Graphics.OpenGL.ExtVertexShader outX, OpenTK.Graphics.OpenGL.ExtVertexShader outY, OpenTK.Graphics.OpenGL.ExtVertexShader outZ, OpenTK.Graphics.OpenGL.ExtVertexShader outW)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSwizzleEXT((UInt32)res, (UInt32)@in, (OpenTK.Graphics.OpenGL.ExtVertexShader)outX, (OpenTK.Graphics.OpenGL.ExtVertexShader)outY, (OpenTK.Graphics.OpenGL.ExtVertexShader)outZ, (OpenTK.Graphics.OpenGL.ExtVertexShader)outW);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bEXT")]
            public static
            void Tangent3(Byte tx, Byte ty, Byte tz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3bEXT((SByte)tx, (SByte)ty, (SByte)tz);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bEXT")]
            public static
            void Tangent3(SByte tx, SByte ty, SByte tz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3bEXT((SByte)tx, (SByte)ty, (SByte)tz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bvEXT")]
            public static
            void Tangent3(Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glTangent3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bvEXT")]
            public static
            void Tangent3(ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glTangent3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bvEXT")]
            public static
            unsafe void Tangent3(Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3bvEXT((SByte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bvEXT")]
            public static
            void Tangent3(SByte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = v)
                        {
                            Delegates.glTangent3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bvEXT")]
            public static
            void Tangent3(ref SByte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = &v)
                        {
                            Delegates.glTangent3bvEXT((SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3bvEXT")]
            public static
            unsafe void Tangent3(SByte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3bvEXT((SByte*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3dEXT")]
            public static
            void Tangent3(Double tx, Double ty, Double tz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3dEXT((Double)tx, (Double)ty, (Double)tz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3dvEXT")]
            public static
            void Tangent3(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glTangent3dvEXT((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3dvEXT")]
            public static
            void Tangent3(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glTangent3dvEXT((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3dvEXT")]
            public static
            unsafe void Tangent3(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3dvEXT((Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3fEXT")]
            public static
            void Tangent3(Single tx, Single ty, Single tz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3fEXT((Single)tx, (Single)ty, (Single)tz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3fvEXT")]
            public static
            void Tangent3(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTangent3fvEXT((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3fvEXT")]
            public static
            void Tangent3(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTangent3fvEXT((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3fvEXT")]
            public static
            unsafe void Tangent3(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3fvEXT((Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3iEXT")]
            public static
            void Tangent3(Int32 tx, Int32 ty, Int32 tz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3iEXT((Int32)tx, (Int32)ty, (Int32)tz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3ivEXT")]
            public static
            void Tangent3(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glTangent3ivEXT((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3ivEXT")]
            public static
            void Tangent3(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glTangent3ivEXT((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3ivEXT")]
            public static
            unsafe void Tangent3(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3ivEXT((Int32*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3sEXT")]
            public static
            void Tangent3(Int16 tx, Int16 ty, Int16 tz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3sEXT((Int16)tx, (Int16)ty, (Int16)tz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3svEXT")]
            public static
            void Tangent3(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glTangent3svEXT((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3svEXT")]
            public static
            void Tangent3(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glTangent3svEXT((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangent3svEXT")]
            public static
            unsafe void Tangent3(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangent3svEXT((Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangentPointerEXT")]
            public static
            void TangentPointer(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTangentPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangentPointerEXT")]
            public static
            void TangentPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTangentPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangentPointerEXT")]
            public static
            void TangentPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTangentPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangentPointerEXT")]
            public static
            void TangentPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTangentPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCoordinateFrame", Version = "1.1", EntryPoint = "glTangentPointerEXT")]
            public static
            void TangentPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTangentPointerEXT((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTextureBufferObject", Version = "2.0", EntryPoint = "glTexBufferEXT")]
            public static
            void TexBuffer(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ExtTextureBufferObject internalformat, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexBufferEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ExtTextureBufferObject)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureBufferObject", Version = "2.0", EntryPoint = "glTexBufferEXT")]
            public static
            void TexBuffer(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ExtTextureBufferObject internalformat, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexBufferEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ExtTextureBufferObject)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glTexCoordPointerEXT")]
            public static
            void TexCoordPointer(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, Int32 count, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoordPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glTexCoordPointerEXT")]
            public static
            void TexCoordPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glTexCoordPointerEXT")]
            public static
            void TexCoordPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glTexCoordPointerEXT")]
            public static
            void TexCoordPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glTexCoordPointerEXT")]
            public static
            void TexCoordPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexImage3DEXT")]
            public static
            void TexImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexImage3DEXT")]
            public static
            void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexImage3DEXT")]
            public static
            void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexImage3DEXT")]
            public static
            void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalFormat">
            /// <para>
            /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexImage3DEXT")]
            public static
            void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glTexParameterIivEXT")]
            public static
            void TexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glTexParameterIivEXT")]
            public static
            void TexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glTexParameterIivEXT")]
            public static
            unsafe void TexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexParameterIivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glTexParameterIuivEXT")]
            public static
            void TexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glTexParameterIuivEXT")]
            public static
            void TexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTextureInteger", Version = "2.0", EntryPoint = "glTexParameterIuivEXT")]
            public static
            unsafe void TexParameterI(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexParameterIuivEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage1DEXT")]
            public static
            void TexSubImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage1DEXT")]
            public static
            void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] pixels)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage1DEXT")]
            public static
            void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] pixels)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage1DEXT")]
            public static
            void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] pixels)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage1DEXT")]
            public static
            void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 pixels)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage1DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T6)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage2DEXT")]
            public static
            void TexSubImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage2DEXT")]
            public static
            void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage2DEXT")]
            public static
            void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage2DEXT")]
            public static
            void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtSubtexture", Version = "1.0", EntryPoint = "glTexSubImage2DEXT")]
            public static
            void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage2DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T8)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexSubImage3DEXT")]
            public static
            void TexSubImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexSubImage3DEXT")]
            public static
            void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexSubImage3DEXT")]
            public static
            void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexSubImage3DEXT")]
            public static
            void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="zoffset">
            /// <para>
            /// Specifies a texel offset in the z direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtTexture3D", Version = "1.0", EntryPoint = "glTexSubImage3DEXT")]
            public static
            void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage3DEXT((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T10)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureBufferEXT")]
            public static
            void TextureBuffer(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureBufferEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureBufferEXT")]
            public static
            void TextureBuffer(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureBufferEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T8)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage1DEXT")]
            public static
            void TextureImage1D<T8>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T8)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage2DEXT")]
            public static
            void TextureImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T10)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureImage3DEXT")]
            public static
            void TextureImage3D<T10>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.ExtDirectStateAccess internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.ExtDirectStateAccess)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T10)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtLightTexture", Version = "1.1", EntryPoint = "glTextureLightEXT")]
            public static
            void TextureLight(OpenTK.Graphics.OpenGL.ExtLightTexture pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureLightEXT((OpenTK.Graphics.OpenGL.ExtLightTexture)pname);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtLightTexture", Version = "1.1", EntryPoint = "glTextureMaterialEXT")]
            public static
            void TextureMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureMaterialEXT((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTexturePerturbNormal", Version = "1.1", EntryPoint = "glTextureNormalEXT")]
            public static
            void TextureNormal(OpenTK.Graphics.OpenGL.ExtTexturePerturbNormal mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureNormalEXT((OpenTK.Graphics.OpenGL.ExtTexturePerturbNormal)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterfEXT")]
            public static
            void TextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterfEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterfEXT")]
            public static
            void TextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterfEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterfvEXT")]
            public static
            void TextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterfvEXT")]
            public static
            unsafe void TextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterfvEXT")]
            public static
            void TextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterfvEXT")]
            public static
            unsafe void TextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterfvEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameteriEXT")]
            public static
            void TextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameteriEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameteriEXT")]
            public static
            void TextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameteriEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIivEXT")]
            public static
            void TextureParameterI(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIivEXT")]
            public static
            void TextureParameterI(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIivEXT")]
            public static
            unsafe void TextureParameterI(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIivEXT")]
            public static
            void TextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIivEXT")]
            public static
            void TextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIivEXT")]
            public static
            unsafe void TextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterIivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIuivEXT")]
            public static
            void TextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterIuivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIuivEXT")]
            public static
            void TextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glTextureParameterIuivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterIuivEXT")]
            public static
            unsafe void TextureParameterI(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterIuivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterivEXT")]
            public static
            void TextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterivEXT")]
            public static
            unsafe void TextureParameter(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterivEXT")]
            public static
            void TextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureParameterivEXT")]
            public static
            unsafe void TextureParameter(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureParameterivEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureRenderbufferEXT")]
            public static
            void TextureRenderbuffer(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureRenderbufferEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureRenderbufferEXT")]
            public static
            void TextureRenderbuffer(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureRenderbufferEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,,] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T7 pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T7)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,,] pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage1DEXT")]
            public static
            void TextureSubImage1D<T7>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T7 pixels)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage1DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T7)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage2DEXT")]
            public static
            void TextureSubImage2D<T9>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
                where T9 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage2DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T9)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[,] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[,,] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(Int32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T11 pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T11)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[,] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T11[,,] pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glTextureSubImage3DEXT")]
            public static
            void TextureSubImage3D<T11>(UInt32 texture, OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T11 pixels)
                where T11 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureSubImage3DEXT((UInt32)texture, (OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T11)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glTransformFeedbackVaryingsEXT")]
            public static
            void TransformFeedbackVaryings(Int32 program, Int32 count, String[] varyings, OpenTK.Graphics.OpenGL.ExtTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTransformFeedbackVaryingsEXT((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.OpenGL.ExtTransformFeedback)bufferMode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtTransformFeedback", Version = "2.0", EntryPoint = "glTransformFeedbackVaryingsEXT")]
            public static
            void TransformFeedbackVaryings(UInt32 program, Int32 count, String[] varyings, OpenTK.Graphics.OpenGL.ExtTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTransformFeedbackVaryingsEXT((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.OpenGL.ExtTransformFeedback)bufferMode);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uiEXT")]
            public static
            void Uniform1(Int32 location, Int32 v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1uiEXT((Int32)location, (UInt32)v0);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uiEXT")]
            public static
            void Uniform1(Int32 location, UInt32 v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1uiEXT((Int32)location, (UInt32)v0);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uivEXT")]
            public static
            void Uniform1(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform1uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uivEXT")]
            public static
            void Uniform1(Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glUniform1uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uivEXT")]
            public static
            unsafe void Uniform1(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uivEXT")]
            public static
            void Uniform1(Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glUniform1uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uivEXT")]
            public static
            void Uniform1(Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glUniform1uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform1uivEXT")]
            public static
            unsafe void Uniform1(Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uiEXT")]
            public static
            void Uniform2(Int32 location, Int32 v0, Int32 v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2uiEXT((Int32)location, (UInt32)v0, (UInt32)v1);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uiEXT")]
            public static
            void Uniform2(Int32 location, UInt32 v0, UInt32 v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2uiEXT((Int32)location, (UInt32)v0, (UInt32)v1);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uivEXT")]
            public static
            void Uniform2(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform2uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uivEXT")]
            public static
            unsafe void Uniform2(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uivEXT")]
            public static
            void Uniform2(Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glUniform2uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uivEXT")]
            public static
            void Uniform2(Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glUniform2uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform2uivEXT")]
            public static
            unsafe void Uniform2(Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uiEXT")]
            public static
            void Uniform3(Int32 location, Int32 v0, Int32 v1, Int32 v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3uiEXT((Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uiEXT")]
            public static
            void Uniform3(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3uiEXT((Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uivEXT")]
            public static
            void Uniform3(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform3uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uivEXT")]
            public static
            void Uniform3(Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glUniform3uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uivEXT")]
            public static
            unsafe void Uniform3(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uivEXT")]
            public static
            void Uniform3(Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glUniform3uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uivEXT")]
            public static
            void Uniform3(Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glUniform3uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform3uivEXT")]
            public static
            unsafe void Uniform3(Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uiEXT")]
            public static
            void Uniform4(Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4uiEXT((Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2, (UInt32)v3);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uiEXT")]
            public static
            void Uniform4(Int32 location, UInt32 v0, UInt32 v1, UInt32 v2, UInt32 v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4uiEXT((Int32)location, (UInt32)v0, (UInt32)v1, (UInt32)v2, (UInt32)v3);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uivEXT")]
            public static
            void Uniform4(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform4uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uivEXT")]
            public static
            void Uniform4(Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glUniform4uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uivEXT")]
            public static
            unsafe void Uniform4(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uivEXT")]
            public static
            void Uniform4(Int32 location, Int32 count, UInt32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = value)
                        {
                            Delegates.glUniform4uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uivEXT")]
            public static
            void Uniform4(Int32 location, Int32 count, ref UInt32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* value_ptr = &value)
                        {
                            Delegates.glUniform4uivEXT((Int32)location, (Int32)count, (UInt32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtGpuShader4", Version = "2.0", EntryPoint = "glUniform4uivEXT")]
            public static
            unsafe void Uniform4(Int32 location, Int32 count, UInt32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4uivEXT((Int32)location, (Int32)count, (UInt32*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtBindableUniform", Version = "2.0", EntryPoint = "glUniformBufferEXT")]
            public static
            void UniformBuffer(Int32 program, Int32 location, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniformBufferEXT((UInt32)program, (Int32)location, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtBindableUniform", Version = "2.0", EntryPoint = "glUniformBufferEXT")]
            public static
            void UniformBuffer(UInt32 program, Int32 location, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniformBufferEXT((UInt32)program, (Int32)location, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtCompiledVertexArray", Version = "1.1", EntryPoint = "glUnlockArraysEXT")]
            public static
            void UnlockArrays()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUnlockArraysEXT();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glUnmapNamedBufferEXT")]
            public static
            bool UnmapNamedBuffer(Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glUnmapNamedBufferEXT((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtDirectStateAccess", Version = "", EntryPoint = "glUnmapNamedBufferEXT")]
            public static
            bool UnmapNamedBuffer(UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glUnmapNamedBufferEXT((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantbvEXT")]
            public static
            void Variant(UInt32 id, SByte[] addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* addr_ptr = addr)
                        {
                            Delegates.glVariantbvEXT((UInt32)id, (SByte*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantbvEXT")]
            public static
            void Variant(UInt32 id, ref SByte addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* addr_ptr = &addr)
                        {
                            Delegates.glVariantbvEXT((UInt32)id, (SByte*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantbvEXT")]
            public static
            unsafe void Variant(UInt32 id, SByte* addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantbvEXT((UInt32)id, (SByte*)addr);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantdvEXT")]
            public static
            void Variant(Int32 id, Double[] addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* addr_ptr = addr)
                        {
                            Delegates.glVariantdvEXT((UInt32)id, (Double*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantdvEXT")]
            public static
            void Variant(Int32 id, ref Double addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* addr_ptr = &addr)
                        {
                            Delegates.glVariantdvEXT((UInt32)id, (Double*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantdvEXT")]
            public static
            unsafe void Variant(Int32 id, Double* addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantdvEXT((UInt32)id, (Double*)addr);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantdvEXT")]
            public static
            void Variant(UInt32 id, Double[] addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* addr_ptr = addr)
                        {
                            Delegates.glVariantdvEXT((UInt32)id, (Double*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantdvEXT")]
            public static
            void Variant(UInt32 id, ref Double addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* addr_ptr = &addr)
                        {
                            Delegates.glVariantdvEXT((UInt32)id, (Double*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantdvEXT")]
            public static
            unsafe void Variant(UInt32 id, Double* addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantdvEXT((UInt32)id, (Double*)addr);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantfvEXT")]
            public static
            void Variant(Int32 id, Single[] addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* addr_ptr = addr)
                        {
                            Delegates.glVariantfvEXT((UInt32)id, (Single*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantfvEXT")]
            public static
            void Variant(Int32 id, ref Single addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* addr_ptr = &addr)
                        {
                            Delegates.glVariantfvEXT((UInt32)id, (Single*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantfvEXT")]
            public static
            unsafe void Variant(Int32 id, Single* addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantfvEXT((UInt32)id, (Single*)addr);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantfvEXT")]
            public static
            void Variant(UInt32 id, Single[] addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* addr_ptr = addr)
                        {
                            Delegates.glVariantfvEXT((UInt32)id, (Single*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantfvEXT")]
            public static
            void Variant(UInt32 id, ref Single addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* addr_ptr = &addr)
                        {
                            Delegates.glVariantfvEXT((UInt32)id, (Single*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantfvEXT")]
            public static
            unsafe void Variant(UInt32 id, Single* addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantfvEXT((UInt32)id, (Single*)addr);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantivEXT")]
            public static
            void Variant(Int32 id, Int32[] addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* addr_ptr = addr)
                        {
                            Delegates.glVariantivEXT((UInt32)id, (Int32*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexShader", Version = "1.2", EntryPoint = "glVariantivEXT")]
            public static
            void Variant(Int32 id, ref Int32 addr)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* addr_ptr = &addr)
                        {
                            Delegates.glVariantivEXT((UInt32)id, (Int32*)addr_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI1iEXT")]
            public static
            void VertexAttribI1(Int32 index, Int32 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI1iEXT((UInt32)index, (Int32)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI1iEXT")]
            public static
            void VertexAttribI1(UInt32 index, Int32 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI1iEXT((UInt32)index, (Int32)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI1ivEXT")]
            public static
            unsafe void VertexAttribI1(Int32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI1ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI1ivEXT")]
            public static
            unsafe void VertexAttribI1(UInt32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI1ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI1uiEXT")]
            public static
            void VertexAttribI1(UInt32 index, UInt32 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI1uiEXT((UInt32)index, (UInt32)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI1uivEXT")]
            public static
            unsafe void VertexAttribI1(UInt32 index, UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI1uivEXT((UInt32)index, (UInt32*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2iEXT")]
            public static
            void VertexAttribI2(Int32 index, Int32 x, Int32 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI2iEXT((UInt32)index, (Int32)x, (Int32)y);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2iEXT")]
            public static
            void VertexAttribI2(UInt32 index, Int32 x, Int32 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI2iEXT((UInt32)index, (Int32)x, (Int32)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2ivEXT")]
            public static
            void VertexAttribI2(Int32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI2ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2ivEXT")]
            public static
            void VertexAttribI2(Int32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI2ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2ivEXT")]
            public static
            unsafe void VertexAttribI2(Int32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI2ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2ivEXT")]
            public static
            void VertexAttribI2(UInt32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI2ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2ivEXT")]
            public static
            void VertexAttribI2(UInt32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI2ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2ivEXT")]
            public static
            unsafe void VertexAttribI2(UInt32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI2ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2uiEXT")]
            public static
            void VertexAttribI2(UInt32 index, UInt32 x, UInt32 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI2uiEXT((UInt32)index, (UInt32)x, (UInt32)y);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2uivEXT")]
            public static
            void VertexAttribI2(UInt32 index, UInt32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI2uivEXT((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2uivEXT")]
            public static
            void VertexAttribI2(UInt32 index, ref UInt32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI2uivEXT((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI2uivEXT")]
            public static
            unsafe void VertexAttribI2(UInt32 index, UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI2uivEXT((UInt32)index, (UInt32*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3iEXT")]
            public static
            void VertexAttribI3(Int32 index, Int32 x, Int32 y, Int32 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI3iEXT((UInt32)index, (Int32)x, (Int32)y, (Int32)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3iEXT")]
            public static
            void VertexAttribI3(UInt32 index, Int32 x, Int32 y, Int32 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI3iEXT((UInt32)index, (Int32)x, (Int32)y, (Int32)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3ivEXT")]
            public static
            void VertexAttribI3(Int32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI3ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3ivEXT")]
            public static
            void VertexAttribI3(Int32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI3ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3ivEXT")]
            public static
            unsafe void VertexAttribI3(Int32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI3ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3ivEXT")]
            public static
            void VertexAttribI3(UInt32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI3ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3ivEXT")]
            public static
            void VertexAttribI3(UInt32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI3ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3ivEXT")]
            public static
            unsafe void VertexAttribI3(UInt32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI3ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3uiEXT")]
            public static
            void VertexAttribI3(UInt32 index, UInt32 x, UInt32 y, UInt32 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI3uiEXT((UInt32)index, (UInt32)x, (UInt32)y, (UInt32)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3uivEXT")]
            public static
            void VertexAttribI3(UInt32 index, UInt32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI3uivEXT((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3uivEXT")]
            public static
            void VertexAttribI3(UInt32 index, ref UInt32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI3uivEXT((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI3uivEXT")]
            public static
            unsafe void VertexAttribI3(UInt32 index, UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI3uivEXT((UInt32)index, (UInt32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4bvEXT")]
            public static
            void VertexAttribI4(UInt32 index, SByte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4bvEXT((UInt32)index, (SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4bvEXT")]
            public static
            void VertexAttribI4(UInt32 index, ref SByte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4bvEXT((UInt32)index, (SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4bvEXT")]
            public static
            unsafe void VertexAttribI4(UInt32 index, SByte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4bvEXT((UInt32)index, (SByte*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4iEXT")]
            public static
            void VertexAttribI4(Int32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4iEXT((UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4iEXT")]
            public static
            void VertexAttribI4(UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4iEXT((UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ivEXT")]
            public static
            void VertexAttribI4(Int32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ivEXT")]
            public static
            void VertexAttribI4(Int32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ivEXT")]
            public static
            unsafe void VertexAttribI4(Int32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ivEXT")]
            public static
            void VertexAttribI4(UInt32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ivEXT")]
            public static
            void VertexAttribI4(UInt32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4ivEXT((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ivEXT")]
            public static
            unsafe void VertexAttribI4(UInt32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4ivEXT((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4svEXT")]
            public static
            void VertexAttribI4(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4svEXT((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4svEXT")]
            public static
            void VertexAttribI4(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4svEXT((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4svEXT")]
            public static
            unsafe void VertexAttribI4(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4svEXT((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4svEXT")]
            public static
            void VertexAttribI4(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4svEXT((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4svEXT")]
            public static
            void VertexAttribI4(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4svEXT((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4svEXT")]
            public static
            unsafe void VertexAttribI4(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4svEXT((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ubvEXT")]
            public static
            void VertexAttribI4(Int32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4ubvEXT((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ubvEXT")]
            public static
            void VertexAttribI4(Int32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4ubvEXT((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ubvEXT")]
            public static
            unsafe void VertexAttribI4(Int32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4ubvEXT((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ubvEXT")]
            public static
            void VertexAttribI4(UInt32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4ubvEXT((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ubvEXT")]
            public static
            void VertexAttribI4(UInt32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4ubvEXT((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4ubvEXT")]
            public static
            unsafe void VertexAttribI4(UInt32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4ubvEXT((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4uiEXT")]
            public static
            void VertexAttribI4(UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4uiEXT((UInt32)index, (UInt32)x, (UInt32)y, (UInt32)z, (UInt32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4uivEXT")]
            public static
            void VertexAttribI4(UInt32 index, UInt32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4uivEXT((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4uivEXT")]
            public static
            void VertexAttribI4(UInt32 index, ref UInt32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4uivEXT((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4uivEXT")]
            public static
            unsafe void VertexAttribI4(UInt32 index, UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4uivEXT((UInt32)index, (UInt32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4usvEXT")]
            public static
            void VertexAttribI4(UInt32 index, UInt16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = v)
                        {
                            Delegates.glVertexAttribI4usvEXT((UInt32)index, (UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4usvEXT")]
            public static
            void VertexAttribI4(UInt32 index, ref UInt16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribI4usvEXT((UInt32)index, (UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribI4usvEXT")]
            public static
            unsafe void VertexAttribI4(UInt32 index, UInt16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribI4usvEXT((UInt32)index, (UInt16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram4", Version = "", EntryPoint = "glVertexAttribIPointerEXT")]
            public static
            void VertexAttribIPointer<T4>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.NvVertexProgram4 type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribIPointerEXT((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.NvVertexProgram4)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glVertexPointerEXT")]
            public static
            void VertexPointer(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, Int32 count, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glVertexPointerEXT")]
            public static
            void VertexPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glVertexPointerEXT")]
            public static
            void VertexPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glVertexPointerEXT")]
            public static
            void VertexPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ExtVertexArray", Version = "1.0", EntryPoint = "glVertexPointerEXT")]
            public static
            void VertexPointer<T4>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, Int32 count, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (Int32)count, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightfEXT")]
            public static
            void VertexWeight(Single weight)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexWeightfEXT((Single)weight);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightfvEXT")]
            public static
            unsafe void VertexWeight(Single* weight)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexWeightfvEXT((Single*)weight);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightPointerEXT")]
            public static
            void VertexWeightPointer(Int32 size, OpenTK.Graphics.OpenGL.ExtVertexWeighting type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexWeightPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ExtVertexWeighting)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightPointerEXT")]
            public static
            void VertexWeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ExtVertexWeighting type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexWeightPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ExtVertexWeighting)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightPointerEXT")]
            public static
            void VertexWeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ExtVertexWeighting type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexWeightPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ExtVertexWeighting)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightPointerEXT")]
            public static
            void VertexWeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ExtVertexWeighting type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexWeightPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ExtVertexWeighting)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ExtVertexWeighting", Version = "1.1", EntryPoint = "glVertexWeightPointerEXT")]
            public static
            void VertexWeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ExtVertexWeighting type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexWeightPointerEXT((Int32)size, (OpenTK.Graphics.OpenGL.ExtVertexWeighting)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }
        }
    }
}
#endif