#region License
//
// The Open Toolkit Library License
//
// Copyright (c) 2006 - 2009 the Open Toolkit library.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to 
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
#endregion

#if  ENABLE_DESKTOP_OPENGL
namespace OpenTK.Graphics.OpenGL
{
    using System;
    using System.Text;
    using System.Runtime.InteropServices;
#pragma warning disable 3019
#pragma warning disable 1591
#pragma warning disable 1572
#pragma warning disable 1573

    partial class GL
    {
        /// <summary>
        /// Operate on the accumulation buffer
        /// </summary>
        /// <param name="op">
        /// <para>
        /// Specifies the accumulation buffer operation. Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT, and GL_RETURN are accepted.
        /// </para>
        /// </param>
        /// <param name="value">
        /// <para>
        /// Specifies a floating-point value used in the accumulation buffer operation. op determines how value is used.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glAccum")]
        public static
        void Accum(OpenTK.Graphics.OpenGL.AccumOp op, Single value)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glAccum((OpenTK.Graphics.OpenGL.AccumOp)op, (Single)value);
#if DEBUG
            }
#endif
        }
        /// <summary>
        /// Define the scissor box
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the scissor box. Initially (0, 0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glScissor")]
        public static
        void Scissor(Int32 x, Int32 y, Int32 width, Int32 height)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glScissor((Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
            }
#endif
        }

        /// <summary>
        /// Specify the alpha test function
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0,1], where 0 represents the lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glAlphaFunc")]
        public static
        void AlphaFunc(OpenTK.Graphics.OpenGL.AlphaFunction func, Single @ref)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glAlphaFunc((OpenTK.Graphics.OpenGL.AlphaFunction)func, (Single)@ref);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if textures are loaded in texture memory
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be queried.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be queried.
        /// </para>
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glAreTexturesResident")]
        public static
        bool AreTexturesResident(Int32 n, Int32[] textures, [OutAttribute] bool[] residences)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = textures)
                    fixed (bool* residences_ptr = residences)
                    {
                        return Delegates.glAreTexturesResident((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if textures are loaded in texture memory
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be queried.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be queried.
        /// </para>
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glAreTexturesResident")]
        public static
        bool AreTexturesResident(Int32 n, ref Int32 textures, [OutAttribute] out bool residences)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = &textures)
                    fixed (bool* residences_ptr = &residences)
                    {
                        bool retval = Delegates.glAreTexturesResident((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                        residences = *residences_ptr;
                        return retval;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if textures are loaded in texture memory
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be queried.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be queried.
        /// </para>
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glAreTexturesResident")]
        public static
        unsafe bool AreTexturesResident(Int32 n, Int32* textures, [OutAttribute] bool* residences)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glAreTexturesResident((Int32)n, (UInt32*)textures, (bool*)residences);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if textures are loaded in texture memory
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be queried.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be queried.
        /// </para>
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glAreTexturesResident")]
        public static
        bool AreTexturesResident(Int32 n, UInt32[] textures, [OutAttribute] bool[] residences)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = textures)
                    fixed (bool* residences_ptr = residences)
                    {
                        return Delegates.glAreTexturesResident((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if textures are loaded in texture memory
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be queried.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be queried.
        /// </para>
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glAreTexturesResident")]
        public static
        bool AreTexturesResident(Int32 n, ref UInt32 textures, [OutAttribute] out bool residences)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = &textures)
                    fixed (bool* residences_ptr = &residences)
                    {
                        bool retval = Delegates.glAreTexturesResident((Int32)n, (UInt32*)textures_ptr, (bool*)residences_ptr);
                        residences = *residences_ptr;
                        return retval;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if textures are loaded in texture memory
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be queried.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be queried.
        /// </para>
        /// </param>
        /// <param name="residences">
        /// <para>
        /// Specifies an array in which the texture residence status is returned. The residence status of a texture named by an element of textures is returned in the corresponding element of residences.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glAreTexturesResident")]
        public static
        unsafe bool AreTexturesResident(Int32 n, UInt32* textures, [OutAttribute] bool* residences)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glAreTexturesResident((Int32)n, (UInt32*)textures, (bool*)residences);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render a vertex using the specified vertex array element
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies an index into the enabled vertex data arrays.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glArrayElement")]
        public static
        void ArrayElement(Int32 i)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glArrayElement((Int32)i);
#if DEBUG
            }
#endif
        }






        /// <summary>
        /// Delimit the vertices of a primitive or a group of like primitives
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the primitive or primitives that will be created from vertices presented between glBegin and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and GL_POLYGON.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glBegin")]
        public static
        void Begin(OpenTK.Graphics.OpenGL.BeginMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
                GraphicsContext.CurrentContext.ErrorChecking = false;
#endif
                Delegates.glBegin((OpenTK.Graphics.OpenGL.BeginMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the name of a texture.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glBindTexture")]
        public static
        void BindTexture(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 texture)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBindTexture((OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)texture);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Bind a named texture to a texturing target
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target to which the texture is bound. Must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="texture">
        /// <para>
        /// Specifies the name of a texture.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glBindTexture")]
        public static
        void BindTexture(OpenTK.Graphics.OpenGL.TextureTarget target, UInt32 texture)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBindTexture((OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)texture);
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Draw a bitmap
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the pixel width and height of the bitmap image.
        /// </para>
        /// </param>
        /// <param name="xorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="xmove">
        /// <para>
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="bitmap">
        /// <para>
        /// Specifies the address of the bitmap image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glBitmap")]
        public static
        void Bitmap(Int32 width, Int32 height, Single xorig, Single yorig, Single xmove, Single ymove, Byte[] bitmap)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* bitmap_ptr = bitmap)
                    {
                        Delegates.glBitmap((Int32)width, (Int32)height, (Single)xorig, (Single)yorig, (Single)xmove, (Single)ymove, (Byte*)bitmap_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a bitmap
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the pixel width and height of the bitmap image.
        /// </para>
        /// </param>
        /// <param name="xorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="xmove">
        /// <para>
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="bitmap">
        /// <para>
        /// Specifies the address of the bitmap image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glBitmap")]
        public static
        void Bitmap(Int32 width, Int32 height, Single xorig, Single yorig, Single xmove, Single ymove, ref Byte bitmap)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* bitmap_ptr = &bitmap)
                    {
                        Delegates.glBitmap((Int32)width, (Int32)height, (Single)xorig, (Single)yorig, (Single)xmove, (Single)ymove, (Byte*)bitmap_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a bitmap
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the pixel width and height of the bitmap image.
        /// </para>
        /// </param>
        /// <param name="xorig">
        /// <para>
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left corner of the bitmap, with right and up being the positive axes.
        /// </para>
        /// </param>
        /// <param name="xmove">
        /// <para>
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </para>
        /// </param>
        /// <param name="bitmap">
        /// <para>
        /// Specifies the address of the bitmap image.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glBitmap")]
        public static
        unsafe void Bitmap(Int32 width, Int32 height, Single xorig, Single yorig, Single xmove, Single ymove, Byte* bitmap)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBitmap((Int32)width, (Int32)height, (Single)xorig, (Single)yorig, (Single)xmove, (Single)ymove, (Byte*)bitmap);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glBlendFunc")]
        public static
        void BlendFunc(OpenTK.Graphics.OpenGL.BlendingFactorSrc sfactor, OpenTK.Graphics.OpenGL.BlendingFactorDest dfactor)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBlendFunc((OpenTK.Graphics.OpenGL.BlendingFactorSrc)sfactor, (OpenTK.Graphics.OpenGL.BlendingFactorDest)dfactor);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ArbDrawBuffersBlend", Version = "1.2", EntryPoint = "glBlendFunci")]
        public static
        void BlendFunc(Int32 buf, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend src, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend dst)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBlendFunci((UInt32)buf, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)src, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)dst);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify pixel arithmetic
        /// </summary>
        /// <param name="sfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dfactor">
        /// <para>
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawBuffersBlend", Version = "1.2", EntryPoint = "glBlendFunci")]
        public static
        void BlendFunc(UInt32 buf, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend src, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend dst)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBlendFunci((UInt32)buf, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)src, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)dst);
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Specify pixel arithmetic for RGB and alpha components separately
        /// </summary>
        /// <param name="srcRGB">
        /// <para>
        /// Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstRGB">
        /// <para>
        /// Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        /// <param name="srcAlpha">
        /// <para>
        /// Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstAlpha">
        /// <para>
        /// Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "ArbDrawBuffersBlend", Version = "1.2", EntryPoint = "glBlendFuncSeparatei")]
        public static
        void BlendFuncSeparate(Int32 buf, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend srcRGB, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend dstRGB, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend srcAlpha, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend dstAlpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBlendFuncSeparatei((UInt32)buf, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)srcRGB, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)dstRGB, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)srcAlpha, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)dstAlpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify pixel arithmetic for RGB and alpha components separately
        /// </summary>
        /// <param name="srcRGB">
        /// <para>
        /// Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstRGB">
        /// <para>
        /// Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        /// <param name="srcAlpha">
        /// <para>
        /// Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.
        /// </para>
        /// </param>
        /// <param name="dstAlpha">
        /// <para>
        /// Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawBuffersBlend", Version = "1.2", EntryPoint = "glBlendFuncSeparatei")]
        public static
        void BlendFuncSeparate(UInt32 buf, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend srcRGB, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend dstRGB, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend srcAlpha, OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend dstAlpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glBlendFuncSeparatei((UInt32)buf, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)srcRGB, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)dstRGB, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)srcAlpha, (OpenTK.Graphics.OpenGL.ArbDrawBuffersBlend)dstAlpha);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Execute a display list
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies the integer name of the display list to be executed.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallList")]
        public static
        void CallList(Int32 list)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCallList((UInt32)list);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Execute a display list
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies the integer name of the display list to be executed.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallList")]
        public static
        void CallList(UInt32 list)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCallList((UInt32)list);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Execute a list of display lists
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of display lists to be executed.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallLists")]
        public static
        void CallLists(Int32 n, OpenTK.Graphics.OpenGL.ListNameType type, IntPtr lists)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCallLists((Int32)n, (OpenTK.Graphics.OpenGL.ListNameType)type, (IntPtr)lists);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Execute a list of display lists
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of display lists to be executed.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallLists")]
        public static
        void CallLists<T2>(Int32 n, OpenTK.Graphics.OpenGL.ListNameType type, [InAttribute, OutAttribute] T2[] lists)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle lists_ptr = GCHandle.Alloc(lists, GCHandleType.Pinned);
                try
                {
                    Delegates.glCallLists((Int32)n, (OpenTK.Graphics.OpenGL.ListNameType)type, (IntPtr)lists_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    lists_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Execute a list of display lists
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of display lists to be executed.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallLists")]
        public static
        void CallLists<T2>(Int32 n, OpenTK.Graphics.OpenGL.ListNameType type, [InAttribute, OutAttribute] T2[,] lists)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle lists_ptr = GCHandle.Alloc(lists, GCHandleType.Pinned);
                try
                {
                    Delegates.glCallLists((Int32)n, (OpenTK.Graphics.OpenGL.ListNameType)type, (IntPtr)lists_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    lists_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Execute a list of display lists
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of display lists to be executed.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallLists")]
        public static
        void CallLists<T2>(Int32 n, OpenTK.Graphics.OpenGL.ListNameType type, [InAttribute, OutAttribute] T2[,,] lists)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle lists_ptr = GCHandle.Alloc(lists, GCHandleType.Pinned);
                try
                {
                    Delegates.glCallLists((Int32)n, (OpenTK.Graphics.OpenGL.ListNameType)type, (IntPtr)lists_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    lists_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Execute a list of display lists
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of display lists to be executed.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are accepted.
        /// </para>
        /// </param>
        /// <param name="lists">
        /// <para>
        /// Specifies the address of an array of name offsets in the display list. The pointer type is void because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCallLists")]
        public static
        void CallLists<T2>(Int32 n, OpenTK.Graphics.OpenGL.ListNameType type, [InAttribute, OutAttribute] ref T2 lists)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle lists_ptr = GCHandle.Alloc(lists, GCHandleType.Pinned);
                try
                {
                    Delegates.glCallLists((Int32)n, (OpenTK.Graphics.OpenGL.ListNameType)type, (IntPtr)lists_ptr.AddrOfPinnedObject());
                    lists = (T2)lists_ptr.Target;
                }
                finally
                {
                    lists_ptr.Free();
                }
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Clear buffers to preset values
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Bitwise OR of masks that indicate the buffers to be cleared. The four masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_ACCUM_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glClear")]
        public static
        void Clear(OpenTK.Graphics.OpenGL.ClearBufferMask mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClear((OpenTK.Graphics.OpenGL.ClearBufferMask)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify clear values for the accumulation buffer
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The initial values are all 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glClearAccum")]
        public static
        void ClearAccum(Single red, Single green, Single blue, Single alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClearAccum((Single)red, (Single)green, (Single)blue, (Single)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify clear values for the color buffers
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glClearColor")]
        public static
        void ClearColor(Single red, Single green, Single blue, Single alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClearColor((Single)red, (Single)green, (Single)blue, (Single)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the clear value for the depth buffer
        /// </summary>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glClearDepth")]
        public static
        void ClearDepth(Double depth)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClearDepth((Double)depth);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the clear value for the color index buffers
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the index used when the color index buffers are cleared. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glClearIndex")]
        public static
        void ClearIndex(Single c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClearIndex((Single)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the clear value for the stencil buffer
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specifies the index used when the stencil buffer is cleared. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glClearStencil")]
        public static
        void ClearStencil(Int32 s)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClearStencil((Int32)s);
#if DEBUG
            }
#endif
        }
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glClientWaitSync")]
        public static
        OpenTK.Graphics.OpenGL.ArbSync ClientWaitSync(IntPtr sync, Int32 flags, Int64 timeout)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glClientWaitSync((IntPtr)sync, (UInt32)flags, (UInt64)timeout);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glClientWaitSync")]
        public static
        OpenTK.Graphics.OpenGL.ArbSync ClientWaitSync(IntPtr sync, UInt32 flags, UInt64 timeout)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glClientWaitSync((IntPtr)sync, (UInt32)flags, (UInt64)timeout);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a plane against which all geometry is clipped
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glClipPlane")]
        public static
        void ClipPlane(OpenTK.Graphics.OpenGL.ClipPlaneName plane, Double[] equation)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* equation_ptr = equation)
                    {
                        Delegates.glClipPlane((OpenTK.Graphics.OpenGL.ClipPlaneName)plane, (Double*)equation_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a plane against which all geometry is clipped
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glClipPlane")]
        public static
        void ClipPlane(OpenTK.Graphics.OpenGL.ClipPlaneName plane, ref Double equation)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* equation_ptr = &equation)
                    {
                        Delegates.glClipPlane((OpenTK.Graphics.OpenGL.ClipPlaneName)plane, (Double*)equation_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a plane against which all geometry is clipped
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where i is an integer between 0 and GL_MAX_CLIP_PLANES - 1, are accepted.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Specifies the address of an array of four double-precision floating-point values. These values are interpreted as a plane equation.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glClipPlane")]
        public static
        unsafe void ClipPlane(OpenTK.Graphics.OpenGL.ClipPlaneName plane, Double* equation)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glClipPlane((OpenTK.Graphics.OpenGL.ClipPlaneName)plane, (Double*)equation);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3b")]
        public static
        void Color3(SByte red, SByte green, SByte blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3b((SByte)red, (SByte)green, (SByte)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3bv")]
        public static
        void Color3(SByte[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (SByte* v_ptr = v)
                    {
                        Delegates.glColor3bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3bv")]
        public static
        void Color3(ref SByte v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (SByte* v_ptr = &v)
                    {
                        Delegates.glColor3bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3bv")]
        public static
        unsafe void Color3(SByte* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3bv((SByte*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3d")]
        public static
        void Color3(Double red, Double green, Double blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3d((Double)red, (Double)green, (Double)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3dv")]
        public static
        void Color3(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glColor3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3dv")]
        public static
        void Color3(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glColor3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3dv")]
        public static
        unsafe void Color3(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3f")]
        public static
        void Color3(Single red, Single green, Single blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3f((Single)red, (Single)green, (Single)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3fv")]
        public static
        void Color3(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glColor3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3fv")]
        public static
        void Color3(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glColor3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3fv")]
        public static
        unsafe void Color3(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3i")]
        public static
        void Color3(Int32 red, Int32 green, Int32 blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3i((Int32)red, (Int32)green, (Int32)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3iv")]
        public static
        void Color3(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glColor3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3iv")]
        public static
        void Color3(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glColor3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3iv")]
        public static
        unsafe void Color3(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3s")]
        public static
        void Color3(Int16 red, Int16 green, Int16 blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3s((Int16)red, (Int16)green, (Int16)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3sv")]
        public static
        void Color3(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glColor3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3sv")]
        public static
        void Color3(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glColor3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3sv")]
        public static
        unsafe void Color3(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3ub")]
        public static
        void Color3(Byte red, Byte green, Byte blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3ub((Byte)red, (Byte)green, (Byte)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3ubv")]
        public static
        void Color3(Byte[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* v_ptr = v)
                    {
                        Delegates.glColor3ubv((Byte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3ubv")]
        public static
        void Color3(ref Byte v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* v_ptr = &v)
                    {
                        Delegates.glColor3ubv((Byte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3ubv")]
        public static
        unsafe void Color3(Byte* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3ubv((Byte*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3ui")]
        public static
        void Color3(UInt32 red, UInt32 green, UInt32 blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3ui((UInt32)red, (UInt32)green, (UInt32)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3uiv")]
        public static
        void Color3(UInt32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* v_ptr = v)
                    {
                        Delegates.glColor3uiv((UInt32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3uiv")]
        public static
        void Color3(ref UInt32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* v_ptr = &v)
                    {
                        Delegates.glColor3uiv((UInt32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3uiv")]
        public static
        unsafe void Color3(UInt32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3uiv((UInt32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3us")]
        public static
        void Color3(UInt16 red, UInt16 green, UInt16 blue)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3us((UInt16)red, (UInt16)green, (UInt16)blue);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3usv")]
        public static
        void Color3(UInt16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* v_ptr = v)
                    {
                        Delegates.glColor3usv((UInt16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3usv")]
        public static
        void Color3(ref UInt16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* v_ptr = &v)
                    {
                        Delegates.glColor3usv((UInt16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor3usv")]
        public static
        unsafe void Color3(UInt16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor3usv((UInt16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4b")]
        public static
        void Color4(SByte red, SByte green, SByte blue, SByte alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4b((SByte)red, (SByte)green, (SByte)blue, (SByte)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4bv")]
        public static
        void Color4(SByte[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (SByte* v_ptr = v)
                    {
                        Delegates.glColor4bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4bv")]
        public static
        void Color4(ref SByte v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (SByte* v_ptr = &v)
                    {
                        Delegates.glColor4bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4bv")]
        public static
        unsafe void Color4(SByte* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4bv((SByte*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4d")]
        public static
        void Color4(Double red, Double green, Double blue, Double alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4d((Double)red, (Double)green, (Double)blue, (Double)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4dv")]
        public static
        void Color4(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glColor4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4dv")]
        public static
        void Color4(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glColor4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4dv")]
        public static
        unsafe void Color4(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4f")]
        public static
        void Color4(Single red, Single green, Single blue, Single alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4f((Single)red, (Single)green, (Single)blue, (Single)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4fv")]
        public static
        void Color4(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glColor4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4fv")]
        public static
        void Color4(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glColor4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4fv")]
        public static
        unsafe void Color4(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4i")]
        public static
        void Color4(Int32 red, Int32 green, Int32 blue, Int32 alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4i((Int32)red, (Int32)green, (Int32)blue, (Int32)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4iv")]
        public static
        void Color4(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glColor4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4iv")]
        public static
        void Color4(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glColor4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4iv")]
        public static
        unsafe void Color4(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4s")]
        public static
        void Color4(Int16 red, Int16 green, Int16 blue, Int16 alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4s((Int16)red, (Int16)green, (Int16)blue, (Int16)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4sv")]
        public static
        void Color4(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glColor4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4sv")]
        public static
        void Color4(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glColor4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4sv")]
        public static
        unsafe void Color4(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4ub")]
        public static
        void Color4(Byte red, Byte green, Byte blue, Byte alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4ub((Byte)red, (Byte)green, (Byte)blue, (Byte)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4ubv")]
        public static
        void Color4(Byte[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* v_ptr = v)
                    {
                        Delegates.glColor4ubv((Byte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4ubv")]
        public static
        void Color4(ref Byte v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* v_ptr = &v)
                    {
                        Delegates.glColor4ubv((Byte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4ubv")]
        public static
        unsafe void Color4(Byte* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4ubv((Byte*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4ui")]
        public static
        void Color4(UInt32 red, UInt32 green, UInt32 blue, UInt32 alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4ui((UInt32)red, (UInt32)green, (UInt32)blue, (UInt32)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4uiv")]
        public static
        void Color4(UInt32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* v_ptr = v)
                    {
                        Delegates.glColor4uiv((UInt32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4uiv")]
        public static
        void Color4(ref UInt32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* v_ptr = &v)
                    {
                        Delegates.glColor4uiv((UInt32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4uiv")]
        public static
        unsafe void Color4(UInt32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4uiv((UInt32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4us")]
        public static
        void Color4(UInt16 red, UInt16 green, UInt16 blue, UInt16 alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4us((UInt16)red, (UInt16)green, (UInt16)blue, (UInt16)alpha);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4usv")]
        public static
        void Color4(UInt16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* v_ptr = v)
                    {
                        Delegates.glColor4usv((UInt16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4usv")]
        public static
        void Color4(ref UInt16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* v_ptr = &v)
                    {
                        Delegates.glColor4usv((UInt16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify new red, green, and blue values for the current color.
        /// </para>
        /// </param>
        /// <param name="alpha">
        /// <para>
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4 commands.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColor4usv")]
        public static
        unsafe void Color4(UInt16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColor4usv((UInt16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Enable and disable writing of frame buffer color components
        /// </summary>
        /// <param name="red">
        /// <para>
        /// Specify whether red, green, blue, and alpha can or cannot be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components can be written.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glColorMask")]
        public static
        void ColorMask(bool red, bool green, bool blue, bool alpha)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColorMask((bool)red, (bool)green, (bool)blue, (bool)alpha);
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Cause a material color to track the current color
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies whether front, back, or both front and back material parameters should track the current color. Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. The initial value is GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies which of several material parameters track the current color. Accepted values are GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE. The initial value is GL_AMBIENT_AND_DIFFUSE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glColorMaterial")]
        public static
        void ColorMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.ColorMaterialParameter mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColorMaterial((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.ColorMaterialParameter)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of colors
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glColorPointer")]
        public static
        void ColorPointer(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColorPointer((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of colors
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glColorPointer")]
        public static
        void ColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorPointer((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of colors
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glColorPointer")]
        public static
        void ColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorPointer((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of colors
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glColorPointer")]
        public static
        void ColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorPointer((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of colors
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glColorPointer")]
        public static
        void ColorPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorPointer((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T3)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        /// <summary>
        /// Define a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of entries in the color lookup table specified by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTable")]
        public static
        void ColorTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr table)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of entries in the color lookup table specified by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTable")]
        public static
        void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] table)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of entries in the color lookup table specified by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTable")]
        public static
        void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] table)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of entries in the color lookup table specified by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTable")]
        public static
        void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] table)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of entries in the color lookup table specified by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTable")]
        public static
        void ColorTable<T5>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 table)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    table = (T5)table_ptr.Target;
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameters are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTableParameterfv")]
        public static
        void ColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.ColorTableParameterPName pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glColorTableParameterfv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.ColorTableParameterPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameters are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTableParameterfv")]
        public static
        void ColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.ColorTableParameterPName pname, ref Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glColorTableParameterfv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.ColorTableParameterPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameters are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTableParameterfv")]
        public static
        unsafe void ColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.ColorTableParameterPName pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColorTableParameterfv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.ColorTableParameterPName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameters are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTableParameteriv")]
        public static
        void ColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.ColorTableParameterPName pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glColorTableParameteriv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.ColorTableParameterPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameters are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTableParameteriv")]
        public static
        void ColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.ColorTableParameterPName pname, ref Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glColorTableParameteriv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.ColorTableParameterPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameters are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glColorTableParameteriv")]
        public static
        unsafe void ColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.ColorTableParameterPName pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glColorTableParameteriv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.ColorTableParameterPName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }





        /// <summary>
        /// Define a one-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_1D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter1D")]
        public static
        void ConvolutionFilter1D(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr image)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glConvolutionFilter1D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_1D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter1D")]
        public static
        void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] image)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter1D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_1D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter1D")]
        public static
        void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] image)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter1D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_1D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter1D")]
        public static
        void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] image)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter1D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_1D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter1D")]
        public static
        void ConvolutionFilter1D<T5>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 image)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter1D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    image = (T5)image_ptr.Target;
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter2D")]
        public static
        void ConvolutionFilter2D(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr image)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glConvolutionFilter2D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter2D")]
        public static
        void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] image)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter2D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter2D")]
        public static
        void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] image)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter2D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter2D")]
        public static
        void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] image)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter2D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the pixel array referenced by data.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Pointer to a two-dimensional array of pixel data that is processed to build the convolution filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionFilter2D")]
        public static
        void ConvolutionFilter2D<T6>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 image)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glConvolutionFilter2D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    image = (T6)image_ptr.Target;
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionParameterf")]
        public static
        void ConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.ConvolutionParameter pname, Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glConvolutionParameterf((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.ConvolutionParameter)pname, (Single)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionParameterfv")]
        public static
        void ConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.ConvolutionParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glConvolutionParameterfv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.ConvolutionParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionParameterfv")]
        public static
        unsafe void ConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.ConvolutionParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glConvolutionParameterfv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.ConvolutionParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionParameteri")]
        public static
        void ConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.ConvolutionParameter pname, Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glConvolutionParameteri((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.ConvolutionParameter)pname, (Int32)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionParameteriv")]
        public static
        void ConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.ConvolutionParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glConvolutionParameteriv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.ConvolutionParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glConvolutionParameteriv")]
        public static
        unsafe void ConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.ConvolutionParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glConvolutionParameteriv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.ConvolutionParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Respecify a portion of a color table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// The starting index of the portion of the color table to be replaced.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window coordinates of the left corner of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of table entries to replace.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glCopyColorSubTable")]
        public static
        void CopyColorSubTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, Int32 start, Int32 x, Int32 y, Int32 width)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyColorSubTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (Int32)start, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy pixels into a color table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal storage format of the texture image. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.
        /// </para>
        /// </param>
        /// <param name="y">
        /// <para>
        /// The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glCopyColorTable")]
        public static
        void CopyColorTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy pixels into a one-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_1D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array to copy.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glCopyConvolutionFilter1D")]
        public static
        void CopyConvolutionFilter1D(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyConvolutionFilter1D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy pixels into a two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The width of the pixel array to copy.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The height of the pixel array to copy.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glCopyConvolutionFilter2D")]
        public static
        void CopyConvolutionFilter2D(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 height)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyConvolutionFilter2D((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy pixels in the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glCopyPixels")]
        public static
        void CopyPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelCopyType type)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelCopyType)type);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy pixels into a 1D texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. Must be 0 or 2 sup n + 2 ( border ) for some integer . The height of the texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glCopyTexImage1D")]
        public static
        void CopyTexImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 border)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyTexImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)border);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy pixels into a 2D texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image. Must be 0 or 2 sup n + 2 ( border ) for some integer .
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image. Must be 0 or 2 sup m + 2 ( border ) for some integer .
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glCopyTexImage2D")]
        public static
        void CopyTexImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width, Int32 height, Int32 border)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyTexImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width, (Int32)height, (Int32)border);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies the texel offset within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glCopyTexSubImage1D")]
        public static
        void CopyTexSubImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 x, Int32 y, Int32 width)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyTexSubImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glCopyTexSubImage2D")]
        public static
        void CopyTexSubImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 x, Int32 y, Int32 width, Int32 height)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyTexSubImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Copy a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glCopyTexSubImage3D")]
        public static
        void CopyTexSubImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 x, Int32 y, Int32 width, Int32 height)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCopyTexSubImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
            }
#endif
        }

        /// <summary>
        /// Specify whether front- or back-facing facets can be culled
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glCullFace")]
        public static
        void CullFace(OpenTK.Graphics.OpenGL.CullFaceMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glCullFace((OpenTK.Graphics.OpenGL.CullFaceMode)mode);
#if DEBUG
            }
#endif
        }





        /// <summary>
        /// Delete a contiguous group of display lists
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies the integer name of the first display list to delete.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the number of display lists to delete.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDeleteLists")]
        public static
        void DeleteLists(Int32 list, Int32 range)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDeleteLists((UInt32)list, (Int32)range);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Delete a contiguous group of display lists
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies the integer name of the first display list to delete.
        /// </para>
        /// </param>
        /// <param name="range">
        /// <para>
        /// Specifies the number of display lists to delete.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDeleteLists")]
        public static
        void DeleteLists(UInt32 list, Int32 range)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDeleteLists((UInt32)list, (Int32)range);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDeleteTextures")]
        public static
        void DeleteTextures(Int32 n, Int32[] textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = textures)
                    {
                        Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDeleteTextures")]
        public static
        void DeleteTextures(Int32 n, ref Int32 textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = &textures)
                    {
                        Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDeleteTextures")]
        public static
        unsafe void DeleteTextures(Int32 n, Int32* textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDeleteTextures((Int32)n, (UInt32*)textures);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDeleteTextures")]
        public static
        void DeleteTextures(Int32 n, UInt32[] textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = textures)
                    {
                        Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDeleteTextures")]
        public static
        void DeleteTextures(Int32 n, ref UInt32 textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = &textures)
                    {
                        Delegates.glDeleteTextures((Int32)n, (UInt32*)textures_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Delete named textures
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be deleted.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array of textures to be deleted.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDeleteTextures")]
        public static
        unsafe void DeleteTextures(Int32 n, UInt32* textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDeleteTextures((Int32)n, (UInt32*)textures);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Specify the value used for depth buffer comparisons
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glDepthFunc")]
        public static
        void DepthFunc(OpenTK.Graphics.OpenGL.DepthFunction func)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDepthFunc((OpenTK.Graphics.OpenGL.DepthFunction)func);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Enable or disable writing into the depth buffer
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glDepthMask")]
        public static
        void DepthMask(bool flag)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDepthMask((bool)flag);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify mapping of depth values from normalized device coordinates to window coordinates
        /// </summary>
        /// <param name="nearVal">
        /// <para>
        /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="farVal">
        /// <para>
        /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glDepthRange")]
        public static
        void DepthRange(Double near, Double far)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDepthRange((Double)near, (Double)far);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glDisable")]
        public static
        void Disable(OpenTK.Graphics.OpenGL.EnableCap cap)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDisable((OpenTK.Graphics.OpenGL.EnableCap)cap);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glDisableClientState")]
        public static
        void DisableClientState(OpenTK.Graphics.OpenGL.ArrayCap array)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDisableClientState((OpenTK.Graphics.OpenGL.ArrayCap)array);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="first">
        /// <para>
        /// Specifies the starting index in the enabled arrays.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of indices to be rendered.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDrawArrays")]
        public static
        void DrawArrays(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 first, Int32 count)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawArrays((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)first, (Int32)count);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glDrawArraysInstanced")]
        public static
        void DrawArraysInstanced(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 first, Int32 count, Int32 primcount)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawArraysInstanced((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)first, (Int32)count, (Int32)primcount);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify which color buffers are to be drawn into
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, and GL_AUXi, where i is between 0 and the value of GL_AUX_BUFFERS minus 1, are accepted. (GL_AUX_BUFFERS is not the upper limit; use glGet to query the number of available aux buffers.) The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glDrawBuffer")]
        public static
        void DrawBuffer(OpenTK.Graphics.OpenGL.DrawBufferMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawBuffer((OpenTK.Graphics.OpenGL.DrawBufferMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDrawElements")]
        public static
        void DrawElements(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDrawElements")]
        public static
        void DrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDrawElements")]
        public static
        void DrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDrawElements")]
        public static
        void DrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glDrawElements")]
        public static
        void DrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsBaseVertex")]
        public static
        void DrawElementsBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)basevertex);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsBaseVertex")]
        public static
        void DrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsBaseVertex")]
        public static
        void DrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsBaseVertex")]
        public static
        void DrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsBaseVertex")]
        public static
        void DrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glDrawElementsInstanced")]
        public static
        void DrawElementsInstanced(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawElementsInstanced((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glDrawElementsInstanced")]
        public static
        void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstanced((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glDrawElementsInstanced")]
        public static
        void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstanced((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glDrawElementsInstanced")]
        public static
        void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstanced((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glDrawElementsInstanced")]
        public static
        void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstanced((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsInstancedBaseVertex")]
        public static
        void DrawElementsInstancedBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawElementsInstancedBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)basevertex);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsInstancedBaseVertex")]
        public static
        void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsInstancedBaseVertex")]
        public static
        void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsInstancedBaseVertex")]
        public static
        void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawElementsInstancedBaseVertex")]
        public static
        void DrawElementsInstancedBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawElementsInstancedBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)basevertex);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Write a block of pixels to the frame buffer
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDrawPixels")]
        public static
        void DrawPixels(Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawPixels((Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Write a block of pixels to the frame buffer
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDrawPixels")]
        public static
        void DrawPixels<T4>(Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[] pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawPixels((Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Write a block of pixels to the frame buffer
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDrawPixels")]
        public static
        void DrawPixels<T4>(Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,] pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawPixels((Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Write a block of pixels to the frame buffer
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDrawPixels")]
        public static
        void DrawPixels<T4>(Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,,] pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawPixels((Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Write a block of pixels to the frame buffer
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glDrawPixels")]
        public static
        void DrawPixels<T4>(Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T4 pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawPixels((Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T4)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    indices = (T5)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Render primitives from array data
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_QUAD_STRIP, GL_QUADS, and GL_POLYGON are accepted.
        /// </para>
        /// </param>
        /// <param name="start">
        /// <para>
        /// Specifies the minimum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="end">
        /// <para>
        /// Specifies the maximum array index contained in indices.
        /// </para>
        /// </param>
        /// <param name="count">
        /// <para>
        /// Specifies the number of elements to be rendered.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.
        /// </para>
        /// </param>
        /// <param name="indices">
        /// <para>
        /// Specifies a pointer to the location where the indices are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glDrawRangeElements")]
        public static
        void DrawRangeElements<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElements((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject());
                    indices = (T5)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)basevertex);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                    indices = (T5)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)basevertex);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[] indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,] indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T5[,,] indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glDrawRangeElementsBaseVertex")]
        public static
        void DrawRangeElementsBaseVertex<T5>(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T5 indices, Int32 basevertex)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glDrawRangeElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)basevertex);
                    indices = (T5)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Flag edges as either boundary or nonboundary
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEdgeFlag")]
        public static
        void EdgeFlag(bool flag)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEdgeFlag((bool)flag);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of edge flags
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glEdgeFlagPointer")]
        public static
        void EdgeFlagPointer(Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEdgeFlagPointer((Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of edge flags
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glEdgeFlagPointer")]
        public static
        void EdgeFlagPointer<T1>(Int32 stride, [InAttribute, OutAttribute] T1[] pointer)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glEdgeFlagPointer((Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of edge flags
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glEdgeFlagPointer")]
        public static
        void EdgeFlagPointer<T1>(Int32 stride, [InAttribute, OutAttribute] T1[,] pointer)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glEdgeFlagPointer((Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of edge flags
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glEdgeFlagPointer")]
        public static
        void EdgeFlagPointer<T1>(Int32 stride, [InAttribute, OutAttribute] T1[,,] pointer)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glEdgeFlagPointer((Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of edge flags
        /// </summary>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glEdgeFlagPointer")]
        public static
        void EdgeFlagPointer<T1>(Int32 stride, [InAttribute, OutAttribute] ref T1 pointer)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glEdgeFlagPointer((Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T1)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Flag edges as either boundary or nonboundary
        /// </summary>
        /// <param name="flag">
        /// <para>
        /// Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEdgeFlagv")]
        public static
        unsafe void EdgeFlag(bool* flag)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEdgeFlagv((bool*)flag);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Enable or disable server-side GL capabilities
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies a symbolic constant indicating a GL capability.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glEnable")]
        public static
        void Enable(OpenTK.Graphics.OpenGL.EnableCap cap)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEnable((OpenTK.Graphics.OpenGL.EnableCap)cap);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Enable or disable client-side capability
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY, GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glEnableClientState")]
        public static
        void EnableClientState(OpenTK.Graphics.OpenGL.ArrayCap array)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEnableClientState((OpenTK.Graphics.OpenGL.ArrayCap)array);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEnd")]
        public static
        void End()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEnd();
#if DEBUG
                GraphicsContext.CurrentContext.ErrorChecking = true;
            }
#endif
        }



        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEndList")]
        public static
        void EndList()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEndList();
#if DEBUG
            }
#endif
        }

        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord1d")]
        public static
        void EvalCoord1(Double u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord1d((Double)u);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord1dv")]
        public static
        unsafe void EvalCoord1(Double* u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord1dv((Double*)u);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord1f")]
        public static
        void EvalCoord1(Single u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord1f((Single)u);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord1fv")]
        public static
        unsafe void EvalCoord1(Single* u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord1fv((Single*)u);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2d")]
        public static
        void EvalCoord2(Double u, Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord2d((Double)u, (Double)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2dv")]
        public static
        void EvalCoord2(Double[] u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* u_ptr = u)
                    {
                        Delegates.glEvalCoord2dv((Double*)u_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2dv")]
        public static
        void EvalCoord2(ref Double u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* u_ptr = &u)
                    {
                        Delegates.glEvalCoord2dv((Double*)u_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2dv")]
        public static
        unsafe void EvalCoord2(Double* u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord2dv((Double*)u);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2f")]
        public static
        void EvalCoord2(Single u, Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord2f((Single)u, (Single)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2fv")]
        public static
        void EvalCoord2(Single[] u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* u_ptr = u)
                    {
                        Delegates.glEvalCoord2fv((Single*)u_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2fv")]
        public static
        void EvalCoord2(ref Single u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* u_ptr = &u)
                    {
                        Delegates.glEvalCoord2fv((Single*)u_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Evaluate enabled one- and two-dimensional maps
        /// </summary>
        /// <param name="u">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap1 or glMap2 command.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Specifies a value that is the domain coordinate to the basis function defined in a previous glMap2 command. This argument is not present in a glEvalCoord1 command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalCoord2fv")]
        public static
        unsafe void EvalCoord2(Single* u)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalCoord2fv((Single*)u);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Compute a one- or two-dimensional grid of points or lines
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted.
        /// </para>
        /// </param>
        /// <param name="i1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable .
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalMesh1")]
        public static
        void EvalMesh1(OpenTK.Graphics.OpenGL.MeshMode1 mode, Int32 i1, Int32 i2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalMesh1((OpenTK.Graphics.OpenGL.MeshMode1)mode, (Int32)i1, (Int32)i2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Compute a one- or two-dimensional grid of points or lines
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic constants GL_POINT and GL_LINE are accepted.
        /// </para>
        /// </param>
        /// <param name="i1">
        /// <para>
        /// Specify the first and last integer values for grid domain variable .
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalMesh2")]
        public static
        void EvalMesh2(OpenTK.Graphics.OpenGL.MeshMode2 mode, Int32 i1, Int32 i2, Int32 j1, Int32 j2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalMesh2((OpenTK.Graphics.OpenGL.MeshMode2)mode, (Int32)i1, (Int32)i2, (Int32)j1, (Int32)j2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate and evaluate a single point in a mesh
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies the integer value for grid domain variable .
        /// </para>
        /// </param>
        /// <param name="j">
        /// <para>
        /// Specifies the integer value for grid domain variable (glEvalPoint2 only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalPoint1")]
        public static
        void EvalPoint1(Int32 i)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalPoint1((Int32)i);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate and evaluate a single point in a mesh
        /// </summary>
        /// <param name="i">
        /// <para>
        /// Specifies the integer value for grid domain variable .
        /// </para>
        /// </param>
        /// <param name="j">
        /// <para>
        /// Specifies the integer value for grid domain variable (glEvalPoint2 only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glEvalPoint2")]
        public static
        void EvalPoint2(Int32 i, Int32 j)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glEvalPoint2((Int32)i, (Int32)j);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Controls feedback mode
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the maximum number of values that can be written into buffer.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the feedback data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFeedbackBuffer")]
        public static
        void FeedbackBuffer(Int32 size, OpenTK.Graphics.OpenGL.FeedbackType type, [OutAttribute] Single[] buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* buffer_ptr = buffer)
                    {
                        Delegates.glFeedbackBuffer((Int32)size, (OpenTK.Graphics.OpenGL.FeedbackType)type, (Single*)buffer_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Controls feedback mode
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the maximum number of values that can be written into buffer.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the feedback data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFeedbackBuffer")]
        public static
        void FeedbackBuffer(Int32 size, OpenTK.Graphics.OpenGL.FeedbackType type, [OutAttribute] out Single buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* buffer_ptr = &buffer)
                    {
                        Delegates.glFeedbackBuffer((Int32)size, (OpenTK.Graphics.OpenGL.FeedbackType)type, (Single*)buffer_ptr);
                        buffer = *buffer_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Controls feedback mode
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the maximum number of values that can be written into buffer.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex. GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the feedback data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFeedbackBuffer")]
        public static
        unsafe void FeedbackBuffer(Int32 size, OpenTK.Graphics.OpenGL.FeedbackType type, [OutAttribute] Single* buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFeedbackBuffer((Int32)size, (OpenTK.Graphics.OpenGL.FeedbackType)type, (Single*)buffer);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glFenceSync")]
        public static
        IntPtr FenceSync(OpenTK.Graphics.OpenGL.ArbSync condition, Int32 flags)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glFenceSync((OpenTK.Graphics.OpenGL.ArbSync)condition, (UInt32)flags);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glFenceSync")]
        public static
        IntPtr FenceSync(OpenTK.Graphics.OpenGL.ArbSync condition, UInt32 flags)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glFenceSync((OpenTK.Graphics.OpenGL.ArbSync)condition, (UInt32)flags);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Block until all GL execution is complete
        /// </summary>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glFinish")]
        public static
        void Finish()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFinish();
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Force execution of GL commands in finite time
        /// </summary>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glFlush")]
        public static
        void Flush()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFlush();
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Specify fog parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFogf")]
        public static
        void Fog(OpenTK.Graphics.OpenGL.FogParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFogf((OpenTK.Graphics.OpenGL.FogParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify fog parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFogfv")]
        public static
        void Fog(OpenTK.Graphics.OpenGL.FogParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glFogfv((OpenTK.Graphics.OpenGL.FogParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify fog parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFogfv")]
        public static
        unsafe void Fog(OpenTK.Graphics.OpenGL.FogParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFogfv((OpenTK.Graphics.OpenGL.FogParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify fog parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFogi")]
        public static
        void Fog(OpenTK.Graphics.OpenGL.FogParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFogi((OpenTK.Graphics.OpenGL.FogParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify fog parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFogiv")]
        public static
        void Fog(OpenTK.Graphics.OpenGL.FogParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glFogiv((OpenTK.Graphics.OpenGL.FogParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify fog parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glFogiv")]
        public static
        unsafe void Fog(OpenTK.Graphics.OpenGL.FogParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFogiv((OpenTK.Graphics.OpenGL.FogParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "Version32", Version = "1.2", EntryPoint = "glFramebufferTexture")]
        public static
        void FramebufferTexture(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFramebufferTexture((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "1.2", EntryPoint = "glFramebufferTexture")]
        public static
        void FramebufferTexture(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFramebufferTexture((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "Version32", Version = "1.2", EntryPoint = "glFramebufferTextureFace")]
        public static
        void FramebufferTextureFace(OpenTK.Graphics.OpenGL.Version32 target, OpenTK.Graphics.OpenGL.Version32 attachment, Int32 texture, Int32 level, OpenTK.Graphics.OpenGL.Version32 face)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFramebufferTextureFace((OpenTK.Graphics.OpenGL.Version32)target, (OpenTK.Graphics.OpenGL.Version32)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.Version32)face);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "1.2", EntryPoint = "glFramebufferTextureFace")]
        public static
        void FramebufferTextureFace(OpenTK.Graphics.OpenGL.Version32 target, OpenTK.Graphics.OpenGL.Version32 attachment, UInt32 texture, Int32 level, OpenTK.Graphics.OpenGL.Version32 face)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFramebufferTextureFace((OpenTK.Graphics.OpenGL.Version32)target, (OpenTK.Graphics.OpenGL.Version32)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.Version32)face);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Define front- and back-facing polygons
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glFrontFace")]
        public static
        void FrontFace(OpenTK.Graphics.OpenGL.FrontFaceDirection mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glFrontFace((OpenTK.Graphics.OpenGL.FrontFaceDirection)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate a contiguous set of empty display lists
        /// </summary>
        /// <param name="range">
        /// <para>
        /// Specifies the number of contiguous empty display lists to be generated.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGenLists")]
        public static
        Int32 GenLists(Int32 range)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glGenLists((Int32)range);
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGenTextures")]
        public static
        void GenTextures(Int32 n, [OutAttribute] Int32[] textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = textures)
                    {
                        Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGenTextures")]
        public static
        void GenTextures(Int32 n, [OutAttribute] out Int32 textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = &textures)
                    {
                        Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                        textures = *textures_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGenTextures")]
        public static
        unsafe void GenTextures(Int32 n, [OutAttribute] Int32* textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGenTextures((Int32)n, (UInt32*)textures);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGenTextures")]
        public static
        void GenTextures(Int32 n, [OutAttribute] UInt32[] textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = textures)
                    {
                        Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGenTextures")]
        public static
        void GenTextures(Int32 n, [OutAttribute] out UInt32 textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = &textures)
                    {
                        Delegates.glGenTextures((Int32)n, (UInt32*)textures_ptr);
                        textures = *textures_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Generate texture names
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of texture names to be generated.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array in which the generated texture names are stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGenTextures")]
        public static
        unsafe void GenTextures(Int32 n, [OutAttribute] UInt32* textures)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGenTextures((Int32)n, (UInt32*)textures);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetBooleanv")]
        public static
        void GetBoolean(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] bool[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (bool* @params_ptr = @params)
                    {
                        Delegates.glGetBooleanv((OpenTK.Graphics.OpenGL.GetPName)pname, (bool*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetBooleanv")]
        public static
        void GetBoolean(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] out bool @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (bool* @params_ptr = &@params)
                    {
                        Delegates.glGetBooleanv((OpenTK.Graphics.OpenGL.GetPName)pname, (bool*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetBooleanv")]
        public static
        unsafe void GetBoolean(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] bool* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetBooleanv((OpenTK.Graphics.OpenGL.GetPName)pname, (bool*)@params);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Return the coefficients of the specified clipping plane
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetClipPlane")]
        public static
        void GetClipPlane(OpenTK.Graphics.OpenGL.ClipPlaneName plane, [OutAttribute] Double[] equation)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* equation_ptr = equation)
                    {
                        Delegates.glGetClipPlane((OpenTK.Graphics.OpenGL.ClipPlaneName)plane, (Double*)equation_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the coefficients of the specified clipping plane
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetClipPlane")]
        public static
        void GetClipPlane(OpenTK.Graphics.OpenGL.ClipPlaneName plane, [OutAttribute] out Double equation)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* equation_ptr = &equation)
                    {
                        Delegates.glGetClipPlane((OpenTK.Graphics.OpenGL.ClipPlaneName)plane, (Double*)equation_ptr);
                        equation = *equation_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the coefficients of the specified clipping plane
        /// </summary>
        /// <param name="plane">
        /// <para>
        /// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at least six clipping planes are supported. They are identified by symbolic names of the form GL_CLIP_PLANE where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
        /// </para>
        /// </param>
        /// <param name="equation">
        /// <para>
        /// Returns four double-precision values that are the coefficients of the plane equation of plane in eye coordinates. The initial value is (0, 0, 0, 0).
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetClipPlane")]
        public static
        unsafe void GetClipPlane(OpenTK.Graphics.OpenGL.ClipPlaneName plane, [OutAttribute] Double* equation)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetClipPlane((OpenTK.Graphics.OpenGL.ClipPlaneName)plane, (Double*)equation);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Retrieve contents of a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTable")]
        public static
        void GetColorTable(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr table)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Retrieve contents of a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTable")]
        public static
        void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] table)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Retrieve contents of a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTable")]
        public static
        void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] table)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Retrieve contents of a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTable")]
        public static
        void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] table)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Retrieve contents of a color lookup table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="table">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTable")]
        public static
        void GetColorTable<T3>(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 table)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetColorTable((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    table = (T3)table_ptr.Target;
                }
                finally
                {
                    table_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameter will be stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTableParameterfv")]
        public static
        void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetColorTableParameterfv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameter will be stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTableParameterfv")]
        public static
        void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetColorTableParameterfv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameter will be stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTableParameterfv")]
        public static
        unsafe void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetColorTableParameterfv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameter will be stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTableParameteriv")]
        public static
        void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetColorTableParameteriv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameter will be stored.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTableParameteriv")]
        public static
        void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetColorTableParameteriv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get color lookup table parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to an array where the values of the parameter will be stored.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetColorTableParameteriv")]
        public static
        unsafe void GetColorTableParameter(OpenTK.Graphics.OpenGL.ColorTableTarget target, OpenTK.Graphics.OpenGL.GetColorTableParameterPName pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetColorTableParameteriv((OpenTK.Graphics.OpenGL.ColorTableTarget)target, (OpenTK.Graphics.OpenGL.GetColorTableParameterPName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get current 1D or 2D convolution filter kernel
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// <para>
        /// Pointer to storage for the output image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionFilter")]
        public static
        void GetConvolutionFilter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr image)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetConvolutionFilter((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get current 1D or 2D convolution filter kernel
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// <para>
        /// Pointer to storage for the output image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionFilter")]
        public static
        void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] image)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetConvolutionFilter((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get current 1D or 2D convolution filter kernel
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// <para>
        /// Pointer to storage for the output image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionFilter")]
        public static
        void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] image)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetConvolutionFilter((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get current 1D or 2D convolution filter kernel
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// <para>
        /// Pointer to storage for the output image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionFilter")]
        public static
        void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] image)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetConvolutionFilter((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get current 1D or 2D convolution filter kernel
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="image">
        /// <para>
        /// Pointer to storage for the output image.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionFilter")]
        public static
        void GetConvolutionFilter<T3>(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 image)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle image_ptr = GCHandle.Alloc(image, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetConvolutionFilter((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)image_ptr.AddrOfPinnedObject());
                    image = (T3)image_ptr.Target;
                }
                finally
                {
                    image_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the parameters to be retrieved.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionParameterfv")]
        public static
        void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.GetConvolutionParameterPName pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetConvolutionParameterfv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.GetConvolutionParameterPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the parameters to be retrieved.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionParameterfv")]
        public static
        void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.GetConvolutionParameterPName pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetConvolutionParameterfv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.GetConvolutionParameterPName)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the parameters to be retrieved.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionParameterfv")]
        public static
        unsafe void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.GetConvolutionParameterPName pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetConvolutionParameterfv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.GetConvolutionParameterPName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the parameters to be retrieved.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionParameteriv")]
        public static
        void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.GetConvolutionParameterPName pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetConvolutionParameteriv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.GetConvolutionParameterPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the parameters to be retrieved.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionParameteriv")]
        public static
        void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.GetConvolutionParameterPName pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetConvolutionParameteriv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.GetConvolutionParameterPName)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get convolution parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE, GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS, GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or GL_MAX_CONVOLUTION_HEIGHT.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the parameters to be retrieved.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetConvolutionParameteriv")]
        public static
        unsafe void GetConvolutionParameter(OpenTK.Graphics.OpenGL.ConvolutionTarget target, OpenTK.Graphics.OpenGL.GetConvolutionParameterPName pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetConvolutionParameteriv((OpenTK.Graphics.OpenGL.ConvolutionTarget)target, (OpenTK.Graphics.OpenGL.GetConvolutionParameterPName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetDoublev")]
        public static
        void GetDouble(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] Double[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* @params_ptr = @params)
                    {
                        Delegates.glGetDoublev((OpenTK.Graphics.OpenGL.GetPName)pname, (Double*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetDoublev")]
        public static
        void GetDouble(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] out Double @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* @params_ptr = &@params)
                    {
                        Delegates.glGetDoublev((OpenTK.Graphics.OpenGL.GetPName)pname, (Double*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetDoublev")]
        public static
        unsafe void GetDouble(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] Double* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetDoublev((OpenTK.Graphics.OpenGL.GetPName)pname, (Double*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return error information
        /// </summary>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetError")]
        public static
        OpenTK.Graphics.OpenGL.ErrorCode GetError()
        {
            return Delegates.glGetError();
        }

        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetFloatv")]
        public static
        void GetFloat(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetFloatv((OpenTK.Graphics.OpenGL.GetPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetFloatv")]
        public static
        void GetFloat(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetFloatv((OpenTK.Graphics.OpenGL.GetPName)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetFloatv")]
        public static
        unsafe void GetFloat(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetFloatv((OpenTK.Graphics.OpenGL.GetPName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned histogram table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogram")]
        public static
        void GetHistogram(OpenTK.Graphics.OpenGL.HistogramTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned histogram table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogram")]
        public static
        void GetHistogram<T4>(OpenTK.Graphics.OpenGL.HistogramTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[] values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned histogram table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogram")]
        public static
        void GetHistogram<T4>(OpenTK.Graphics.OpenGL.HistogramTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,] values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned histogram table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogram")]
        public static
        void GetHistogram<T4>(OpenTK.Graphics.OpenGL.HistogramTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,,] values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned histogram table.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogram")]
        public static
        void GetHistogram<T4>(OpenTK.Graphics.OpenGL.HistogramTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T4 values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    values = (T4)values_ptr.Target;
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogramParameterfv")]
        public static
        void GetHistogramParameter(OpenTK.Graphics.OpenGL.HistogramTarget target, OpenTK.Graphics.OpenGL.GetHistogramParameterPName pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetHistogramParameterfv((OpenTK.Graphics.OpenGL.HistogramTarget)target, (OpenTK.Graphics.OpenGL.GetHistogramParameterPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogramParameterfv")]
        public static
        void GetHistogramParameter(OpenTK.Graphics.OpenGL.HistogramTarget target, OpenTK.Graphics.OpenGL.GetHistogramParameterPName pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetHistogramParameterfv((OpenTK.Graphics.OpenGL.HistogramTarget)target, (OpenTK.Graphics.OpenGL.GetHistogramParameterPName)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the returned values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogramParameterfv")]
        public static
        unsafe void GetHistogramParameter(OpenTK.Graphics.OpenGL.HistogramTarget target, OpenTK.Graphics.OpenGL.GetHistogramParameterPName pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetHistogramParameterfv((OpenTK.Graphics.OpenGL.HistogramTarget)target, (OpenTK.Graphics.OpenGL.GetHistogramParameterPName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogramParameteriv")]
        public static
        void GetHistogramParameter(OpenTK.Graphics.OpenGL.HistogramTarget target, OpenTK.Graphics.OpenGL.GetHistogramParameterPName pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetHistogramParameteriv((OpenTK.Graphics.OpenGL.HistogramTarget)target, (OpenTK.Graphics.OpenGL.GetHistogramParameterPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogramParameteriv")]
        public static
        void GetHistogramParameter(OpenTK.Graphics.OpenGL.HistogramTarget target, OpenTK.Graphics.OpenGL.GetHistogramParameterPName pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetHistogramParameteriv((OpenTK.Graphics.OpenGL.HistogramTarget)target, (OpenTK.Graphics.OpenGL.GetHistogramParameterPName)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get histogram parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT, GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE, GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Pointer to storage for the returned values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetHistogramParameteriv")]
        public static
        unsafe void GetHistogramParameter(OpenTK.Graphics.OpenGL.HistogramTarget target, OpenTK.Graphics.OpenGL.GetHistogramParameterPName pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetHistogramParameteriv((OpenTK.Graphics.OpenGL.HistogramTarget)target, (OpenTK.Graphics.OpenGL.GetHistogramParameterPName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version32", Version = "3.2", EntryPoint = "glGetInteger64i_v")]
        public static
        void GetInteger64(OpenTK.Graphics.OpenGL.Version32 target, Int32 index, [OutAttribute] Int64[] data)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int64* data_ptr = data)
                    {
                        Delegates.glGetInteger64i_v((OpenTK.Graphics.OpenGL.Version32)target, (UInt32)index, (Int64*)data_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version32", Version = "3.2", EntryPoint = "glGetInteger64i_v")]
        public static
        void GetInteger64(OpenTK.Graphics.OpenGL.Version32 target, Int32 index, [OutAttribute] out Int64 data)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int64* data_ptr = &data)
                    {
                        Delegates.glGetInteger64i_v((OpenTK.Graphics.OpenGL.Version32)target, (UInt32)index, (Int64*)data_ptr);
                        data = *data_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "3.2", EntryPoint = "glGetInteger64i_v")]
        public static
        unsafe void GetInteger64(OpenTK.Graphics.OpenGL.Version32 target, Int32 index, [OutAttribute] Int64* data)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetInteger64i_v((OpenTK.Graphics.OpenGL.Version32)target, (UInt32)index, (Int64*)data);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "3.2", EntryPoint = "glGetInteger64i_v")]
        public static
        void GetInteger64(OpenTK.Graphics.OpenGL.Version32 target, UInt32 index, [OutAttribute] Int64[] data)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int64* data_ptr = data)
                    {
                        Delegates.glGetInteger64i_v((OpenTK.Graphics.OpenGL.Version32)target, (UInt32)index, (Int64*)data_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "3.2", EntryPoint = "glGetInteger64i_v")]
        public static
        void GetInteger64(OpenTK.Graphics.OpenGL.Version32 target, UInt32 index, [OutAttribute] out Int64 data)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int64* data_ptr = &data)
                    {
                        Delegates.glGetInteger64i_v((OpenTK.Graphics.OpenGL.Version32)target, (UInt32)index, (Int64*)data_ptr);
                        data = *data_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "3.2", EntryPoint = "glGetInteger64i_v")]
        public static
        unsafe void GetInteger64(OpenTK.Graphics.OpenGL.Version32 target, UInt32 index, [OutAttribute] Int64* data)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetInteger64i_v((OpenTK.Graphics.OpenGL.Version32)target, (UInt32)index, (Int64*)data);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetInteger64v")]
        public static
        void GetInteger64(OpenTK.Graphics.OpenGL.ArbSync pname, [OutAttribute] Int64[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int64* @params_ptr = @params)
                    {
                        Delegates.glGetInteger64v((OpenTK.Graphics.OpenGL.ArbSync)pname, (Int64*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetInteger64v")]
        public static
        void GetInteger64(OpenTK.Graphics.OpenGL.ArbSync pname, [OutAttribute] out Int64 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int64* @params_ptr = &@params)
                    {
                        Delegates.glGetInteger64v((OpenTK.Graphics.OpenGL.ArbSync)pname, (Int64*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetInteger64v")]
        public static
        unsafe void GetInteger64(OpenTK.Graphics.OpenGL.ArbSync pname, [OutAttribute] Int64* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetInteger64v((OpenTK.Graphics.OpenGL.ArbSync)pname, (Int64*)@params);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetIntegerv")]
        public static
        void GetInteger(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetIntegerv((OpenTK.Graphics.OpenGL.GetPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetIntegerv")]
        public static
        void GetInteger(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetIntegerv((OpenTK.Graphics.OpenGL.GetPName)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetIntegerv")]
        public static
        unsafe void GetInteger(OpenTK.Graphics.OpenGL.GetPName pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetIntegerv((OpenTK.Graphics.OpenGL.GetPName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return light source parameter values
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetLightfv")]
        public static
        void GetLight(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetLightfv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return light source parameter values
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetLightfv")]
        public static
        void GetLight(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetLightfv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return light source parameter values
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetLightfv")]
        public static
        unsafe void GetLight(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetLightfv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return light source parameter values
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetLightiv")]
        public static
        void GetLight(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetLightiv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return light source parameter values
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetLightiv")]
        public static
        void GetLight(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetLightiv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return light source parameter values
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT where ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetLightiv")]
        public static
        unsafe void GetLight(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetLightiv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapdv")]
        public static
        void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glGetMapdv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapdv")]
        public static
        void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] out Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glGetMapdv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Double*)v_ptr);
                        v = *v_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapdv")]
        public static
        unsafe void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMapdv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapfv")]
        public static
        void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glGetMapfv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapfv")]
        public static
        void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] out Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glGetMapfv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Single*)v_ptr);
                        v = *v_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapfv")]
        public static
        unsafe void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMapfv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapiv")]
        public static
        void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glGetMapiv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapiv")]
        public static
        void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] out Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glGetMapiv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Int32*)v_ptr);
                        v = *v_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return evaluator parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </para>
        /// </param>
        /// <param name="query">
        /// <para>
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </para>
        /// </param>
        /// <param name="v">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMapiv")]
        public static
        unsafe void GetMap(OpenTK.Graphics.OpenGL.MapTarget target, OpenTK.Graphics.OpenGL.GetMapQuery query, [OutAttribute] Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMapiv((OpenTK.Graphics.OpenGL.MapTarget)target, (OpenTK.Graphics.OpenGL.GetMapQuery)query, (Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return material parameters
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMaterialfv")]
        public static
        void GetMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetMaterialfv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return material parameters
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMaterialfv")]
        public static
        void GetMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetMaterialfv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return material parameters
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMaterialfv")]
        public static
        unsafe void GetMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMaterialfv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return material parameters
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMaterialiv")]
        public static
        void GetMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetMaterialiv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return material parameters
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMaterialiv")]
        public static
        void GetMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetMaterialiv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return material parameters
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted, representing the front and back materials, respectively.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION, GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetMaterialiv")]
        public static
        unsafe void GetMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMaterialiv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minimum and maximum pixel values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmax")]
        public static
        void GetMinmax(OpenTK.Graphics.OpenGL.MinmaxTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minimum and maximum pixel values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmax")]
        public static
        void GetMinmax<T4>(OpenTK.Graphics.OpenGL.MinmaxTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[] values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minimum and maximum pixel values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmax")]
        public static
        void GetMinmax<T4>(OpenTK.Graphics.OpenGL.MinmaxTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,] values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minimum and maximum pixel values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmax")]
        public static
        void GetMinmax<T4>(OpenTK.Graphics.OpenGL.MinmaxTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,,] values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minimum and maximum pixel values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="reset">
        /// <para>
        /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="types">
        /// <para>
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// A pointer to storage for the returned values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmax")]
        public static
        void GetMinmax<T4>(OpenTK.Graphics.OpenGL.MinmaxTarget target, bool reset, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T4 values)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle values_ptr = GCHandle.Alloc(values, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (bool)reset, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)values_ptr.AddrOfPinnedObject());
                    values = (T4)values_ptr.Target;
                }
                finally
                {
                    values_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minmax parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to storage for the retrieved parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmaxParameterfv")]
        public static
        void GetMinmaxParameter(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.GetMinmaxParameterPName pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetMinmaxParameterfv((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.GetMinmaxParameterPName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minmax parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to storage for the retrieved parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmaxParameterfv")]
        public static
        void GetMinmaxParameter(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.GetMinmaxParameterPName pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetMinmaxParameterfv((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.GetMinmaxParameterPName)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minmax parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to storage for the retrieved parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmaxParameterfv")]
        public static
        unsafe void GetMinmaxParameter(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.GetMinmaxParameterPName pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMinmaxParameterfv((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.GetMinmaxParameterPName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minmax parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to storage for the retrieved parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmaxParameteriv")]
        public static
        void GetMinmaxParameter(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.GetMinmaxParameterPName pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetMinmaxParameteriv((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.GetMinmaxParameterPName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minmax parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to storage for the retrieved parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmaxParameteriv")]
        public static
        void GetMinmaxParameter(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.GetMinmaxParameterPName pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetMinmaxParameteriv((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.GetMinmaxParameterPName)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get minmax parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// A pointer to storage for the retrieved parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetMinmaxParameteriv")]
        public static
        unsafe void GetMinmaxParameter(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.GetMinmaxParameterPName pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMinmaxParameteriv((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.GetMinmaxParameterPName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glGetMultisamplefv")]
        public static
        void GetMultisample(OpenTK.Graphics.OpenGL.GetMultisamplePName pname, Int32 index, [OutAttribute] Single[] val)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* val_ptr = val)
                    {
                        Delegates.glGetMultisamplefv((OpenTK.Graphics.OpenGL.GetMultisamplePName)pname, (UInt32)index, (Single*)val_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glGetMultisamplefv")]
        public static
        void GetMultisample(OpenTK.Graphics.OpenGL.GetMultisamplePName pname, Int32 index, [OutAttribute] out Single val)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* val_ptr = &val)
                    {
                        Delegates.glGetMultisamplefv((OpenTK.Graphics.OpenGL.GetMultisamplePName)pname, (UInt32)index, (Single*)val_ptr);
                        val = *val_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glGetMultisamplefv")]
        public static
        unsafe void GetMultisample(OpenTK.Graphics.OpenGL.GetMultisamplePName pname, Int32 index, [OutAttribute] Single* val)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMultisamplefv((OpenTK.Graphics.OpenGL.GetMultisamplePName)pname, (UInt32)index, (Single*)val);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glGetMultisamplefv")]
        public static
        void GetMultisample(OpenTK.Graphics.OpenGL.GetMultisamplePName pname, UInt32 index, [OutAttribute] Single[] val)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* val_ptr = val)
                    {
                        Delegates.glGetMultisamplefv((OpenTK.Graphics.OpenGL.GetMultisamplePName)pname, (UInt32)index, (Single*)val_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glGetMultisamplefv")]
        public static
        void GetMultisample(OpenTK.Graphics.OpenGL.GetMultisamplePName pname, UInt32 index, [OutAttribute] out Single val)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* val_ptr = &val)
                    {
                        Delegates.glGetMultisamplefv((OpenTK.Graphics.OpenGL.GetMultisamplePName)pname, (UInt32)index, (Single*)val_ptr);
                        val = *val_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glGetMultisamplefv")]
        public static
        unsafe void GetMultisample(OpenTK.Graphics.OpenGL.GetMultisamplePName pname, UInt32 index, [OutAttribute] Single* val)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetMultisamplefv((OpenTK.Graphics.OpenGL.GetMultisamplePName)pname, (UInt32)index, (Single*)val);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapfv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] Single[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* values_ptr = values)
                    {
                        Delegates.glGetPixelMapfv((OpenTK.Graphics.OpenGL.PixelMap)map, (Single*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapfv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] out Single values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* values_ptr = &values)
                    {
                        Delegates.glGetPixelMapfv((OpenTK.Graphics.OpenGL.PixelMap)map, (Single*)values_ptr);
                        values = *values_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapfv")]
        public static
        unsafe void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] Single* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPixelMapfv((OpenTK.Graphics.OpenGL.PixelMap)map, (Single*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapuiv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] Int32[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* values_ptr = values)
                    {
                        Delegates.glGetPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt32*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapuiv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] out Int32 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* values_ptr = &values)
                    {
                        Delegates.glGetPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt32*)values_ptr);
                        values = *values_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapuiv")]
        public static
        unsafe void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] Int32* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt32*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapuiv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] UInt32[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* values_ptr = values)
                    {
                        Delegates.glGetPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt32*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapuiv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] out UInt32 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* values_ptr = &values)
                    {
                        Delegates.glGetPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt32*)values_ptr);
                        values = *values_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapuiv")]
        public static
        unsafe void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] UInt32* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt32*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapusv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] Int16[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* values_ptr = values)
                    {
                        Delegates.glGetPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt16*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapusv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] out Int16 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* values_ptr = &values)
                    {
                        Delegates.glGetPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt16*)values_ptr);
                        values = *values_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapusv")]
        public static
        unsafe void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] Int16* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt16*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapusv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] UInt16[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* values_ptr = values)
                    {
                        Delegates.glGetPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt16*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapusv")]
        public static
        void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] out UInt16 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* values_ptr = &values)
                    {
                        Delegates.glGetPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt16*)values_ptr);
                        values = *values_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the specified pixel map
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel map contents.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPixelMapusv")]
        public static
        unsafe void GetPixelMap(OpenTK.Graphics.OpenGL.PixelMap map, [OutAttribute] UInt16* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (UInt16*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGetPointerv")]
        public static
        void GetPointer(OpenTK.Graphics.OpenGL.GetPointervPName pname, [OutAttribute] IntPtr @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPointerv((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGetPointerv")]
        public static
        void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] T1[] @params)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointerv((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGetPointerv")]
        public static
        void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] T1[,] @params)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointerv((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGetPointerv")]
        public static
        void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] T1[,,] @params)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointerv((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    @params_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the address of the specified pointer
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the array or buffer pointer to be returned. Symbolic constants GL_COLOR_ARRAY_POINTER, GL_EDGE_FLAG_ARRAY_POINTER, GL_FOG_COORD_ARRAY_POINTER, GL_FEEDBACK_BUFFER_POINTER, GL_INDEX_ARRAY_POINTER, GL_NORMAL_ARRAY_POINTER, GL_SECONDARY_COLOR_ARRAY_POINTER, GL_SELECTION_BUFFER_POINTER, GL_TEXTURE_COORD_ARRAY_POINTER, or GL_VERTEX_ARRAY_POINTER are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the pointer value specified by pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glGetPointerv")]
        public static
        void GetPointer<T1>(OpenTK.Graphics.OpenGL.GetPointervPName pname, [InAttribute, OutAttribute] ref T1 @params)
            where T1 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetPointerv((OpenTK.Graphics.OpenGL.GetPointervPName)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    @params = (T1)@params_ptr.Target;
                }
                finally
                {
                    @params_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the polygon stipple pattern
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPolygonStipple")]
        public static
        void GetPolygonStipple([OutAttribute] Byte[] mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* mask_ptr = mask)
                    {
                        Delegates.glGetPolygonStipple((Byte*)mask_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the polygon stipple pattern
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPolygonStipple")]
        public static
        void GetPolygonStipple([OutAttribute] out Byte mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* mask_ptr = &mask)
                    {
                        Delegates.glGetPolygonStipple((Byte*)mask_ptr);
                        mask = *mask_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return the polygon stipple pattern
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetPolygonStipple")]
        public static
        unsafe void GetPolygonStipple([OutAttribute] Byte* mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetPolygonStipple((Byte*)mask);
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [OutAttribute] IntPtr span)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[] span)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,] span)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] T5[,,] span)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [OutAttribute] IntPtr column, [InAttribute, OutAttribute] ref T5 span)
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column, (IntPtr)span_ptr.AddrOfPinnedObject());
                    span = (T5)span_ptr.Target;
                }
                finally
                {
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[] column, [InAttribute, OutAttribute] T5[,,] span)
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,] column, [InAttribute, OutAttribute] T5[,,] span)
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr row, [InAttribute, OutAttribute] ref T4 column, [InAttribute, OutAttribute] T5[,,] span)
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    column = (T4)column_ptr.Target;
                }
                finally
                {
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Get separable convolution filter kernel images
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to storage for the row filter image.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to storage for the column filter image.
        /// </para>
        /// </param>
        /// <param name="span">
        /// <para>
        /// Pointer to storage for the span filter image (currently unused).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glGetSeparableFilter")]
        public static
        void GetSeparableFilter<T3, T4, T5>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 row, [InAttribute, OutAttribute] T4[,,] column, [InAttribute, OutAttribute] T5[,,] span)
            where T3 : struct
            where T4 : struct
            where T5 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                GCHandle span_ptr = GCHandle.Alloc(span, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetSeparableFilter((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject(), (IntPtr)span_ptr.AddrOfPinnedObject());
                    row = (T3)row_ptr.Target;
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                    span_ptr.Free();
                }
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Return a string describing the current GL connection
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, or GL_EXTENSIONS.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetString")]
        public static
        System.String GetString(OpenTK.Graphics.OpenGL.StringName name)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe { return new string((sbyte*)Delegates.glGetString((OpenTK.Graphics.OpenGL.StringName)name)); }
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetSynciv")]
        public static
        void GetSync(IntPtr sync, OpenTK.Graphics.OpenGL.ArbSync pname, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* length_ptr = &length)
                    fixed (Int32* values_ptr = &values)
                    {
                        Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.OpenGL.ArbSync)pname, (Int32)bufSize, (Int32*)length_ptr, (Int32*)values_ptr);
                        length = *length_ptr;
                        values = *values_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetSynciv")]
        public static
        unsafe void GetSync(IntPtr sync, OpenTK.Graphics.OpenGL.ArbSync pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                fixed (Int32* values_ptr = values)
                {
                    Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.OpenGL.ArbSync)pname, (Int32)bufSize, (Int32*)length, (Int32*)values_ptr);
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glGetSynciv")]
        public static
        unsafe void GetSync(IntPtr sync, OpenTK.Graphics.OpenGL.ArbSync pname, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetSynciv((IntPtr)sync, (OpenTK.Graphics.OpenGL.ArbSync)pname, (Int32)bufSize, (Int32*)length, (Int32*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexEnvfv")]
        public static
        void GetTexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetTexEnvfv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexEnvfv")]
        public static
        void GetTexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetTexEnvfv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexEnvfv")]
        public static
        unsafe void GetTexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexEnvfv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexEnviv")]
        public static
        void GetTexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetTexEnviv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexEnviv")]
        public static
        void GetTexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetTexEnviv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexEnviv")]
        public static
        unsafe void GetTexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexEnviv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGendv")]
        public static
        void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Double[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* @params_ptr = @params)
                    {
                        Delegates.glGetTexGendv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGendv")]
        public static
        void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] out Double @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* @params_ptr = &@params)
                    {
                        Delegates.glGetTexGendv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGendv")]
        public static
        unsafe void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Double* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexGendv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGenfv")]
        public static
        void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetTexGenfv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGenfv")]
        public static
        void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetTexGenfv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGenfv")]
        public static
        unsafe void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexGenfv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGeniv")]
        public static
        void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetTexGeniv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGeniv")]
        public static
        void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetTexGeniv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture coordinate generation parameters
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glGetTexGeniv")]
        public static
        unsafe void GetTexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexGeniv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return a texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data. The supported formats are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image. Should be a pointer to an array of the type specified by type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexImage")]
        public static
        void GetTexImage(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexImage((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return a texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data. The supported formats are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image. Should be a pointer to an array of the type specified by type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexImage")]
        public static
        void GetTexImage<T4>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[] pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetTexImage((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return a texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data. The supported formats are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image. Should be a pointer to an array of the type specified by type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexImage")]
        public static
        void GetTexImage<T4>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,] pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetTexImage((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return a texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data. The supported formats are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image. Should be a pointer to an array of the type specified by type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexImage")]
        public static
        void GetTexImage<T4>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T4[,,] pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetTexImage((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return a texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies a pixel format for the returned data. The supported formats are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="img">
        /// <para>
        /// Returns the texture image. Should be a pointer to an array of the type specified by type.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexImage")]
        public static
        void GetTexImage<T4>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T4 pixels)
            where T4 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glGetTexImage((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T4)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture, either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE, GL_TEXTURE_INTENSITY_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, and GL_TEXTURE_COMPRESSED_IMAGE_SIZE are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexLevelParameterfv")]
        public static
        void GetTexLevelParameter(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetTexLevelParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture, either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE, GL_TEXTURE_INTENSITY_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, and GL_TEXTURE_COMPRESSED_IMAGE_SIZE are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexLevelParameterfv")]
        public static
        void GetTexLevelParameter(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetTexLevelParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture, either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE, GL_TEXTURE_INTENSITY_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, and GL_TEXTURE_COMPRESSED_IMAGE_SIZE are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexLevelParameterfv")]
        public static
        unsafe void GetTexLevelParameter(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexLevelParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture, either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE, GL_TEXTURE_INTENSITY_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, and GL_TEXTURE_COMPRESSED_IMAGE_SIZE are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexLevelParameteriv")]
        public static
        void GetTexLevelParameter(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetTexLevelParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture, either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE, GL_TEXTURE_INTENSITY_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, and GL_TEXTURE_COMPRESSED_IMAGE_SIZE are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexLevelParameteriv")]
        public static
        void GetTexLevelParameter(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetTexLevelParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values for a specific level of detail
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture, either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_PROXY_TEXTURE_1D, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT, GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_BORDER, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE, GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_LUMINANCE_SIZE, GL_TEXTURE_INTENSITY_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED, and GL_TEXTURE_COMPRESSED_IMAGE_SIZE are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the requested data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexLevelParameteriv")]
        public static
        unsafe void GetTexLevelParameter(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexLevelParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, and GL_TEXTURE_CUBE_MAP are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_PRIORITY, GL_TEXTURE_RESIDENT, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, and GL_GENERATE_MIPMAP are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexParameterfv")]
        public static
        void GetTexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetTexParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, and GL_TEXTURE_CUBE_MAP are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_PRIORITY, GL_TEXTURE_RESIDENT, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, and GL_GENERATE_MIPMAP are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexParameterfv")]
        public static
        void GetTexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Single @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = &@params)
                    {
                        Delegates.glGetTexParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, and GL_TEXTURE_CUBE_MAP are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_PRIORITY, GL_TEXTURE_RESIDENT, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, and GL_GENERATE_MIPMAP are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexParameterfv")]
        public static
        unsafe void GetTexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, and GL_TEXTURE_CUBE_MAP are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_PRIORITY, GL_TEXTURE_RESIDENT, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, and GL_GENERATE_MIPMAP are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexParameteriv")]
        public static
        void GetTexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glGetTexParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, and GL_TEXTURE_CUBE_MAP are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_PRIORITY, GL_TEXTURE_RESIDENT, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, and GL_GENERATE_MIPMAP are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexParameteriv")]
        public static
        void GetTexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] out Int32 @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = &@params)
                    {
                        Delegates.glGetTexParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params_ptr);
                        @params = *@params_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Return texture parameter values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the symbolic name of the target texture. GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, and GL_TEXTURE_CUBE_MAP are accepted.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_PRIORITY, GL_TEXTURE_RESIDENT, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, and GL_GENERATE_MIPMAP are accepted.
        /// </para>
        /// </param>
        /// <param name="params">
        /// <para>
        /// Returns the texture parameters.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glGetTexParameteriv")]
        public static
        unsafe void GetTexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.GetTextureParameter pname, [OutAttribute] Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glGetTexParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.GetTextureParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Specify implementation-specific hints
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a symbolic constant indicating the behavior to be controlled. GL_FOG_HINT, GL_GENERATE_MIPMAP_HINT, GL_LINE_SMOOTH_HINT, GL_PERSPECTIVE_CORRECTION_HINT, GL_POINT_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glHint")]
        public static
        void Hint(OpenTK.Graphics.OpenGL.HintTarget target, OpenTK.Graphics.OpenGL.HintMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glHint((OpenTK.Graphics.OpenGL.HintTarget)target, (OpenTK.Graphics.OpenGL.HintMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define histogram table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of entries in the histogram table. Must be a power of 2.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="sink">
        /// <para>
        /// If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glHistogram")]
        public static
        void Histogram(OpenTK.Graphics.OpenGL.HistogramTarget target, Int32 width, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, bool sink)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target, (Int32)width, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (bool)sink);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexd")]
        public static
        void Index(Double c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexd((Double)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexdv")]
        public static
        unsafe void Index(Double* c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexdv((Double*)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexf")]
        public static
        void Index(Single c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexf((Single)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexfv")]
        public static
        unsafe void Index(Single* c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexfv((Single*)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexi")]
        public static
        void Index(Int32 c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexi((Int32)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexiv")]
        public static
        unsafe void Index(Int32* c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexiv((Int32*)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the writing of individual bits in the color index buffers
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexMask")]
        public static
        void IndexMask(Int32 mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexMask((UInt32)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the writing of individual bits in the color index buffers
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable the writing of individual bits in the color index buffers. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexMask")]
        public static
        void IndexMask(UInt32 mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexMask((UInt32)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of color indexes
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexPointer")]
        public static
        void IndexPointer(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexPointer((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of color indexes
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexPointer")]
        public static
        void IndexPointer<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glIndexPointer((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of color indexes
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexPointer")]
        public static
        void IndexPointer<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glIndexPointer((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of color indexes
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexPointer")]
        public static
        void IndexPointer<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glIndexPointer((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of color indexes
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first index in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexPointer")]
        public static
        void IndexPointer<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glIndexPointer((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T2)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexs")]
        public static
        void Index(Int16 c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexs((Int16)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIndexsv")]
        public static
        unsafe void Index(Int16* c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexsv((Int16*)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexub")]
        public static
        void Index(Byte c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexub((Byte)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current color index
        /// </summary>
        /// <param name="c">
        /// <para>
        /// Specifies the new value for the current color index.
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glIndexubv")]
        public static
        unsafe void Index(Byte* c)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glIndexubv((Byte*)c);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Initialize the name stack
        /// </summary>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glInitNames")]
        public static
        void InitNames()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glInitNames();
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Simultaneously specify and enable several interleaved arrays
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the offset in bytes between each aggregate array element.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glInterleavedArrays")]
        public static
        void InterleavedArrays(OpenTK.Graphics.OpenGL.InterleavedArrayFormat format, Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glInterleavedArrays((OpenTK.Graphics.OpenGL.InterleavedArrayFormat)format, (Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Simultaneously specify and enable several interleaved arrays
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the offset in bytes between each aggregate array element.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glInterleavedArrays")]
        public static
        void InterleavedArrays<T2>(OpenTK.Graphics.OpenGL.InterleavedArrayFormat format, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glInterleavedArrays((OpenTK.Graphics.OpenGL.InterleavedArrayFormat)format, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Simultaneously specify and enable several interleaved arrays
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the offset in bytes between each aggregate array element.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glInterleavedArrays")]
        public static
        void InterleavedArrays<T2>(OpenTK.Graphics.OpenGL.InterleavedArrayFormat format, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glInterleavedArrays((OpenTK.Graphics.OpenGL.InterleavedArrayFormat)format, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Simultaneously specify and enable several interleaved arrays
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the offset in bytes between each aggregate array element.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glInterleavedArrays")]
        public static
        void InterleavedArrays<T2>(OpenTK.Graphics.OpenGL.InterleavedArrayFormat format, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glInterleavedArrays((OpenTK.Graphics.OpenGL.InterleavedArrayFormat)format, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Simultaneously specify and enable several interleaved arrays
        /// </summary>
        /// <param name="format">
        /// <para>
        /// Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F, GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F, GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the offset in bytes between each aggregate array element.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glInterleavedArrays")]
        public static
        void InterleavedArrays<T2>(OpenTK.Graphics.OpenGL.InterleavedArrayFormat format, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glInterleavedArrays((OpenTK.Graphics.OpenGL.InterleavedArrayFormat)format, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T2)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Test whether a capability is enabled
        /// </summary>
        /// <param name="cap">
        /// <para>
        /// Specifies a symbolic constant indicating a GL capability.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glIsEnabled")]
        public static
        bool IsEnabled(OpenTK.Graphics.OpenGL.EnableCap cap)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glIsEnabled((OpenTK.Graphics.OpenGL.EnableCap)cap);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if a name corresponds to a display list
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies a potential display list name.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIsList")]
        public static
        bool IsList(Int32 list)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glIsList((UInt32)list);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if a name corresponds to a display list
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies a potential display list name.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glIsList")]
        public static
        bool IsList(UInt32 list)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glIsList((UInt32)list);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glIsSync")]
        public static
        bool IsSync(IntPtr sync)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glIsSync((IntPtr)sync);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if a name corresponds to a texture
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies a value that may be the name of a texture.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glIsTexture")]
        public static
        bool IsTexture(Int32 texture)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glIsTexture((UInt32)texture);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Determine if a name corresponds to a texture
        /// </summary>
        /// <param name="texture">
        /// <para>
        /// Specifies a value that may be the name of a texture.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glIsTexture")]
        public static
        bool IsTexture(UInt32 texture)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glIsTexture((UInt32)texture);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Set light source parameters
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightf")]
        public static
        void Light(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightf((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set light source parameters
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightfv")]
        public static
        void Light(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glLightfv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set light source parameters
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightfv")]
        public static
        unsafe void Light(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightfv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set light source parameters
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLighti")]
        public static
        void Light(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLighti((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set light source parameters
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightiv")]
        public static
        void Light(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glLightiv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set light source parameters
        /// </summary>
        /// <param name="light">
        /// <para>
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are supported. They are identified by symbolic names of the form GL_LIGHT , where i ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF, GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightiv")]
        public static
        unsafe void Light(OpenTK.Graphics.OpenGL.LightName light, OpenTK.Graphics.OpenGL.LightParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightiv((OpenTK.Graphics.OpenGL.LightName)light, (OpenTK.Graphics.OpenGL.LightParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the lighting model parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that param will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightModelf")]
        public static
        void LightModel(OpenTK.Graphics.OpenGL.LightModelParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightModelf((OpenTK.Graphics.OpenGL.LightModelParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the lighting model parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that param will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightModelfv")]
        public static
        void LightModel(OpenTK.Graphics.OpenGL.LightModelParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glLightModelfv((OpenTK.Graphics.OpenGL.LightModelParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the lighting model parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that param will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightModelfv")]
        public static
        unsafe void LightModel(OpenTK.Graphics.OpenGL.LightModelParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightModelfv((OpenTK.Graphics.OpenGL.LightModelParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the lighting model parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that param will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightModeli")]
        public static
        void LightModel(OpenTK.Graphics.OpenGL.LightModelParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightModeli((OpenTK.Graphics.OpenGL.LightModelParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the lighting model parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that param will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightModeliv")]
        public static
        void LightModel(OpenTK.Graphics.OpenGL.LightModelParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glLightModeliv((OpenTK.Graphics.OpenGL.LightModelParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the lighting model parameters
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER, GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that param will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLightModeliv")]
        public static
        unsafe void LightModel(OpenTK.Graphics.OpenGL.LightModelParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLightModeliv((OpenTK.Graphics.OpenGL.LightModelParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the line stipple pattern
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped to the range [1, 256] and defaults to 1.
        /// </para>
        /// </param>
        /// <param name="pattern">
        /// <para>
        /// Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLineStipple")]
        public static
        void LineStipple(Int32 factor, Int16 pattern)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLineStipple((Int32)factor, (UInt16)pattern);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the line stipple pattern
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped to the range [1, 256] and defaults to 1.
        /// </para>
        /// </param>
        /// <param name="pattern">
        /// <para>
        /// Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when the line is rasterized. Bit zero is used first; the default pattern is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLineStipple")]
        public static
        void LineStipple(Int32 factor, UInt16 pattern)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLineStipple((Int32)factor, (UInt16)pattern);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the width of rasterized lines
        /// </summary>
        /// <param name="width">
        /// <para>
        /// Specifies the width of rasterized lines. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glLineWidth")]
        public static
        void LineWidth(Single width)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLineWidth((Single)width);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the display-list base for glCallLists
        /// </summary>
        /// <param name="base">
        /// <para>
        /// Specifies an integer offset that will be added to glCallLists offsets to generate display-list names. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glListBase")]
        public static
        void ListBase(Int32 @base)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glListBase((UInt32)@base);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the display-list base for glCallLists
        /// </summary>
        /// <param name="base">
        /// <para>
        /// Specifies an integer offset that will be added to glCallLists offsets to generate display-list names. The initial value is 0.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glListBase")]
        public static
        void ListBase(UInt32 @base)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glListBase((UInt32)@base);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the identity matrix
        /// </summary>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadIdentity")]
        public static
        void LoadIdentity()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLoadIdentity();
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadMatrixd")]
        public static
        void LoadMatrix(Double[] m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* m_ptr = m)
                    {
                        Delegates.glLoadMatrixd((Double*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadMatrixd")]
        public static
        void LoadMatrix(ref Double m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* m_ptr = &m)
                    {
                        Delegates.glLoadMatrixd((Double*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadMatrixd")]
        public static
        unsafe void LoadMatrix(Double* m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLoadMatrixd((Double*)m);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadMatrixf")]
        public static
        void LoadMatrix(Single[] m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* m_ptr = m)
                    {
                        Delegates.glLoadMatrixf((Single*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadMatrixf")]
        public static
        void LoadMatrix(ref Single m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* m_ptr = &m)
                    {
                        Delegates.glLoadMatrixf((Single*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Replace the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadMatrixf")]
        public static
        unsafe void LoadMatrix(Single* m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLoadMatrixf((Single*)m);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Load a name onto the name stack
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a name that will replace the top value on the name stack.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadName")]
        public static
        void LoadName(Int32 name)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLoadName((UInt32)name);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Load a name onto the name stack
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a name that will replace the top value on the name stack.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glLoadName")]
        public static
        void LoadName(UInt32 name)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLoadName((UInt32)name);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a logical pixel operation for color index rendering
        /// </summary>
        /// <param name="opcode">
        /// <para>
        /// Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glLogicOp")]
        public static
        void LogicOp(OpenTK.Graphics.OpenGL.LogicOp opcode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glLogicOp((OpenTK.Graphics.OpenGL.LogicOp)opcode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord1, to u hat, the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points. Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap1d")]
        public static
        void Map1(OpenTK.Graphics.OpenGL.MapTarget target, Double u1, Double u2, Int32 stride, Int32 order, Double[] points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* points_ptr = points)
                    {
                        Delegates.glMap1d((OpenTK.Graphics.OpenGL.MapTarget)target, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord1, to u hat, the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points. Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap1d")]
        public static
        void Map1(OpenTK.Graphics.OpenGL.MapTarget target, Double u1, Double u2, Int32 stride, Int32 order, ref Double points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* points_ptr = &points)
                    {
                        Delegates.glMap1d((OpenTK.Graphics.OpenGL.MapTarget)target, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord1, to u hat, the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points. Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap1d")]
        public static
        unsafe void Map1(OpenTK.Graphics.OpenGL.MapTarget target, Double u1, Double u2, Int32 stride, Int32 order, Double* points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMap1d((OpenTK.Graphics.OpenGL.MapTarget)target, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord1, to u hat, the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points. Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap1f")]
        public static
        void Map1(OpenTK.Graphics.OpenGL.MapTarget target, Single u1, Single u2, Int32 stride, Int32 order, Single[] points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* points_ptr = points)
                    {
                        Delegates.glMap1f((OpenTK.Graphics.OpenGL.MapTarget)target, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord1, to u hat, the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points. Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap1f")]
        public static
        void Map1(OpenTK.Graphics.OpenGL.MapTarget target, Single u1, Single u2, Int32 stride, Int32 order, ref Single points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* points_ptr = &points)
                    {
                        Delegates.glMap1f((OpenTK.Graphics.OpenGL.MapTarget)target, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord1, to u hat, the variable that is evaluated by the equations specified by this command.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of one control point and the beginning of the next one in the data structure referenced in points. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations.
        /// </para>
        /// </param>
        /// <param name="order">
        /// <para>
        /// Specifies the number of control points. Must be positive.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap1f")]
        public static
        unsafe void Map1(OpenTK.Graphics.OpenGL.MapTarget target, Single u1, Single u2, Int32 stride, Int32 order, Single* points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMap1f((OpenTK.Graphics.OpenGL.MapTarget)target, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to u hat, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { (i+1) j }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to v hat, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { i (j+1) }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap2d")]
        public static
        void Map2(OpenTK.Graphics.OpenGL.MapTarget target, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double[] points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* points_ptr = points)
                    {
                        Delegates.glMap2d((OpenTK.Graphics.OpenGL.MapTarget)target, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to u hat, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { (i+1) j }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to v hat, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { i (j+1) }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap2d")]
        public static
        void Map2(OpenTK.Graphics.OpenGL.MapTarget target, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, ref Double points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* points_ptr = &points)
                    {
                        Delegates.glMap2d((OpenTK.Graphics.OpenGL.MapTarget)target, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to u hat, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { (i+1) j }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to v hat, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { i (j+1) }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap2d")]
        public static
        unsafe void Map2(OpenTK.Graphics.OpenGL.MapTarget target, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double* points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMap2d((OpenTK.Graphics.OpenGL.MapTarget)target, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to u hat, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { (i+1) j }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to v hat, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { i (j+1) }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap2f")]
        public static
        void Map2(OpenTK.Graphics.OpenGL.MapTarget target, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single[] points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* points_ptr = points)
                    {
                        Delegates.glMap2f((OpenTK.Graphics.OpenGL.MapTarget)target, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to u hat, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { (i+1) j }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to v hat, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { i (j+1) }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap2f")]
        public static
        void Map2(OpenTK.Graphics.OpenGL.MapTarget target, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, ref Single points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* points_ptr = &points)
                    {
                        Delegates.glMap2f((OpenTK.Graphics.OpenGL.MapTarget)target, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a two-dimensional evaluator
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to u hat, one of the two variables that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </para>
        /// </param>
        /// <param name="ustride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { (i+1) j }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of ustride is 0.
        /// </para>
        /// </param>
        /// <param name="uorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify a linear mapping of , as presented to glEvalCoord2, to v hat, one of the two variables that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </para>
        /// </param>
        /// <param name="vstride">
        /// <para>
        /// Specifies the number of floats or doubles between the beginning of control point R sub ij and the beginning of control point R sub { i (j+1) }, where and are the and control point indices, respectively. This allows control points to be embedded in arbitrary data structures. The only constraint is that the values for a particular control point must occupy contiguous memory locations. The initial value of vstride is 0.
        /// </para>
        /// </param>
        /// <param name="vorder">
        /// <para>
        /// Specifies the dimension of the control point array in the axis. Must be positive. The initial value is 1.
        /// </para>
        /// </param>
        /// <param name="points">
        /// <para>
        /// Specifies a pointer to the array of control points.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMap2f")]
        public static
        unsafe void Map2(OpenTK.Graphics.OpenGL.MapTarget target, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single* points)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMap2f((OpenTK.Graphics.OpenGL.MapTarget)target, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Define a one- or two-dimensional mesh
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values i = 0 and i = un.
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMapGrid1d")]
        public static
        void MapGrid1(Int32 un, Double u1, Double u2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMapGrid1d((Int32)un, (Double)u1, (Double)u2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one- or two-dimensional mesh
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values i = 0 and i = un.
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMapGrid1f")]
        public static
        void MapGrid1(Int32 un, Single u1, Single u2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMapGrid1f((Int32)un, (Single)u1, (Single)u2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one- or two-dimensional mesh
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values i = 0 and i = un.
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMapGrid2d")]
        public static
        void MapGrid2(Int32 un, Double u1, Double u2, Int32 vn, Double v1, Double v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMapGrid2d((Int32)un, (Double)u1, (Double)u2, (Int32)vn, (Double)v1, (Double)v2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a one- or two-dimensional mesh
        /// </summary>
        /// <param name="un">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </para>
        /// </param>
        /// <param name="u1">
        /// <para>
        /// Specify the mappings for integer grid domain values i = 0 and i = un.
        /// </para>
        /// </param>
        /// <param name="vn">
        /// <para>
        /// Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).
        /// </para>
        /// </param>
        /// <param name="v1">
        /// <para>
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMapGrid2f")]
        public static
        void MapGrid2(Int32 un, Single u1, Single u2, Int32 vn, Single v1, Single v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMapGrid2f((Int32)un, (Single)u1, (Single)u2, (Int32)vn, (Single)v1, (Single)v2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify material parameters for the lighting model
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMaterialf")]
        public static
        void Material(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMaterialf((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify material parameters for the lighting model
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMaterialfv")]
        public static
        void Material(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glMaterialfv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify material parameters for the lighting model
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMaterialfv")]
        public static
        unsafe void Material(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMaterialfv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify material parameters for the lighting model
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMateriali")]
        public static
        void Material(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMateriali((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify material parameters for the lighting model
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMaterialiv")]
        public static
        void Material(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glMaterialiv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify material parameters for the lighting model
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be GL_SHININESS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMaterialiv")]
        public static
        unsafe void Material(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMaterialiv((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify which matrix is the current matrix
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies which matrix stack is the target for subsequent matrix operations. Three values are accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW. Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMatrixMode")]
        public static
        void MatrixMode(OpenTK.Graphics.OpenGL.MatrixMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMatrixMode((OpenTK.Graphics.OpenGL.MatrixMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define minmax table
        /// </summary>
        /// <param name="target">
        /// <para>
        /// The minmax table whose parameters are to be set. Must be GL_MINMAX.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="sink">
        /// <para>
        /// If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glMinmax")]
        public static
        void Minmax(OpenTK.Graphics.OpenGL.MinmaxTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, bool sink)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (bool)sink);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbSampleShading", Version = "1.2", EntryPoint = "glMinSampleShading")]
        public static
        void MinSampleShading(Single value)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMinSampleShading((Single)value);
#if DEBUG
            }
#endif
        }


        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32[] basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    fixed (Int32* basevertex_ptr = basevertex)
                    {
                        Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32*)basevertex_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32[] basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    fixed (Int32* basevertex_ptr = basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32[] basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    fixed (Int32* basevertex_ptr = basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32[] basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    fixed (Int32* basevertex_ptr = basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32[] basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = count)
                    fixed (Int32* basevertex_ptr = basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                            indices = (T3)indices_ptr.Target;
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, ref Int32 basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    fixed (Int32* basevertex_ptr = &basevertex)
                    {
                        Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32*)basevertex_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, ref Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    fixed (Int32* basevertex_ptr = &basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, ref Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    fixed (Int32* basevertex_ptr = &basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, ref Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    fixed (Int32* basevertex_ptr = &basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, ref Int32 basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* count_ptr = &count)
                    fixed (Int32* basevertex_ptr = &basevertex)
                    {
                        GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                        try
                        {
                            Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex_ptr);
                            indices = (T3)indices_ptr.Target;
                        }
                        finally
                        {
                            indices_ptr.Free();
                        }
                    }
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        unsafe void MultiDrawElementsBaseVertex(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32* basevertex)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32*)basevertex);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32* basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32* basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32* basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex);
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbDrawElementsBaseVertex", Version = "1.2", EntryPoint = "glMultiDrawElementsBaseVertex")]
        public static
        unsafe void MultiDrawElementsBaseVertex<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32* basevertex)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                try
                {
                    Delegates.glMultiDrawElementsBaseVertex((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32*)basevertex);
                    indices = (T3)indices_ptr.Target;
                }
                finally
                {
                    indices_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMultMatrixd")]
        public static
        void MultMatrix(Double[] m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* m_ptr = m)
                    {
                        Delegates.glMultMatrixd((Double*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMultMatrixd")]
        public static
        void MultMatrix(ref Double m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* m_ptr = &m)
                    {
                        Delegates.glMultMatrixd((Double*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMultMatrixd")]
        public static
        unsafe void MultMatrix(Double* m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMultMatrixd((Double*)m);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMultMatrixf")]
        public static
        void MultMatrix(Single[] m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* m_ptr = m)
                    {
                        Delegates.glMultMatrixf((Single*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMultMatrixf")]
        public static
        void MultMatrix(ref Single m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* m_ptr = &m)
                    {
                        Delegates.glMultMatrixf((Single*)m_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with the specified matrix
        /// </summary>
        /// <param name="m">
        /// <para>
        /// Points to 16 consecutive values that are used as the elements of a 4 times 4 column-major matrix.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glMultMatrixf")]
        public static
        unsafe void MultMatrix(Single* m)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glMultMatrixf((Single*)m);
#if DEBUG
            }
#endif
        }

        /// <summary>
        /// Create or replace a display list
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies the display-list name.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNewList")]
        public static
        void NewList(Int32 list, OpenTK.Graphics.OpenGL.ListMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNewList((UInt32)list, (OpenTK.Graphics.OpenGL.ListMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Create or replace a display list
        /// </summary>
        /// <param name="list">
        /// <para>
        /// Specifies the display-list name.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNewList")]
        public static
        void NewList(UInt32 list, OpenTK.Graphics.OpenGL.ListMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNewList((UInt32)list, (OpenTK.Graphics.OpenGL.ListMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3b")]
        public static
        void Normal3(Byte nx, Byte ny, Byte nz)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3b((SByte)nx, (SByte)ny, (SByte)nz);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3b")]
        public static
        void Normal3(SByte nx, SByte ny, SByte nz)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3b((SByte)nx, (SByte)ny, (SByte)nz);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3bv")]
        public static
        void Normal3(Byte[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* v_ptr = v)
                    {
                        Delegates.glNormal3bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3bv")]
        public static
        void Normal3(ref Byte v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* v_ptr = &v)
                    {
                        Delegates.glNormal3bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3bv")]
        public static
        unsafe void Normal3(Byte* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3bv((SByte*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3bv")]
        public static
        void Normal3(SByte[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (SByte* v_ptr = v)
                    {
                        Delegates.glNormal3bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3bv")]
        public static
        void Normal3(ref SByte v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (SByte* v_ptr = &v)
                    {
                        Delegates.glNormal3bv((SByte*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3bv")]
        public static
        unsafe void Normal3(SByte* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3bv((SByte*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3d")]
        public static
        void Normal3(Double nx, Double ny, Double nz)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3d((Double)nx, (Double)ny, (Double)nz);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3dv")]
        public static
        void Normal3(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glNormal3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3dv")]
        public static
        void Normal3(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glNormal3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3dv")]
        public static
        unsafe void Normal3(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3f")]
        public static
        void Normal3(Single nx, Single ny, Single nz)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3f((Single)nx, (Single)ny, (Single)nz);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3fv")]
        public static
        void Normal3(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glNormal3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3fv")]
        public static
        void Normal3(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glNormal3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3fv")]
        public static
        unsafe void Normal3(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3i")]
        public static
        void Normal3(Int32 nx, Int32 ny, Int32 nz)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3i((Int32)nx, (Int32)ny, (Int32)nz);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3iv")]
        public static
        void Normal3(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glNormal3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3iv")]
        public static
        void Normal3(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glNormal3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3iv")]
        public static
        unsafe void Normal3(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3s")]
        public static
        void Normal3(Int16 nx, Int16 ny, Int16 nz)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3s((Int16)nx, (Int16)ny, (Int16)nz);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3sv")]
        public static
        void Normal3(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glNormal3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3sv")]
        public static
        void Normal3(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glNormal3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current normal vector
        /// </summary>
        /// <param name="nx">
        /// <para>
        /// Specify the , , and coordinates of the new current normal. The initial value of the current normal is the unit vector, (0, 0, 1).
        /// </para>
        /// <para>
        /// 
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glNormal3sv")]
        public static
        unsafe void Normal3(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormal3sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of normals
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glNormalPointer")]
        public static
        void NormalPointer(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glNormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of normals
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glNormalPointer")]
        public static
        void NormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glNormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of normals
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glNormalPointer")]
        public static
        void NormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glNormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of normals
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glNormalPointer")]
        public static
        void NormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glNormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of normals
        /// </summary>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glNormalPointer")]
        public static
        void NormalPointer<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
            where T2 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glNormalPointer((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T2)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix with an orthographic matrix
        /// </summary>
        /// <param name="left">
        /// <para>
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </para>
        /// </param>
        /// <param name="bottom">
        /// <para>
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </para>
        /// </param>
        /// <param name="nearVal">
        /// <para>
        /// Specify the distances to the nearer and farther depth clipping planes. These values are negative if the plane is to be behind the viewer.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glOrtho")]
        public static
        void Ortho(Double left, Double right, Double bottom, Double top, Double zNear, Double zFar)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glOrtho((Double)left, (Double)right, (Double)bottom, (Double)top, (Double)zNear, (Double)zFar);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Place a marker in the feedback buffer
        /// </summary>
        /// <param name="token">
        /// <para>
        /// Specifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPassThrough")]
        public static
        void PassThrough(Single token)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPassThrough((Single)token);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapfv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, Single[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* values_ptr = values)
                    {
                        Delegates.glPixelMapfv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (Single*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapfv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, ref Single values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* values_ptr = &values)
                    {
                        Delegates.glPixelMapfv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (Single*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapfv")]
        public static
        unsafe void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, Single* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelMapfv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (Single*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapuiv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, Int32[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* values_ptr = values)
                    {
                        Delegates.glPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt32*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapuiv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, ref Int32 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* values_ptr = &values)
                    {
                        Delegates.glPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt32*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapuiv")]
        public static
        unsafe void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, Int32* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt32*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapuiv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, UInt32[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* values_ptr = values)
                    {
                        Delegates.glPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt32*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapuiv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, ref UInt32 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* values_ptr = &values)
                    {
                        Delegates.glPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt32*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapuiv")]
        public static
        unsafe void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, UInt32* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelMapuiv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt32*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapusv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, Int16[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* values_ptr = values)
                    {
                        Delegates.glPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt16*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapusv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, ref Int16 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* values_ptr = &values)
                    {
                        Delegates.glPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt16*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapusv")]
        public static
        unsafe void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, Int16* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt16*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapusv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, UInt16[] values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* values_ptr = values)
                    {
                        Delegates.glPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt16*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapusv")]
        public static
        void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, ref UInt16 values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt16* values_ptr = &values)
                    {
                        Delegates.glPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt16*)values_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set up pixel transfer maps
        /// </summary>
        /// <param name="map">
        /// <para>
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I, GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B, GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or GL_PIXEL_MAP_A_TO_A.
        /// </para>
        /// </param>
        /// <param name="mapsize">
        /// <para>
        /// Specifies the size of the map being defined.
        /// </para>
        /// </param>
        /// <param name="values">
        /// <para>
        /// Specifies an array of mapsize values.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelMapusv")]
        public static
        unsafe void PixelMap(OpenTK.Graphics.OpenGL.PixelMap map, Int32 mapsize, UInt16* values)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelMapusv((OpenTK.Graphics.OpenGL.PixelMap)map, (Int32)mapsize, (UInt16*)values);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set pixel storage modes
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname is set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glPixelStoref")]
        public static
        void PixelStore(OpenTK.Graphics.OpenGL.PixelStoreParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelStoref((OpenTK.Graphics.OpenGL.PixelStoreParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set pixel storage modes
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT, GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST, GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS, GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname is set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glPixelStorei")]
        public static
        void PixelStore(OpenTK.Graphics.OpenGL.PixelStoreParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelStorei((OpenTK.Graphics.OpenGL.PixelStoreParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set pixel transfer modes
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS.
        /// </para>
        /// <para>
        /// Additionally, if the ARB_imaging extension is supported, the following symbolic names are accepted: GL_POST_COLOR_MATRIX_RED_SCALE, GL_POST_COLOR_MATRIX_GREEN_SCALE, GL_POST_COLOR_MATRIX_BLUE_SCALE, GL_POST_COLOR_MATRIX_ALPHA_SCALE, GL_POST_COLOR_MATRIX_RED_BIAS, GL_POST_COLOR_MATRIX_GREEN_BIAS, GL_POST_COLOR_MATRIX_BLUE_BIAS, GL_POST_COLOR_MATRIX_ALPHA_BIAS, GL_POST_CONVOLUTION_RED_SCALE, GL_POST_CONVOLUTION_GREEN_SCALE, GL_POST_CONVOLUTION_BLUE_SCALE, GL_POST_CONVOLUTION_ALPHA_SCALE, GL_POST_CONVOLUTION_RED_BIAS, GL_POST_CONVOLUTION_GREEN_BIAS, GL_POST_CONVOLUTION_BLUE_BIAS, and GL_POST_CONVOLUTION_ALPHA_BIAS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname is set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelTransferf")]
        public static
        void PixelTransfer(OpenTK.Graphics.OpenGL.PixelTransferParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelTransferf((OpenTK.Graphics.OpenGL.PixelTransferParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set pixel transfer modes
        /// </summary>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following: GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS, GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS, GL_DEPTH_SCALE, or GL_DEPTH_BIAS.
        /// </para>
        /// <para>
        /// Additionally, if the ARB_imaging extension is supported, the following symbolic names are accepted: GL_POST_COLOR_MATRIX_RED_SCALE, GL_POST_COLOR_MATRIX_GREEN_SCALE, GL_POST_COLOR_MATRIX_BLUE_SCALE, GL_POST_COLOR_MATRIX_ALPHA_SCALE, GL_POST_COLOR_MATRIX_RED_BIAS, GL_POST_COLOR_MATRIX_GREEN_BIAS, GL_POST_COLOR_MATRIX_BLUE_BIAS, GL_POST_COLOR_MATRIX_ALPHA_BIAS, GL_POST_CONVOLUTION_RED_SCALE, GL_POST_CONVOLUTION_GREEN_SCALE, GL_POST_CONVOLUTION_BLUE_SCALE, GL_POST_CONVOLUTION_ALPHA_SCALE, GL_POST_CONVOLUTION_RED_BIAS, GL_POST_CONVOLUTION_GREEN_BIAS, GL_POST_CONVOLUTION_BLUE_BIAS, and GL_POST_CONVOLUTION_ALPHA_BIAS.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value that pname is set to.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelTransferi")]
        public static
        void PixelTransfer(OpenTK.Graphics.OpenGL.PixelTransferParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelTransferi((OpenTK.Graphics.OpenGL.PixelTransferParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the pixel zoom factors
        /// </summary>
        /// <param name="xfactor">
        /// <para>
        /// Specify the and zoom factors for pixel write operations.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPixelZoom")]
        public static
        void PixelZoom(Single xfactor, Single yfactor)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPixelZoom((Single)xfactor, (Single)yfactor);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Specify the diameter of rasterized points
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the diameter of rasterized points. The initial value is 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glPointSize")]
        public static
        void PointSize(Single size)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPointSize((Single)size);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Select a polygon rasterization mode
        /// </summary>
        /// <param name="face">
        /// <para>
        /// Specifies the polygons that mode applies to. Must be GL_FRONT for front-facing polygons, GL_BACK for back-facing polygons, or GL_FRONT_AND_BACK for front- and back-facing polygons.
        /// </para>
        /// </param>
        /// <param name="mode">
        /// <para>
        /// Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glPolygonMode")]
        public static
        void PolygonMode(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.PolygonMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPolygonMode((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.PolygonMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the scale and units used to calculate depth values
        /// </summary>
        /// <param name="factor">
        /// <para>
        /// Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="units">
        /// <para>
        /// Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glPolygonOffset")]
        public static
        void PolygonOffset(Single factor, Single units)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPolygonOffset((Single)factor, (Single)units);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the polygon stippling pattern
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Specifies a pointer to a 32 times 32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPolygonStipple")]
        public static
        void PolygonStipple(Byte[] mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* mask_ptr = mask)
                    {
                        Delegates.glPolygonStipple((Byte*)mask_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the polygon stippling pattern
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Specifies a pointer to a 32 times 32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPolygonStipple")]
        public static
        void PolygonStipple(ref Byte mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Byte* mask_ptr = &mask)
                    {
                        Delegates.glPolygonStipple((Byte*)mask_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the polygon stippling pattern
        /// </summary>
        /// <param name="pattern">
        /// <para>
        /// Specifies a pointer to a 32 times 32 stipple pattern that will be unpacked from memory in the same way that glDrawPixels unpacks pixels.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPolygonStipple")]
        public static
        unsafe void PolygonStipple(Byte* mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPolygonStipple((Byte*)mask);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPopAttrib")]
        public static
        void PopAttrib()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPopAttrib();
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPopClientAttrib")]
        public static
        void PopClientAttrib()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPopClientAttrib();
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPopMatrix")]
        public static
        void PopMatrix()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPopMatrix();
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPopName")]
        public static
        void PopName()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPopName();
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glPrimitiveRestartIndex")]
        public static
        void PrimitiveRestartIndex(Int32 index)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPrimitiveRestartIndex((UInt32)index);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version31", Version = "3.1", EntryPoint = "glPrimitiveRestartIndex")]
        public static
        void PrimitiveRestartIndex(UInt32 index)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPrimitiveRestartIndex((UInt32)index);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture residence priority
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPrioritizeTextures")]
        public static
        void PrioritizeTextures(Int32 n, Int32[] textures, Single[] priorities)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = textures)
                    fixed (Single* priorities_ptr = priorities)
                    {
                        Delegates.glPrioritizeTextures((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture residence priority
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPrioritizeTextures")]
        public static
        void PrioritizeTextures(Int32 n, ref Int32 textures, ref Single priorities)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* textures_ptr = &textures)
                    fixed (Single* priorities_ptr = &priorities)
                    {
                        Delegates.glPrioritizeTextures((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture residence priority
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPrioritizeTextures")]
        public static
        unsafe void PrioritizeTextures(Int32 n, Int32* textures, Single* priorities)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPrioritizeTextures((Int32)n, (UInt32*)textures, (Single*)priorities);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture residence priority
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPrioritizeTextures")]
        public static
        void PrioritizeTextures(Int32 n, UInt32[] textures, Single[] priorities)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = textures)
                    fixed (Single* priorities_ptr = priorities)
                    {
                        Delegates.glPrioritizeTextures((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture residence priority
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPrioritizeTextures")]
        public static
        void PrioritizeTextures(Int32 n, ref UInt32 textures, ref Single priorities)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* textures_ptr = &textures)
                    fixed (Single* priorities_ptr = &priorities)
                    {
                        Delegates.glPrioritizeTextures((Int32)n, (UInt32*)textures_ptr, (Single*)priorities_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture residence priority
        /// </summary>
        /// <param name="n">
        /// <para>
        /// Specifies the number of textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="textures">
        /// <para>
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </para>
        /// </param>
        /// <param name="priorities">
        /// <para>
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities applies to the texture named by the corresponding element of textures.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPrioritizeTextures")]
        public static
        unsafe void PrioritizeTextures(Int32 n, UInt32* textures, Single* priorities)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPrioritizeTextures((Int32)n, (UInt32*)textures, (Single*)priorities);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version32", Version = "1.2", EntryPoint = "glProgramParameteri")]
        public static
        void ProgramParameter(Int32 program, OpenTK.Graphics.OpenGL.Version32 pname, Int32 value)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glProgramParameteri((UInt32)program, (OpenTK.Graphics.OpenGL.Version32)pname, (Int32)value);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version32", Version = "1.2", EntryPoint = "glProgramParameteri")]
        public static
        void ProgramParameter(UInt32 program, OpenTK.Graphics.OpenGL.Version32 pname, Int32 value)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glProgramParameteri((UInt32)program, (OpenTK.Graphics.OpenGL.Version32)pname, (Int32)value);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbProvokingVertex", Version = "1.2", EntryPoint = "glProvokingVertex")]
        public static
        void ProvokingVertex(OpenTK.Graphics.OpenGL.ProvokingVertexMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glProvokingVertex((OpenTK.Graphics.OpenGL.ProvokingVertexMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Push and pop the server attribute stack
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that indicates which attributes to save. Values for mask are listed below.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPushAttrib")]
        public static
        void PushAttrib(OpenTK.Graphics.OpenGL.AttribMask mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPushAttrib((OpenTK.Graphics.OpenGL.AttribMask)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Push and pop the client attribute stack
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that indicates which attributes to save. Values for mask are listed below.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glPushClientAttrib")]
        public static
        void PushClientAttrib(OpenTK.Graphics.OpenGL.ClientAttribMask mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPushClientAttrib((OpenTK.Graphics.OpenGL.ClientAttribMask)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Push and pop the current matrix stack
        /// </summary>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPushMatrix")]
        public static
        void PushMatrix()
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPushMatrix();
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Push and pop the name stack
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a name that will be pushed onto the name stack.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPushName")]
        public static
        void PushName(Int32 name)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPushName((UInt32)name);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Push and pop the name stack
        /// </summary>
        /// <param name="name">
        /// <para>
        /// Specifies a name that will be pushed onto the name stack.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glPushName")]
        public static
        void PushName(UInt32 name)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glPushName((UInt32)name);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2d")]
        public static
        void RasterPos2(Double x, Double y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2d((Double)x, (Double)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2dv")]
        public static
        void RasterPos2(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glRasterPos2dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2dv")]
        public static
        void RasterPos2(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glRasterPos2dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2dv")]
        public static
        unsafe void RasterPos2(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2f")]
        public static
        void RasterPos2(Single x, Single y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2f((Single)x, (Single)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2fv")]
        public static
        void RasterPos2(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glRasterPos2fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2fv")]
        public static
        void RasterPos2(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glRasterPos2fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2fv")]
        public static
        unsafe void RasterPos2(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2i")]
        public static
        void RasterPos2(Int32 x, Int32 y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2i((Int32)x, (Int32)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2iv")]
        public static
        void RasterPos2(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glRasterPos2iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2iv")]
        public static
        void RasterPos2(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glRasterPos2iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2iv")]
        public static
        unsafe void RasterPos2(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2s")]
        public static
        void RasterPos2(Int16 x, Int16 y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2s((Int16)x, (Int16)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2sv")]
        public static
        void RasterPos2(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glRasterPos2sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2sv")]
        public static
        void RasterPos2(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glRasterPos2sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos2sv")]
        public static
        unsafe void RasterPos2(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos2sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3d")]
        public static
        void RasterPos3(Double x, Double y, Double z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3d((Double)x, (Double)y, (Double)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3dv")]
        public static
        void RasterPos3(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glRasterPos3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3dv")]
        public static
        void RasterPos3(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glRasterPos3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3dv")]
        public static
        unsafe void RasterPos3(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3f")]
        public static
        void RasterPos3(Single x, Single y, Single z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3f((Single)x, (Single)y, (Single)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3fv")]
        public static
        void RasterPos3(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glRasterPos3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3fv")]
        public static
        void RasterPos3(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glRasterPos3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3fv")]
        public static
        unsafe void RasterPos3(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3i")]
        public static
        void RasterPos3(Int32 x, Int32 y, Int32 z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3i((Int32)x, (Int32)y, (Int32)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3iv")]
        public static
        void RasterPos3(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glRasterPos3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3iv")]
        public static
        void RasterPos3(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glRasterPos3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3iv")]
        public static
        unsafe void RasterPos3(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3s")]
        public static
        void RasterPos3(Int16 x, Int16 y, Int16 z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3s((Int16)x, (Int16)y, (Int16)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3sv")]
        public static
        void RasterPos3(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glRasterPos3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3sv")]
        public static
        void RasterPos3(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glRasterPos3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos3sv")]
        public static
        unsafe void RasterPos3(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos3sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4d")]
        public static
        void RasterPos4(Double x, Double y, Double z, Double w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4d((Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4dv")]
        public static
        void RasterPos4(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glRasterPos4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4dv")]
        public static
        void RasterPos4(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glRasterPos4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4dv")]
        public static
        unsafe void RasterPos4(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4f")]
        public static
        void RasterPos4(Single x, Single y, Single z, Single w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4f((Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4fv")]
        public static
        void RasterPos4(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glRasterPos4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4fv")]
        public static
        void RasterPos4(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glRasterPos4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4fv")]
        public static
        unsafe void RasterPos4(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4i")]
        public static
        void RasterPos4(Int32 x, Int32 y, Int32 z, Int32 w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4i((Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4iv")]
        public static
        void RasterPos4(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glRasterPos4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4iv")]
        public static
        void RasterPos4(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glRasterPos4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4iv")]
        public static
        unsafe void RasterPos4(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4s")]
        public static
        void RasterPos4(Int16 x, Int16 y, Int16 z, Int16 w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4s((Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4sv")]
        public static
        void RasterPos4(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glRasterPos4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4sv")]
        public static
        void RasterPos4(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glRasterPos4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify the raster position for pixel operations
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the , , , and object coordinates (if present) for the raster position.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRasterPos4sv")]
        public static
        unsafe void RasterPos4(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRasterPos4sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Select a color buffer source for pixels
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_AUXi, where i is between 0 and the value of GL_AUX_BUFFERS minus 1.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glReadBuffer")]
        public static
        void ReadBuffer(OpenTK.Graphics.OpenGL.ReadBufferMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glReadBuffer((OpenTK.Graphics.OpenGL.ReadBufferMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glReadPixels")]
        public static
        void ReadPixels(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glReadPixels")]
        public static
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glReadPixels")]
        public static
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glReadPixels")]
        public static
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the lower left corner of a rectangular block of pixels.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Returns the pixel data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glReadPixels")]
        public static
        void ReadPixels<T6>(Int32 x, Int32 y, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glReadPixels((Int32)x, (Int32)y, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T6)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectd")]
        public static
        void Rect(Double x1, Double y1, Double x2, Double y2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRectd((Double)x1, (Double)y1, (Double)x2, (Double)y2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectdv")]
        public static
        void Rect(Double[] v1, Double[] v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v1_ptr = v1)
                    fixed (Double* v2_ptr = v2)
                    {
                        Delegates.glRectdv((Double*)v1_ptr, (Double*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectdv")]
        public static
        void Rect(ref Double v1, ref Double v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v1_ptr = &v1)
                    fixed (Double* v2_ptr = &v2)
                    {
                        Delegates.glRectdv((Double*)v1_ptr, (Double*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectdv")]
        public static
        unsafe void Rect(Double* v1, Double* v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRectdv((Double*)v1, (Double*)v2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectf")]
        public static
        void Rect(Single x1, Single y1, Single x2, Single y2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRectf((Single)x1, (Single)y1, (Single)x2, (Single)y2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectfv")]
        public static
        void Rect(Single[] v1, Single[] v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v1_ptr = v1)
                    fixed (Single* v2_ptr = v2)
                    {
                        Delegates.glRectfv((Single*)v1_ptr, (Single*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectfv")]
        public static
        void Rect(ref Single v1, ref Single v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v1_ptr = &v1)
                    fixed (Single* v2_ptr = &v2)
                    {
                        Delegates.glRectfv((Single*)v1_ptr, (Single*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectfv")]
        public static
        unsafe void Rect(Single* v1, Single* v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRectfv((Single*)v1, (Single*)v2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRecti")]
        public static
        void Rect(Int32 x1, Int32 y1, Int32 x2, Int32 y2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRecti((Int32)x1, (Int32)y1, (Int32)x2, (Int32)y2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectiv")]
        public static
        void Rect(Int32[] v1, Int32[] v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v1_ptr = v1)
                    fixed (Int32* v2_ptr = v2)
                    {
                        Delegates.glRectiv((Int32*)v1_ptr, (Int32*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectiv")]
        public static
        void Rect(ref Int32 v1, ref Int32 v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v1_ptr = &v1)
                    fixed (Int32* v2_ptr = &v2)
                    {
                        Delegates.glRectiv((Int32*)v1_ptr, (Int32*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectiv")]
        public static
        unsafe void Rect(Int32* v1, Int32* v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRectiv((Int32*)v1, (Int32*)v2);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRects")]
        public static
        void Rects(Int16 x1, Int16 y1, Int16 x2, Int16 y2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRects((Int16)x1, (Int16)y1, (Int16)x2, (Int16)y2);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectsv")]
        public static
        void Rect(Int16[] v1, Int16[] v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v1_ptr = v1)
                    fixed (Int16* v2_ptr = v2)
                    {
                        Delegates.glRectsv((Int16*)v1_ptr, (Int16*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectsv")]
        public static
        void Rect(ref Int16 v1, ref Int16 v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v1_ptr = &v1)
                    fixed (Int16* v2_ptr = &v2)
                    {
                        Delegates.glRectsv((Int16*)v1_ptr, (Int16*)v2_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Draw a rectangle
        /// </summary>
        /// <param name="x1">
        /// <para>
        /// Specify one vertex of a rectangle.
        /// </para>
        /// </param>
        /// <param name="x2">
        /// <para>
        /// Specify the opposite vertex of the rectangle.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRectsv")]
        public static
        unsafe void Rect(Int16* v1, Int16* v2)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRectsv((Int16*)v1, (Int16*)v2);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Set rasterization mode
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies the rasterization mode. Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK. The initial value is GL_RENDER.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRenderMode")]
        public static
        Int32 RenderMode(OpenTK.Graphics.OpenGL.RenderingMode mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                return Delegates.glRenderMode((OpenTK.Graphics.OpenGL.RenderingMode)mode);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Reset histogram table entries to zero
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_HISTOGRAM.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glResetHistogram")]
        public static
        void ResetHistogram(OpenTK.Graphics.OpenGL.HistogramTarget target)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glResetHistogram((OpenTK.Graphics.OpenGL.HistogramTarget)target);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Reset minmax table entries to initial values
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_MINMAX.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glResetMinmax")]
        public static
        void ResetMinmax(OpenTK.Graphics.OpenGL.MinmaxTarget target)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glResetMinmax((OpenTK.Graphics.OpenGL.MinmaxTarget)target);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix by a rotation matrix
        /// </summary>
        /// <param name="angle">
        /// <para>
        /// Specifies the angle of rotation, in degrees.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRotated")]
        public static
        void Rotate(Double angle, Double x, Double y, Double z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRotated((Double)angle, (Double)x, (Double)y, (Double)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix by a translation matrix
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTranslated")]
        public static
        void Translate(Double x, Double y, Double z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTranslated((Double)x, (Double)y, (Double)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Multiply the current matrix by a translation matrix
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTranslatef")]
        public static
        void Translate(Single x, Single y, Single z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTranslatef((Single)x, (Single)y, (Single)z);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2d")]
        public static
        void Vertex2(Double x, Double y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2d((Double)x, (Double)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2dv")]
        public static
        void Vertex2(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glVertex2dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2dv")]
        public static
        void Vertex2(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glVertex2dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2dv")]
        public static
        unsafe void Vertex2(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2f")]
        public static
        void Vertex2(Single x, Single y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2f((Single)x, (Single)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2fv")]
        public static
        void Vertex2(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glVertex2fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2fv")]
        public static
        void Vertex2(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glVertex2fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2fv")]
        public static
        unsafe void Vertex2(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2i")]
        public static
        void Vertex2(Int32 x, Int32 y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2i((Int32)x, (Int32)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2iv")]
        public static
        void Vertex2(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glVertex2iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2iv")]
        public static
        void Vertex2(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glVertex2iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2iv")]
        public static
        unsafe void Vertex2(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2s")]
        public static
        void Vertex2(Int16 x, Int16 y)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2s((Int16)x, (Int16)y);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2sv")]
        public static
        void Vertex2(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glVertex2sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2sv")]
        public static
        void Vertex2(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glVertex2sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex2sv")]
        public static
        unsafe void Vertex2(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex2sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3d")]
        public static
        void Vertex3(Double x, Double y, Double z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3d((Double)x, (Double)y, (Double)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3dv")]
        public static
        void Vertex3(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glVertex3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3dv")]
        public static
        void Vertex3(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glVertex3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3dv")]
        public static
        unsafe void Vertex3(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3f")]
        public static
        void Vertex3(Single x, Single y, Single z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3f((Single)x, (Single)y, (Single)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3fv")]
        public static
        void Vertex3(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glVertex3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3fv")]
        public static
        void Vertex3(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glVertex3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3fv")]
        public static
        unsafe void Vertex3(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3i")]
        public static
        void Vertex3(Int32 x, Int32 y, Int32 z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3i((Int32)x, (Int32)y, (Int32)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3iv")]
        public static
        void Vertex3(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glVertex3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3iv")]
        public static
        void Vertex3(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glVertex3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3iv")]
        public static
        unsafe void Vertex3(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3s")]
        public static
        void Vertex3(Int16 x, Int16 y, Int16 z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3s((Int16)x, (Int16)y, (Int16)z);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3sv")]
        public static
        void Vertex3(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glVertex3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3sv")]
        public static
        void Vertex3(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glVertex3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex3sv")]
        public static
        unsafe void Vertex3(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex3sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4d")]
        public static
        void Vertex4(Double x, Double y, Double z, Double w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4d((Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4dv")]
        public static
        void Vertex4(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glVertex4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4dv")]
        public static
        void Vertex4(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glVertex4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4dv")]
        public static
        unsafe void Vertex4(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4f")]
        public static
        void Vertex4(Single x, Single y, Single z, Single w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4f((Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4fv")]
        public static
        void Vertex4(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glVertex4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4fv")]
        public static
        void Vertex4(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glVertex4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4fv")]
        public static
        unsafe void Vertex4(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4i")]
        public static
        void Vertex4(Int32 x, Int32 y, Int32 z, Int32 w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4i((Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4iv")]
        public static
        void Vertex4(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glVertex4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4iv")]
        public static
        void Vertex4(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glVertex4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4iv")]
        public static
        unsafe void Vertex4(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4s")]
        public static
        void Vertex4(Int16 x, Int16 y, Int16 z, Int16 w)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4s((Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4sv")]
        public static
        void Vertex4(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glVertex4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4sv")]
        public static
        void Vertex4(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glVertex4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a vertex
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glVertex4sv")]
        public static
        unsafe void Vertex4(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertex4sv((Int16*)v);
#if DEBUG
            }
#endif
        }

        /// <summary>
        /// Multiply the current matrix by a rotation matrix
        /// </summary>
        /// <param name="angle">
        /// <para>
        /// Specifies the angle of rotation, in degrees.
        /// </para>
        /// </param>
        /// <param name="x">
        /// <para>
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glRotatef")]
        public static
        void Rotate(Single angle, Single x, Single y, Single z)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glRotatef((Single)angle, (Single)x, (Single)y, (Single)z);
#if DEBUG
            }
#endif
        }
        /// <summary>
        /// Establish a buffer for selection mode values
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the size of buffer.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the selection data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glSelectBuffer")]
        public static
        void SelectBuffer(Int32 size, [OutAttribute] Int32[] buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* buffer_ptr = buffer)
                    {
                        Delegates.glSelectBuffer((Int32)size, (UInt32*)buffer_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Establish a buffer for selection mode values
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the size of buffer.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the selection data.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glSelectBuffer")]
        public static
        void SelectBuffer(Int32 size, [OutAttribute] out Int32 buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* buffer_ptr = &buffer)
                    {
                        Delegates.glSelectBuffer((Int32)size, (UInt32*)buffer_ptr);
                        buffer = *buffer_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Establish a buffer for selection mode values
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the size of buffer.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the selection data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glSelectBuffer")]
        public static
        unsafe void SelectBuffer(Int32 size, [OutAttribute] Int32* buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glSelectBuffer((Int32)size, (UInt32*)buffer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Establish a buffer for selection mode values
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the size of buffer.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the selection data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glSelectBuffer")]
        public static
        void SelectBuffer(Int32 size, [OutAttribute] UInt32[] buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* buffer_ptr = buffer)
                    {
                        Delegates.glSelectBuffer((Int32)size, (UInt32*)buffer_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Establish a buffer for selection mode values
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the size of buffer.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the selection data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glSelectBuffer")]
        public static
        void SelectBuffer(Int32 size, [OutAttribute] out UInt32 buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (UInt32* buffer_ptr = &buffer)
                    {
                        Delegates.glSelectBuffer((Int32)size, (UInt32*)buffer_ptr);
                        buffer = *buffer_ptr;
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Establish a buffer for selection mode values
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the size of buffer.
        /// </para>
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// Returns the selection data.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glSelectBuffer")]
        public static
        unsafe void SelectBuffer(Int32 size, [OutAttribute] UInt32* buffer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glSelectBuffer((Int32)size, (UInt32*)buffer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, IntPtr column)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[] column)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,] column)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] T7[,,] column)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr row, [InAttribute, OutAttribute] ref T7 column)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row, (IntPtr)column_ptr.AddrOfPinnedObject());
                    column = (T7)column_ptr.Target;
                }
                finally
                {
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] row, [InAttribute, OutAttribute] T7[,,] column)
            where T6 : struct
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] row, [InAttribute, OutAttribute] T7[,,] column)
            where T6 : struct
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] row, [InAttribute, OutAttribute] T7[,,] column)
            where T6 : struct
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define a separable two-dimensional convolution filter
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Must be GL_SEPARABLE_2D.
        /// </para>
        /// </param>
        /// <param name="internalformat">
        /// <para>
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable filter kernel.)
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </para>
        /// </param>
        /// <param name="row">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the row filter kernel.
        /// </para>
        /// </param>
        /// <param name="column">
        /// <para>
        /// Pointer to a one-dimensional array of pixel data that is processed to build the column filter kernel.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12Deprecated", Version = "1.2", EntryPoint = "glSeparableFilter2D")]
        public static
        void SeparableFilter2D<T6, T7>(OpenTK.Graphics.OpenGL.SeparableTarget target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 row, [InAttribute, OutAttribute] T7[,,] column)
            where T6 : struct
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle row_ptr = GCHandle.Alloc(row, GCHandleType.Pinned);
                GCHandle column_ptr = GCHandle.Alloc(column, GCHandleType.Pinned);
                try
                {
                    Delegates.glSeparableFilter2D((OpenTK.Graphics.OpenGL.SeparableTarget)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)row_ptr.AddrOfPinnedObject(), (IntPtr)column_ptr.AddrOfPinnedObject());
                    row = (T6)row_ptr.Target;
                }
                finally
                {
                    row_ptr.Free();
                    column_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Select flat or smooth shading
        /// </summary>
        /// <param name="mode">
        /// <para>
        /// Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and GL_SMOOTH. The initial value is GL_SMOOTH.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glShadeModel")]
        public static
        void ShadeModel(OpenTK.Graphics.OpenGL.ShadingModel mode)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glShadeModel((OpenTK.Graphics.OpenGL.ShadingModel)mode);
#if DEBUG
            }
#endif
        }




        /// <summary>
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glStencilFunc")]
        public static
        void StencilFunc(OpenTK.Graphics.OpenGL.StencilFunction func, Int32 @ref, Int32 mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glStencilFunc((OpenTK.Graphics.OpenGL.StencilFunction)func, (Int32)@ref, (UInt32)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set front and back function and reference value for stencil testing
        /// </summary>
        /// <param name="func">
        /// <para>
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </para>
        /// </param>
        /// <param name="ref">
        /// <para>
        /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="mask">
        /// <para>
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glStencilFunc")]
        public static
        void StencilFunc(OpenTK.Graphics.OpenGL.StencilFunction func, Int32 @ref, UInt32 mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glStencilFunc((OpenTK.Graphics.OpenGL.StencilFunction)func, (Int32)@ref, (UInt32)mask);
#if DEBUG
            }
#endif
        }



        /// <summary>
        /// Control the front and back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glStencilMask")]
        public static
        void StencilMask(Int32 mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glStencilMask((UInt32)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the front and back writing of individual bits in the stencil planes
        /// </summary>
        /// <param name="mask">
        /// <para>
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glStencilMask")]
        public static
        void StencilMask(UInt32 mask)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glStencilMask((UInt32)mask);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set front and back stencil test actions
        /// </summary>
        /// <param name="sfail">
        /// <para>
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dpfail">
        /// <para>
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        /// <param name="dppass">
        /// <para>
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glStencilOp")]
        public static
        void StencilOp(OpenTK.Graphics.OpenGL.StencilOp fail, OpenTK.Graphics.OpenGL.StencilOp zfail, OpenTK.Graphics.OpenGL.StencilOp zpass)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glStencilOp((OpenTK.Graphics.OpenGL.StencilOp)fail, (OpenTK.Graphics.OpenGL.StencilOp)zfail, (OpenTK.Graphics.OpenGL.StencilOp)zpass);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1d")]
        public static
        void TexCoord1(Double s)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1d((Double)s);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1dv")]
        public static
        unsafe void TexCoord1(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1f")]
        public static
        void TexCoord1(Single s)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1f((Single)s);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1fv")]
        public static
        unsafe void TexCoord1(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1i")]
        public static
        void TexCoord1(Int32 s)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1i((Int32)s);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1iv")]
        public static
        unsafe void TexCoord1(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1s")]
        public static
        void TexCoord1(Int16 s)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1s((Int16)s);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord1sv")]
        public static
        unsafe void TexCoord1(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord1sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2d")]
        public static
        void TexCoord2(Double s, Double t)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2d((Double)s, (Double)t);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2dv")]
        public static
        void TexCoord2(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glTexCoord2dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2dv")]
        public static
        void TexCoord2(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glTexCoord2dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2dv")]
        public static
        unsafe void TexCoord2(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2f")]
        public static
        void TexCoord2(Single s, Single t)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2f((Single)s, (Single)t);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2fv")]
        public static
        void TexCoord2(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glTexCoord2fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2fv")]
        public static
        void TexCoord2(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glTexCoord2fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2fv")]
        public static
        unsafe void TexCoord2(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2i")]
        public static
        void TexCoord2(Int32 s, Int32 t)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2i((Int32)s, (Int32)t);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2iv")]
        public static
        void TexCoord2(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glTexCoord2iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2iv")]
        public static
        void TexCoord2(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glTexCoord2iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2iv")]
        public static
        unsafe void TexCoord2(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2s")]
        public static
        void TexCoord2(Int16 s, Int16 t)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2s((Int16)s, (Int16)t);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2sv")]
        public static
        void TexCoord2(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glTexCoord2sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2sv")]
        public static
        void TexCoord2(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glTexCoord2sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord2sv")]
        public static
        unsafe void TexCoord2(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord2sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3d")]
        public static
        void TexCoord3(Double s, Double t, Double r)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3d((Double)s, (Double)t, (Double)r);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3dv")]
        public static
        void TexCoord3(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glTexCoord3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3dv")]
        public static
        void TexCoord3(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glTexCoord3dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3dv")]
        public static
        unsafe void TexCoord3(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3f")]
        public static
        void TexCoord3(Single s, Single t, Single r)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3f((Single)s, (Single)t, (Single)r);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3fv")]
        public static
        void TexCoord3(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glTexCoord3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3fv")]
        public static
        void TexCoord3(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glTexCoord3fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3fv")]
        public static
        unsafe void TexCoord3(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3i")]
        public static
        void TexCoord3(Int32 s, Int32 t, Int32 r)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3i((Int32)s, (Int32)t, (Int32)r);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3iv")]
        public static
        void TexCoord3(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glTexCoord3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3iv")]
        public static
        void TexCoord3(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glTexCoord3iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3iv")]
        public static
        unsafe void TexCoord3(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3s")]
        public static
        void TexCoord3(Int16 s, Int16 t, Int16 r)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3s((Int16)s, (Int16)t, (Int16)r);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3sv")]
        public static
        void TexCoord3(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glTexCoord3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3sv")]
        public static
        void TexCoord3(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glTexCoord3sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord3sv")]
        public static
        unsafe void TexCoord3(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord3sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4d")]
        public static
        void TexCoord4(Double s, Double t, Double r, Double q)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4d((Double)s, (Double)t, (Double)r, (Double)q);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4dv")]
        public static
        void TexCoord4(Double[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glTexCoord4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4dv")]
        public static
        void TexCoord4(ref Double v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* v_ptr = &v)
                    {
                        Delegates.glTexCoord4dv((Double*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4dv")]
        public static
        unsafe void TexCoord4(Double* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4dv((Double*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4f")]
        public static
        void TexCoord4(Single s, Single t, Single r, Single q)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4f((Single)s, (Single)t, (Single)r, (Single)q);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4fv")]
        public static
        void TexCoord4(Single[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glTexCoord4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4fv")]
        public static
        void TexCoord4(ref Single v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* v_ptr = &v)
                    {
                        Delegates.glTexCoord4fv((Single*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4fv")]
        public static
        unsafe void TexCoord4(Single* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4fv((Single*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4i")]
        public static
        void TexCoord4(Int32 s, Int32 t, Int32 r, Int32 q)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4i((Int32)s, (Int32)t, (Int32)r, (Int32)q);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4iv")]
        public static
        void TexCoord4(Int32[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = v)
                    {
                        Delegates.glTexCoord4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4iv")]
        public static
        void TexCoord4(ref Int32 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* v_ptr = &v)
                    {
                        Delegates.glTexCoord4iv((Int32*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4iv")]
        public static
        unsafe void TexCoord4(Int32* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4iv((Int32*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4s")]
        public static
        void TexCoord4(Int16 s, Int16 t, Int16 r, Int16 q)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4s((Int16)s, (Int16)t, (Int16)r, (Int16)q);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4sv")]
        public static
        void TexCoord4(Int16[] v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = v)
                    {
                        Delegates.glTexCoord4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4sv")]
        public static
        void TexCoord4(ref Int16 v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int16* v_ptr = &v)
                    {
                        Delegates.glTexCoord4sv((Int16*)v_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the current texture coordinates
        /// </summary>
        /// <param name="s">
        /// <para>
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the command.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexCoord4sv")]
        public static
        unsafe void TexCoord4(Int16* v)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoord4sv((Int16*)v);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of texture coordinates
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glTexCoordPointer")]
        public static
        void TexCoordPointer(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexCoordPointer((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of texture coordinates
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glTexCoordPointer")]
        public static
        void TexCoordPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexCoordPointer((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of texture coordinates
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glTexCoordPointer")]
        public static
        void TexCoordPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexCoordPointer((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of texture coordinates
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glTexCoordPointer")]
        public static
        void TexCoordPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexCoordPointer((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of texture coordinates
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glTexCoordPointer")]
        public static
        void TexCoordPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexCoordPointer((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T3)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexEnvf")]
        public static
        void TexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexEnvf((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexEnvfv")]
        public static
        void TexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glTexEnvfv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexEnvfv")]
        public static
        unsafe void TexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexEnvfv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexEnvi")]
        public static
        void TexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexEnvi((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexEnviv")]
        public static
        void TexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glTexEnviv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture environment parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or GL_POINT_SPRITE.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB, GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE, GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR, GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single boolean value for the point sprite texture coordinate replacement, a single floating-point value for the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or GL_ALPHA_SCALE.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexEnviv")]
        public static
        unsafe void TexEnv(OpenTK.Graphics.OpenGL.TextureEnvTarget target, OpenTK.Graphics.OpenGL.TextureEnvParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexEnviv((OpenTK.Graphics.OpenGL.TextureEnvTarget)target, (OpenTK.Graphics.OpenGL.TextureEnvParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGend")]
        public static
        void TexGend(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Double param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexGend((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGendv")]
        public static
        void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Double[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* @params_ptr = @params)
                    {
                        Delegates.glTexGendv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGendv")]
        public static
        void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, ref Double @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Double* @params_ptr = &@params)
                    {
                        Delegates.glTexGendv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGendv")]
        public static
        unsafe void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Double* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexGendv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Double*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGenf")]
        public static
        void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexGenf((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGenfv")]
        public static
        void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glTexGenfv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGenfv")]
        public static
        unsafe void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexGenfv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGeni")]
        public static
        void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexGeni((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGeniv")]
        public static
        void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glTexGeniv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Control the generation of texture coordinates
        /// </summary>
        /// <param name="coord">
        /// <para>
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be GL_TEXTURE_GEN_MODE.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10Deprecated", Version = "1.0", EntryPoint = "glTexGeniv")]
        public static
        unsafe void TexGen(OpenTK.Graphics.OpenGL.TextureCoordName coord, OpenTK.Graphics.OpenGL.TextureGenParameter pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexGeniv((OpenTK.Graphics.OpenGL.TextureCoordName)coord, (OpenTK.Graphics.OpenGL.TextureGenParameter)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage1D")]
        public static
        void TexImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage1D")]
        public static
        void TexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[] pixels)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage1D")]
        public static
        void TexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,] pixels)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage1D")]
        public static
        void TexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T7[,,] pixels)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage1D")]
        public static
        void TexImage1D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T7 pixels)
            where T7 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T7)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage2D")]
        public static
        void TexImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage2D")]
        public static
        void TexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage2D")]
        public static
        void TexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage2D")]
        public static
        void TexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels high.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexImage2D")]
        public static
        void TexImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T8)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glTexImage2DMultisample")]
        public static
        void TexImage2DMultisample(OpenTK.Graphics.OpenGL.TextureTargetMultisample target, Int32 samples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, bool fixedsamplelocations)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexImage2DMultisample((OpenTK.Graphics.OpenGL.TextureTargetMultisample)target, (Int32)samples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (bool)fixedsamplelocations);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexImage3D")]
        public static
        void TexImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexImage3D")]
        public static
        void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[] pixels)
            where T9 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexImage3D")]
        public static
        void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,] pixels)
            where T9 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexImage3D")]
        public static
        void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T9[,,] pixels)
            where T9 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture image
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level is the n sup th mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="internalFormat">
        /// <para>
        /// Specifies the number of color components in the texture. Must be 1, 2, 3, or 4, or one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_COMPRESSED_ALPHA, GL_COMPRESSED_LUMINANCE, GL_COMPRESSED_LUMINANCE_ALPHA, GL_COMPRESSED_INTENSITY, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SLUMINANCE, GL_SLUMINANCE8, GL_SLUMINANCE_ALPHA, GL_SLUMINANCE8_ALPHA8, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup m + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup k + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
        /// </para>
        /// </param>
        /// <param name="border">
        /// <para>
        /// Specifies the width of the border. Must be either 0 or 1.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexImage3D")]
        public static
        void TexImage3D<T9>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T9 pixels)
            where T9 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T9)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbTextureMultisample", Version = "1.2", EntryPoint = "glTexImage3DMultisample")]
        public static
        void TexImage3DMultisample(OpenTK.Graphics.OpenGL.TextureTargetMultisample target, Int32 samples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, bool fixedsamplelocations)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexImage3DMultisample((OpenTK.Graphics.OpenGL.TextureTargetMultisample)target, (Int32)samples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (bool)fixedsamplelocations);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_PRIORITY, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, or GL_GENERATE_MIPMAP.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value of pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexParameterf")]
        public static
        void TexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexParameterf((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_PRIORITY, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, or GL_GENERATE_MIPMAP.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value of pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexParameterfv")]
        public static
        void TexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glTexParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_PRIORITY, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, or GL_GENERATE_MIPMAP.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value of pname.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexParameterfv")]
        public static
        unsafe void TexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Single* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexParameterfv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Single*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_PRIORITY, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, or GL_GENERATE_MIPMAP.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value of pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexParameteri")]
        public static
        void TexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32 param)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexParameteri((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32)param);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_PRIORITY, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, or GL_GENERATE_MIPMAP.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value of pname.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexParameteriv")]
        public static
        void TexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32[] @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                unsafe
                {
                    fixed (Int32* @params_ptr = @params)
                    {
                        Delegates.glTexParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params_ptr);
                    }
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set texture parameters
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture, which must be either GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP.
        /// </para>
        /// </param>
        /// <param name="pname">
        /// <para>
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_PRIORITY, GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_DEPTH_TEXTURE_MODE, or GL_GENERATE_MIPMAP.
        /// </para>
        /// </param>
        /// <param name="param">
        /// <para>
        /// Specifies the value of pname.
        /// </para>
        /// </param>
        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glTexParameteriv")]
        public static
        unsafe void TexParameter(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.TextureParameterName pname, Int32* @params)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexParameteriv((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.TextureParameterName)pname, (Int32*)@params);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage1D")]
        public static
        void TexSubImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexSubImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage1D")]
        public static
        void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[] pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage1D")]
        public static
        void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,] pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage1D")]
        public static
        void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T6[,,] pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage1D")]
        public static
        void TexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T6 pixels)
            where T6 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage1D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T6)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage2D")]
        public static
        void TexSubImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexSubImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage2D")]
        public static
        void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[] pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage2D")]
        public static
        void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,] pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage2D")]
        public static
        void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T8[,,] pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11", Version = "1.1", EntryPoint = "glTexSubImage2D")]
        public static
        void TexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T8 pixels)
            where T8 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage2D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T8)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexSubImage3D")]
        public static
        void TexSubImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glTexSubImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexSubImage3D")]
        public static
        void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
            where T10 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexSubImage3D")]
        public static
        void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
            where T10 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexSubImage3D")]
        public static
        void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
            where T10 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Specify a three-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// <para>
        /// Specifies the target texture. Must be GL_TEXTURE_3D.
        /// </para>
        /// </param>
        /// <param name="level">
        /// <para>
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
        /// </para>
        /// </param>
        /// <param name="xoffset">
        /// <para>
        /// Specifies a texel offset in the x direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="yoffset">
        /// <para>
        /// Specifies a texel offset in the y direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="zoffset">
        /// <para>
        /// Specifies a texel offset in the z direction within the texture array.
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specifies the width of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="height">
        /// <para>
        /// Specifies the height of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="depth">
        /// <para>
        /// Specifies the depth of the texture subimage.
        /// </para>
        /// </param>
        /// <param name="format">
        /// <para>
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_COLOR_INDEX, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </para>
        /// </param>
        /// <param name="data">
        /// <para>
        /// Specifies a pointer to the image data in memory.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version12", Version = "1.2", EntryPoint = "glTexSubImage3D")]
        public static
        void TexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
            where T10 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                try
                {
                    Delegates.glTexSubImage3D((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    pixels = (T10)pixels_ptr.Target;
                }
                finally
                {
                    pixels_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of vertex data
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glVertexPointer")]
        public static
        void VertexPointer(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, IntPtr pointer)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glVertexPointer((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of vertex data
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glVertexPointer")]
        public static
        void VertexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glVertexPointer((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of vertex data
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glVertexPointer")]
        public static
        void VertexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glVertexPointer((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of vertex data
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glVertexPointer")]
        public static
        void VertexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glVertexPointer((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Define an array of vertex data
        /// </summary>
        /// <param name="size">
        /// <para>
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
        /// </para>
        /// </param>
        /// <param name="type">
        /// <para>
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </para>
        /// </param>
        /// <param name="stride">
        /// <para>
        /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
        /// </para>
        /// </param>
        /// <param name="pointer">
        /// <para>
        /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version11Deprecated", Version = "1.1", EntryPoint = "glVertexPointer")]
        public static
        void VertexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
            where T3 : struct
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                try
                {
                    Delegates.glVertexPointer((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    pointer = (T3)pointer_ptr.Target;
                }
                finally
                {
                    pointer_ptr.Free();
                }
#if DEBUG
            }
#endif
        }


        /// <summary>
        /// Set the viewport
        /// </summary>
        /// <param name="x">
        /// <para>
        /// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
        /// </para>
        /// </param>
        /// <param name="width">
        /// <para>
        /// Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.
        /// </para>
        /// </param>
        [AutoGenerated(Category = "Version10", Version = "1.0", EntryPoint = "glViewport")]
        public static
        void Viewport(Int32 x, Int32 y, Int32 width, Int32 height)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glViewport((Int32)x, (Int32)y, (Int32)width, (Int32)height);
#if DEBUG
            }
#endif
        }

        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glWaitSync")]
        public static
        void WaitSync(IntPtr sync, Int32 flags, Int64 timeout)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glWaitSync((IntPtr)sync, (UInt32)flags, (UInt64)timeout);
#if DEBUG
            }
#endif
        }

        [System.CLSCompliant(false)]
        [AutoGenerated(Category = "ArbSync", Version = "1.2", EntryPoint = "glWaitSync")]
        public static
        void WaitSync(IntPtr sync, UInt32 flags, UInt64 timeout)
        {
#if DEBUG
            using (new ErrorHelper(GraphicsContext.CurrentContext))
            {
#endif
                Delegates.glWaitSync((IntPtr)sync, (UInt32)flags, (UInt64)timeout);
#if DEBUG
            }
#endif
        }
    }
}
#endif