#region License
//
// The Open Toolkit Library License
//
// Copyright (c) 2006 - 2009 the Open Toolkit library.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights to 
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
#endregion

#if  ENABLE_DESKTOP_OPENGL
namespace OpenTK.Graphics.OpenGL
{
    using System;
    using System.Text;
    using System.Runtime.InteropServices;
#pragma warning disable 3019
#pragma warning disable 1591
#pragma warning disable 1572
#pragma warning disable 1573

    partial class GL
    {
        public static partial class GL_3dfx
        {
            [AutoGenerated(Category = "3DfxTbuffer", Version = "1.2", EntryPoint = "glTbufferMask3DFX")]
            public static
            void TbufferMask(Int32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTbufferMask3DFX((UInt32)mask);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "3DfxTbuffer", Version = "1.2", EntryPoint = "glTbufferMask3DFX")]
            public static
            void TbufferMask(UInt32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTbufferMask3DFX((UInt32)mask);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Amd
        {
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glBeginPerfMonitorAMD")]
            public static
            void BeginPerfMonitor(Int32 monitor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginPerfMonitorAMD((UInt32)monitor);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glBeginPerfMonitorAMD")]
            public static
            void BeginPerfMonitor(UInt32 monitor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginPerfMonitorAMD((UInt32)monitor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendEquationIndexedAMD")]
            public static
            void BlendEquationIndexed(Int32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendEquationIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)mode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendEquationIndexedAMD")]
            public static
            void BlendEquationIndexed(UInt32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendEquationIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendEquationSeparateIndexedAMD")]
            public static
            void BlendEquationSeparateIndexed(Int32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend modeRGB, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend modeAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendEquationSeparateIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)modeRGB, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)modeAlpha);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendEquationSeparateIndexedAMD")]
            public static
            void BlendEquationSeparateIndexed(UInt32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend modeRGB, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend modeAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendEquationSeparateIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)modeRGB, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)modeAlpha);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendFuncIndexedAMD")]
            public static
            void BlendFuncIndexed(Int32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend src, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend dst)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendFuncIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)src, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)dst);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendFuncIndexedAMD")]
            public static
            void BlendFuncIndexed(UInt32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend src, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend dst)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendFuncIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)src, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)dst);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendFuncSeparateIndexedAMD")]
            public static
            void BlendFuncSeparateIndexed(Int32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend srcRGB, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend dstRGB, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend srcAlpha, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend dstAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendFuncSeparateIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)srcRGB, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)dstRGB, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)srcAlpha, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)dstAlpha);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdDrawBuffersBlend", Version = "2.0", EntryPoint = "glBlendFuncSeparateIndexedAMD")]
            public static
            void BlendFuncSeparateIndexed(UInt32 buf, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend srcRGB, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend dstRGB, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend srcAlpha, OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend dstAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendFuncSeparateIndexedAMD((UInt32)buf, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)srcRGB, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)dstRGB, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)srcAlpha, (OpenTK.Graphics.OpenGL.AmdDrawBuffersBlend)dstAlpha);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static
            void DeletePerfMonitors(Int32 n, [OutAttribute] Int32[] monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* monitors_ptr = monitors)
                        {
                            Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static
            void DeletePerfMonitors(Int32 n, [OutAttribute] out Int32 monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* monitors_ptr = &monitors)
                        {
                            Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                            monitors = *monitors_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static
            unsafe void DeletePerfMonitors(Int32 n, [OutAttribute] Int32* monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static
            void DeletePerfMonitors(Int32 n, [OutAttribute] UInt32[] monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* monitors_ptr = monitors)
                        {
                            Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static
            void DeletePerfMonitors(Int32 n, [OutAttribute] out UInt32 monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* monitors_ptr = &monitors)
                        {
                            Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                            monitors = *monitors_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glDeletePerfMonitorsAMD")]
            public static
            unsafe void DeletePerfMonitors(Int32 n, [OutAttribute] UInt32* monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeletePerfMonitorsAMD((Int32)n, (UInt32*)monitors);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glEndPerfMonitorAMD")]
            public static
            void EndPerfMonitor(Int32 monitor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndPerfMonitorAMD((UInt32)monitor);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glEndPerfMonitorAMD")]
            public static
            void EndPerfMonitor(UInt32 monitor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndPerfMonitorAMD((UInt32)monitor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGenPerfMonitorsAMD")]
            public static
            void GenPerfMonitors(Int32 n, [OutAttribute] Int32[] monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* monitors_ptr = monitors)
                        {
                            Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGenPerfMonitorsAMD")]
            public static
            void GenPerfMonitors(Int32 n, [OutAttribute] out Int32 monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* monitors_ptr = &monitors)
                        {
                            Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                            monitors = *monitors_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGenPerfMonitorsAMD")]
            public static
            unsafe void GenPerfMonitors(Int32 n, [OutAttribute] Int32* monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGenPerfMonitorsAMD")]
            public static
            void GenPerfMonitors(Int32 n, [OutAttribute] UInt32[] monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* monitors_ptr = monitors)
                        {
                            Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGenPerfMonitorsAMD")]
            public static
            void GenPerfMonitors(Int32 n, [OutAttribute] out UInt32 monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* monitors_ptr = &monitors)
                        {
                            Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors_ptr);
                            monitors = *monitors_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGenPerfMonitorsAMD")]
            public static
            unsafe void GenPerfMonitors(Int32 n, [OutAttribute] UInt32* monitors)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenPerfMonitorsAMD((Int32)n, (UInt32*)monitors);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static
            unsafe void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] Int32[] data, [OutAttribute] Int32* bytesWritten)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Int32* data_ptr = data)
                    {
                        Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten);
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static
            void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] out Int32 data, [OutAttribute] out Int32 bytesWritten)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* data_ptr = &data)
                        fixed (Int32* bytesWritten_ptr = &bytesWritten)
                        {
                            Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten_ptr);
                            data = *data_ptr;
                            bytesWritten = *bytesWritten_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static
            unsafe void GetPerfMonitorCounterData(Int32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] Int32* data, [OutAttribute] Int32* bytesWritten)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data, (Int32*)bytesWritten);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static
            unsafe void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] UInt32[] data, [OutAttribute] Int32* bytesWritten)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (UInt32* data_ptr = data)
                    {
                        Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static
            void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] out UInt32 data, [OutAttribute] out Int32 bytesWritten)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* data_ptr = &data)
                        fixed (Int32* bytesWritten_ptr = &bytesWritten)
                        {
                            Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data_ptr, (Int32*)bytesWritten_ptr);
                            data = *data_ptr;
                            bytesWritten = *bytesWritten_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterDataAMD")]
            public static
            unsafe void GetPerfMonitorCounterData(UInt32 monitor, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, Int32 dataSize, [OutAttribute] UInt32* data, [OutAttribute] Int32* bytesWritten)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCounterDataAMD((UInt32)monitor, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (Int32)dataSize, (UInt32*)data, (Int32*)bytesWritten);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo(Int32 group, Int32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(Int32 group, Int32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo(UInt32 group, UInt32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterInfoAMD")]
            public static
            void GetPerfMonitorCounterInfo<T3>(UInt32 group, UInt32 counter, OpenTK.Graphics.OpenGL.AmdPerformanceMonitor pname, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetPerfMonitorCounterInfoAMD((UInt32)group, (UInt32)counter, (OpenTK.Graphics.OpenGL.AmdPerformanceMonitor)pname, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static
            void GetPerfMonitorCounters(Int32 group, [OutAttribute] out Int32 numCounters, [OutAttribute] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute] out Int32 counters)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* numCounters_ptr = &numCounters)
                        fixed (Int32* maxActiveCounters_ptr = &maxActiveCounters)
                        fixed (Int32* counters_ptr = &counters)
                        {
                            Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters_ptr, (Int32*)maxActiveCounters_ptr, (Int32)counterSize, (UInt32*)counters_ptr);
                            numCounters = *numCounters_ptr;
                            maxActiveCounters = *maxActiveCounters_ptr;
                            counters = *counters_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static
            unsafe void GetPerfMonitorCounters(Int32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] Int32[] counters)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Int32* counters_ptr = counters)
                    {
                        Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static
            unsafe void GetPerfMonitorCounters(Int32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] Int32* counters)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static
            void GetPerfMonitorCounters(UInt32 group, [OutAttribute] out Int32 numCounters, [OutAttribute] out Int32 maxActiveCounters, Int32 counterSize, [OutAttribute] out UInt32 counters)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* numCounters_ptr = &numCounters)
                        fixed (Int32* maxActiveCounters_ptr = &maxActiveCounters)
                        fixed (UInt32* counters_ptr = &counters)
                        {
                            Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters_ptr, (Int32*)maxActiveCounters_ptr, (Int32)counterSize, (UInt32*)counters_ptr);
                            numCounters = *numCounters_ptr;
                            maxActiveCounters = *maxActiveCounters_ptr;
                            counters = *counters_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static
            unsafe void GetPerfMonitorCounters(UInt32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] UInt32[] counters)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (UInt32* counters_ptr = counters)
                    {
                        Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCountersAMD")]
            public static
            unsafe void GetPerfMonitorCounters(UInt32 group, [OutAttribute] Int32* numCounters, [OutAttribute] Int32* maxActiveCounters, Int32 counterSize, [OutAttribute] UInt32* counters)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCountersAMD((UInt32)group, (Int32*)numCounters, (Int32*)maxActiveCounters, (Int32)counterSize, (UInt32*)counters);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static
            void GetPerfMonitorCounterString(Int32 group, Int32 counter, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder counterString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)counterString);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static
            unsafe void GetPerfMonitorCounterString(Int32 group, Int32 counter, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder counterString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length, (StringBuilder)counterString);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static
            void GetPerfMonitorCounterString(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder counterString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)counterString);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorCounterStringAMD")]
            public static
            unsafe void GetPerfMonitorCounterString(UInt32 group, UInt32 counter, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder counterString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorCounterStringAMD((UInt32)group, (UInt32)counter, (Int32)bufSize, (Int32*)length, (StringBuilder)counterString);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static
            void GetPerfMonitorGroup([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] out Int32 groups)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* numGroups_ptr = &numGroups)
                        fixed (Int32* groups_ptr = &groups)
                        {
                            Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
                            numGroups = *numGroups_ptr;
                            groups = *groups_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static
            void GetPerfMonitorGroup([OutAttribute] out Int32 numGroups, Int32 groupsSize, [OutAttribute] out UInt32 groups)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* numGroups_ptr = &numGroups)
                        fixed (UInt32* groups_ptr = &groups)
                        {
                            Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups_ptr, (Int32)groupsSize, (UInt32*)groups_ptr);
                            numGroups = *numGroups_ptr;
                            groups = *groups_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static
            unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] Int32[] groups)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Int32* groups_ptr = groups)
                    {
                        Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static
            unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] Int32* groups)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static
            unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] UInt32[] groups)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (UInt32* groups_ptr = groups)
                    {
                        Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupsAMD")]
            public static
            unsafe void GetPerfMonitorGroup([OutAttribute] Int32* numGroups, Int32 groupsSize, [OutAttribute] UInt32* groups)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorGroupsAMD((Int32*)numGroups, (Int32)groupsSize, (UInt32*)groups);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static
            void GetPerfMonitorGroupString(Int32 group, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder groupString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)groupString);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static
            unsafe void GetPerfMonitorGroupString(Int32 group, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder groupString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length, (StringBuilder)groupString);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static
            void GetPerfMonitorGroupString(UInt32 group, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder groupString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length_ptr, (StringBuilder)groupString);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glGetPerfMonitorGroupStringAMD")]
            public static
            unsafe void GetPerfMonitorGroupString(UInt32 group, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] StringBuilder groupString)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPerfMonitorGroupStringAMD((UInt32)group, (Int32)bufSize, (Int32*)length, (StringBuilder)groupString);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static
            void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute] Int32[] counterList)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* counterList_ptr = counterList)
                        {
                            Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static
            void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute] out Int32 counterList)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* counterList_ptr = &counterList)
                        {
                            Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                            counterList = *counterList_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static
            unsafe void SelectPerfMonitorCounters(Int32 monitor, bool enable, Int32 group, Int32 numCounters, [OutAttribute] Int32* counterList)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static
            void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute] UInt32[] counterList)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* counterList_ptr = counterList)
                        {
                            Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static
            void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute] out UInt32 counterList)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* counterList_ptr = &counterList)
                        {
                            Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList_ptr);
                            counterList = *counterList_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AmdPerformanceMonitor", Version = "1.2", EntryPoint = "glSelectPerfMonitorCountersAMD")]
            public static
            unsafe void SelectPerfMonitorCounters(UInt32 monitor, bool enable, UInt32 group, Int32 numCounters, [OutAttribute] UInt32* counterList)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSelectPerfMonitorCountersAMD((UInt32)monitor, (bool)enable, (UInt32)group, (Int32)numCounters, (UInt32*)counterList);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdVertexShaderTesselator", Version = "2.0", EntryPoint = "glTessellationFactorAMD")]
            public static
            void TessellationFactor(Single factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTessellationFactorAMD((Single)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AmdVertexShaderTesselator", Version = "2.0", EntryPoint = "glTessellationModeAMD")]
            public static
            void TessellationMode(OpenTK.Graphics.OpenGL.AmdVertexShaderTesselator mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTessellationModeAMD((OpenTK.Graphics.OpenGL.AmdVertexShaderTesselator)mode);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Apple
        {
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glBindVertexArrayAPPLE")]
            public static
            void BindVertexArray(Int32 array)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindVertexArrayAPPLE((UInt32)array);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glBindVertexArrayAPPLE")]
            public static
            void BindVertexArray(UInt32 array)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindVertexArrayAPPLE((UInt32)array);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFlushBufferRange", Version = "1.5", EntryPoint = "glBufferParameteriAPPLE")]
            public static
            void BufferParameter(OpenTK.Graphics.OpenGL.BufferTarget target, OpenTK.Graphics.OpenGL.BufferParameterApple pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBufferParameteriAPPLE((OpenTK.Graphics.OpenGL.BufferTarget)target, (OpenTK.Graphics.OpenGL.BufferParameterApple)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glDeleteFencesAPPLE")]
            public static
            void DeleteFences(Int32 n, Int32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = fences)
                        {
                            Delegates.glDeleteFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glDeleteFencesAPPLE")]
            public static
            void DeleteFences(Int32 n, ref Int32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = &fences)
                        {
                            Delegates.glDeleteFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glDeleteFencesAPPLE")]
            public static
            unsafe void DeleteFences(Int32 n, Int32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFencesAPPLE((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glDeleteFencesAPPLE")]
            public static
            void DeleteFences(Int32 n, UInt32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = fences)
                        {
                            Delegates.glDeleteFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glDeleteFencesAPPLE")]
            public static
            void DeleteFences(Int32 n, ref UInt32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = &fences)
                        {
                            Delegates.glDeleteFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glDeleteFencesAPPLE")]
            public static
            unsafe void DeleteFences(Int32 n, UInt32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFencesAPPLE((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glDeleteVertexArraysAPPLE")]
            public static
            void DeleteVertexArrays(Int32 n, Int32[] arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* arrays_ptr = arrays)
                        {
                            Delegates.glDeleteVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glDeleteVertexArraysAPPLE")]
            public static
            void DeleteVertexArrays(Int32 n, ref Int32 arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* arrays_ptr = &arrays)
                        {
                            Delegates.glDeleteVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glDeleteVertexArraysAPPLE")]
            public static
            unsafe void DeleteVertexArrays(Int32 n, Int32* arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteVertexArraysAPPLE((Int32)n, (UInt32*)arrays);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glDeleteVertexArraysAPPLE")]
            public static
            void DeleteVertexArrays(Int32 n, UInt32[] arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* arrays_ptr = arrays)
                        {
                            Delegates.glDeleteVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glDeleteVertexArraysAPPLE")]
            public static
            void DeleteVertexArrays(Int32 n, ref UInt32 arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* arrays_ptr = &arrays)
                        {
                            Delegates.glDeleteVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glDeleteVertexArraysAPPLE")]
            public static
            unsafe void DeleteVertexArrays(Int32 n, UInt32* arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteVertexArraysAPPLE((Int32)n, (UInt32*)arrays);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glDisableVertexAttribAPPLE")]
            public static
            void DisableVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableVertexAttribAPPLE((UInt32)index, (OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators)pname);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glDisableVertexAttribAPPLE")]
            public static
            void DisableVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableVertexAttribAPPLE((UInt32)index, (OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators)pname);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glDrawElementArrayAPPLE")]
            public static
            void DrawElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 first, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)first, (Int32)count);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glDrawRangeElementArrayAPPLE")]
            public static
            void DrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 first, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)first, (Int32)count);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glDrawRangeElementArrayAPPLE")]
            public static
            void DrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 first, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)first, (Int32)count);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glElementPointerAPPLE")]
            public static
            void ElementPointer(OpenTK.Graphics.OpenGL.AppleElementArray type, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glElementPointerAPPLE((OpenTK.Graphics.OpenGL.AppleElementArray)type, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glElementPointerAPPLE")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AppleElementArray type, [InAttribute, OutAttribute] T1[] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerAPPLE((OpenTK.Graphics.OpenGL.AppleElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glElementPointerAPPLE")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AppleElementArray type, [InAttribute, OutAttribute] T1[,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerAPPLE((OpenTK.Graphics.OpenGL.AppleElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glElementPointerAPPLE")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AppleElementArray type, [InAttribute, OutAttribute] T1[,,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerAPPLE((OpenTK.Graphics.OpenGL.AppleElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glElementPointerAPPLE")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AppleElementArray type, [InAttribute, OutAttribute] ref T1 pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerAPPLE((OpenTK.Graphics.OpenGL.AppleElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T1)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glEnableVertexAttribAPPLE")]
            public static
            void EnableVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableVertexAttribAPPLE((UInt32)index, (OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators)pname);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glEnableVertexAttribAPPLE")]
            public static
            void EnableVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableVertexAttribAPPLE((UInt32)index, (OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators)pname);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glFinishFenceAPPLE")]
            public static
            void FinishFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinishFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glFinishFenceAPPLE")]
            public static
            void FinishFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinishFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glFinishObjectAPPLE")]
            public static
            void FinishObject(OpenTK.Graphics.OpenGL.AppleFence @object, Int32 name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinishObjectAPPLE((OpenTK.Graphics.OpenGL.AppleFence)@object, (Int32)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFlushBufferRange", Version = "1.5", EntryPoint = "glFlushMappedBufferRangeAPPLE")]
            public static
            void FlushMappedBufferRange(OpenTK.Graphics.OpenGL.BufferTarget target, IntPtr offset, IntPtr size)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFlushMappedBufferRangeAPPLE((OpenTK.Graphics.OpenGL.BufferTarget)target, (IntPtr)offset, (IntPtr)size);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glFlushVertexArrayRangeAPPLE")]
            public static
            void FlushVertexArrayRange(Int32 length, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFlushVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glFlushVertexArrayRangeAPPLE")]
            public static
            void FlushVertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFlushVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glFlushVertexArrayRangeAPPLE")]
            public static
            void FlushVertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFlushVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glFlushVertexArrayRangeAPPLE")]
            public static
            void FlushVertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[,,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFlushVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glFlushVertexArrayRangeAPPLE")]
            public static
            void FlushVertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] ref T1 pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFlushVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T1)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glGenFencesAPPLE")]
            public static
            void GenFences(Int32 n, [OutAttribute] Int32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = fences)
                        {
                            Delegates.glGenFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glGenFencesAPPLE")]
            public static
            void GenFences(Int32 n, [OutAttribute] out Int32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = &fences)
                        {
                            Delegates.glGenFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                            fences = *fences_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glGenFencesAPPLE")]
            public static
            unsafe void GenFences(Int32 n, [OutAttribute] Int32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenFencesAPPLE((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glGenFencesAPPLE")]
            public static
            void GenFences(Int32 n, [OutAttribute] UInt32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = fences)
                        {
                            Delegates.glGenFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glGenFencesAPPLE")]
            public static
            void GenFences(Int32 n, [OutAttribute] out UInt32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = &fences)
                        {
                            Delegates.glGenFencesAPPLE((Int32)n, (UInt32*)fences_ptr);
                            fences = *fences_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glGenFencesAPPLE")]
            public static
            unsafe void GenFences(Int32 n, [OutAttribute] UInt32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenFencesAPPLE((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glGenVertexArraysAPPLE")]
            public static
            void GenVertexArrays(Int32 n, [OutAttribute] Int32[] arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* arrays_ptr = arrays)
                        {
                            Delegates.glGenVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glGenVertexArraysAPPLE")]
            public static
            void GenVertexArrays(Int32 n, [OutAttribute] out Int32 arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* arrays_ptr = &arrays)
                        {
                            Delegates.glGenVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                            arrays = *arrays_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glGenVertexArraysAPPLE")]
            public static
            unsafe void GenVertexArrays(Int32 n, [OutAttribute] Int32* arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenVertexArraysAPPLE((Int32)n, (UInt32*)arrays);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glGenVertexArraysAPPLE")]
            public static
            void GenVertexArrays(Int32 n, [OutAttribute] UInt32[] arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* arrays_ptr = arrays)
                        {
                            Delegates.glGenVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glGenVertexArraysAPPLE")]
            public static
            void GenVertexArrays(Int32 n, [OutAttribute] out UInt32 arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* arrays_ptr = &arrays)
                        {
                            Delegates.glGenVertexArraysAPPLE((Int32)n, (UInt32*)arrays_ptr);
                            arrays = *arrays_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glGenVertexArraysAPPLE")]
            public static
            unsafe void GenVertexArrays(Int32 n, [OutAttribute] UInt32* arrays)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenVertexArraysAPPLE((Int32)n, (UInt32*)arrays);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glGetObjectParameterivAPPLE")]
            public static
            void GetObjectParameter(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, Int32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetObjectParameterivAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glGetObjectParameterivAPPLE")]
            public static
            void GetObjectParameter(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, Int32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectParameterivAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glGetObjectParameterivAPPLE")]
            public static
            unsafe void GetObjectParameter(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, Int32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectParameterivAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glGetObjectParameterivAPPLE")]
            public static
            void GetObjectParameter(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, UInt32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetObjectParameterivAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glGetObjectParameterivAPPLE")]
            public static
            void GetObjectParameter(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, UInt32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectParameterivAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glGetObjectParameterivAPPLE")]
            public static
            unsafe void GetObjectParameter(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, UInt32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectParameterivAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glGetTexParameterPointervAPPLE")]
            public static
            void GetTexParameterPointer(OpenTK.Graphics.OpenGL.AppleTextureRange target, OpenTK.Graphics.OpenGL.AppleTextureRange pname, [OutAttribute] IntPtr @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTexParameterPointervAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (OpenTK.Graphics.OpenGL.AppleTextureRange)pname, (IntPtr)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glGetTexParameterPointervAPPLE")]
            public static
            void GetTexParameterPointer<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, OpenTK.Graphics.OpenGL.AppleTextureRange pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTexParameterPointervAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (OpenTK.Graphics.OpenGL.AppleTextureRange)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glGetTexParameterPointervAPPLE")]
            public static
            void GetTexParameterPointer<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, OpenTK.Graphics.OpenGL.AppleTextureRange pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTexParameterPointervAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (OpenTK.Graphics.OpenGL.AppleTextureRange)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glGetTexParameterPointervAPPLE")]
            public static
            void GetTexParameterPointer<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, OpenTK.Graphics.OpenGL.AppleTextureRange pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTexParameterPointervAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (OpenTK.Graphics.OpenGL.AppleTextureRange)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glGetTexParameterPointervAPPLE")]
            public static
            void GetTexParameterPointer<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, OpenTK.Graphics.OpenGL.AppleTextureRange pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetTexParameterPointervAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (OpenTK.Graphics.OpenGL.AppleTextureRange)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                        @params = (T2)@params_ptr.Target;
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glIsFenceAPPLE")]
            public static
            bool IsFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glIsFenceAPPLE")]
            public static
            bool IsFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glIsVertexArrayAPPLE")]
            public static
            bool IsVertexArray(Int32 array)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsVertexArrayAPPLE((UInt32)array);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexArrayObject", Version = "1.2", EntryPoint = "glIsVertexArrayAPPLE")]
            public static
            bool IsVertexArray(UInt32 array)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsVertexArrayAPPLE((UInt32)array);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glIsVertexAttribEnabledAPPLE")]
            public static
            bool IsVertexAttribEnabled(Int32 index, OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsVertexAttribEnabledAPPLE((UInt32)index, (OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators)pname);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glIsVertexAttribEnabledAPPLE")]
            public static
            bool IsVertexAttribEnabled(UInt32 index, OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsVertexAttribEnabledAPPLE((UInt32)index, (OpenTK.Graphics.OpenGL.AppleVertexProgramEvaluators)pname);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1dAPPLE")]
            public static
            void MapVertexAttrib1(Int32 index, Int32 size, Double u1, Double u2, Int32 stride, Int32 order, Double[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib1dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1dAPPLE")]
            public static
            void MapVertexAttrib1(Int32 index, Int32 size, Double u1, Double u2, Int32 stride, Int32 order, ref Double points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib1dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1dAPPLE")]
            public static
            unsafe void MapVertexAttrib1(Int32 index, Int32 size, Double u1, Double u2, Int32 stride, Int32 order, Double* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib1dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1dAPPLE")]
            public static
            void MapVertexAttrib1(UInt32 index, UInt32 size, Double u1, Double u2, Int32 stride, Int32 order, Double[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib1dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1dAPPLE")]
            public static
            void MapVertexAttrib1(UInt32 index, UInt32 size, Double u1, Double u2, Int32 stride, Int32 order, ref Double points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib1dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1dAPPLE")]
            public static
            unsafe void MapVertexAttrib1(UInt32 index, UInt32 size, Double u1, Double u2, Int32 stride, Int32 order, Double* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib1dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)stride, (Int32)order, (Double*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1fAPPLE")]
            public static
            void MapVertexAttrib1(Int32 index, Int32 size, Single u1, Single u2, Int32 stride, Int32 order, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib1fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1fAPPLE")]
            public static
            void MapVertexAttrib1(Int32 index, Int32 size, Single u1, Single u2, Int32 stride, Int32 order, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib1fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1fAPPLE")]
            public static
            unsafe void MapVertexAttrib1(Int32 index, Int32 size, Single u1, Single u2, Int32 stride, Int32 order, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib1fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1fAPPLE")]
            public static
            void MapVertexAttrib1(UInt32 index, UInt32 size, Single u1, Single u2, Int32 stride, Int32 order, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib1fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1fAPPLE")]
            public static
            void MapVertexAttrib1(UInt32 index, UInt32 size, Single u1, Single u2, Int32 stride, Int32 order, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib1fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib1fAPPLE")]
            public static
            unsafe void MapVertexAttrib1(UInt32 index, UInt32 size, Single u1, Single u2, Int32 stride, Int32 order, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib1fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)stride, (Int32)order, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2dAPPLE")]
            public static
            void MapVertexAttrib2(Int32 index, Int32 size, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib2dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2dAPPLE")]
            public static
            void MapVertexAttrib2(Int32 index, Int32 size, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, ref Double points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib2dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2dAPPLE")]
            public static
            unsafe void MapVertexAttrib2(Int32 index, Int32 size, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib2dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2dAPPLE")]
            public static
            void MapVertexAttrib2(UInt32 index, UInt32 size, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib2dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2dAPPLE")]
            public static
            void MapVertexAttrib2(UInt32 index, UInt32 size, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, ref Double points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib2dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2dAPPLE")]
            public static
            unsafe void MapVertexAttrib2(UInt32 index, UInt32 size, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib2dAPPLE((UInt32)index, (UInt32)size, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2fAPPLE")]
            public static
            void MapVertexAttrib2(Int32 index, Int32 size, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib2fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2fAPPLE")]
            public static
            void MapVertexAttrib2(Int32 index, Int32 size, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib2fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2fAPPLE")]
            public static
            unsafe void MapVertexAttrib2(Int32 index, Int32 size, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib2fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2fAPPLE")]
            public static
            void MapVertexAttrib2(UInt32 index, UInt32 size, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glMapVertexAttrib2fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2fAPPLE")]
            public static
            void MapVertexAttrib2(UInt32 index, UInt32 size, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glMapVertexAttrib2fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleVertexProgramEvaluators", Version = "1.5", EntryPoint = "glMapVertexAttrib2fAPPLE")]
            public static
            unsafe void MapVertexAttrib2(UInt32 index, UInt32 size, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapVertexAttrib2fAPPLE((UInt32)index, (UInt32)size, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawElementArrayAPPLE")]
            public static
            void MultiDrawElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32[] first, Int32[] count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = first)
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiDrawElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawElementArrayAPPLE")]
            public static
            void MultiDrawElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 first, ref Int32 count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = &first)
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiDrawElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawElementArrayAPPLE")]
            public static
            unsafe void MultiDrawElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32* first, Int32* count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiDrawElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32*)first, (Int32*)count, (Int32)primcount);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawRangeElementArrayAPPLE")]
            public static
            void MultiDrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32[] first, Int32[] count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = first)
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawRangeElementArrayAPPLE")]
            public static
            void MultiDrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, ref Int32 first, ref Int32 count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = &first)
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawRangeElementArrayAPPLE")]
            public static
            unsafe void MultiDrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32* first, Int32* count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32*)first, (Int32*)count, (Int32)primcount);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawRangeElementArrayAPPLE")]
            public static
            void MultiDrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32[] first, Int32[] count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = first)
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawRangeElementArrayAPPLE")]
            public static
            void MultiDrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, ref Int32 first, ref Int32 count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* first_ptr = &first)
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleElementArray", Version = "1.2", EntryPoint = "glMultiDrawRangeElementArrayAPPLE")]
            public static
            unsafe void MultiDrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32* first, Int32* count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiDrawRangeElementArrayAPPLE((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32*)first, (Int32*)count, (Int32)primcount);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glObjectPurgeableAPPLE")]
            public static
            System.IntPtr ObjectPurgeable(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, Int32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable option)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glObjectPurgeableAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)option);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glObjectPurgeableAPPLE")]
            public static
            System.IntPtr ObjectPurgeable(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, UInt32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable option)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glObjectPurgeableAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)option);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glObjectUnpurgeableAPPLE")]
            public static
            System.IntPtr ObjectUnpurgeable(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, Int32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable option)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glObjectUnpurgeableAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)option);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleObjectPurgeable", Version = "1.5", EntryPoint = "glObjectUnpurgeableAPPLE")]
            public static
            System.IntPtr ObjectUnpurgeable(OpenTK.Graphics.OpenGL.AppleObjectPurgeable objectType, UInt32 name, OpenTK.Graphics.OpenGL.AppleObjectPurgeable option)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glObjectUnpurgeableAPPLE((OpenTK.Graphics.OpenGL.AppleObjectPurgeable)objectType, (UInt32)name, (OpenTK.Graphics.OpenGL.AppleObjectPurgeable)option);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glSetFenceAPPLE")]
            public static
            void SetFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glSetFenceAPPLE")]
            public static
            void SetFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glTestFenceAPPLE")]
            public static
            bool TestFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glTestFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glTestFenceAPPLE")]
            public static
            bool TestFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glTestFenceAPPLE((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glTestObjectAPPLE")]
            public static
            bool TestObject(OpenTK.Graphics.OpenGL.AppleFence @object, Int32 name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glTestObjectAPPLE((OpenTK.Graphics.OpenGL.AppleFence)@object, (UInt32)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AppleFence", Version = "1.2", EntryPoint = "glTestObjectAPPLE")]
            public static
            bool TestObject(OpenTK.Graphics.OpenGL.AppleFence @object, UInt32 name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glTestObjectAPPLE((OpenTK.Graphics.OpenGL.AppleFence)@object, (UInt32)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glTextureRangeAPPLE")]
            public static
            void TextureRange(OpenTK.Graphics.OpenGL.AppleTextureRange target, Int32 length, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureRangeAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (Int32)length, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glTextureRangeAPPLE")]
            public static
            void TextureRange<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, Int32 length, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureRangeAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glTextureRangeAPPLE")]
            public static
            void TextureRange<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, Int32 length, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureRangeAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glTextureRangeAPPLE")]
            public static
            void TextureRange<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, Int32 length, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureRangeAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleTextureRange", Version = "1.2", EntryPoint = "glTextureRangeAPPLE")]
            public static
            void TextureRange<T2>(OpenTK.Graphics.OpenGL.AppleTextureRange target, Int32 length, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTextureRangeAPPLE((OpenTK.Graphics.OpenGL.AppleTextureRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glVertexArrayParameteriAPPLE")]
            public static
            void VertexArrayParameter(OpenTK.Graphics.OpenGL.AppleVertexArrayRange pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexArrayParameteriAPPLE((OpenTK.Graphics.OpenGL.AppleVertexArrayRange)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glVertexArrayRangeAPPLE")]
            public static
            void VertexArrayRange(Int32 length, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glVertexArrayRangeAPPLE")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glVertexArrayRangeAPPLE")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glVertexArrayRangeAPPLE")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[,,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AppleVertexArrayRange", Version = "1.2", EntryPoint = "glVertexArrayRangeAPPLE")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] ref T1 pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeAPPLE((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T1)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }
        }

        public static partial class Arb
        {
            /// <summary>
            /// Select active texture unit
            /// </summary>
            /// <param name="texture">
            /// <para>
            /// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTURE, where i ranges from 0 to the larger of (GL_MAX_TEXTURE_COORDS - 1) and (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). The initial value is GL_TEXTURE0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glActiveTextureARB")]
            public static
            void ActiveTexture(OpenTK.Graphics.OpenGL.TextureUnit texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glActiveTextureARB((OpenTK.Graphics.OpenGL.TextureUnit)texture);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glAttachObjectARB")]
            public static
            void AttachObject(Int32 containerObj, Int32 obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAttachObjectARB((UInt32)containerObj, (UInt32)obj);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glAttachObjectARB")]
            public static
            void AttachObject(UInt32 containerObj, UInt32 obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAttachObjectARB((UInt32)containerObj, (UInt32)obj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be GL_SAMPLES_PASSED.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glBeginQueryARB")]
            public static
            void BeginQuery(OpenTK.Graphics.OpenGL.ArbOcclusionQuery target, Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginQueryARB((OpenTK.Graphics.OpenGL.ArbOcclusionQuery)target, (UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delimit the boundaries of a query object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target type of query object established between glBeginQuery and the subsequent glEndQuery. The symbolic constant must be GL_SAMPLES_PASSED.
            /// </para>
            /// </param>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glBeginQueryARB")]
            public static
            void BeginQuery(OpenTK.Graphics.OpenGL.ArbOcclusionQuery target, UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginQueryARB((OpenTK.Graphics.OpenGL.ArbOcclusionQuery)target, (UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Associates a generic vertex attribute index with a named attribute variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program object in which the association is to be made.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be bound.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glBindAttribLocationARB")]
            public static
            void BindAttribLocation(Int32 programObj, Int32 index, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindAttribLocationARB((UInt32)programObj, (UInt32)index, (String)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Associates a generic vertex attribute index with a named attribute variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program object in which the association is to be made.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be bound.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glBindAttribLocationARB")]
            public static
            void BindAttribLocation(UInt32 programObj, UInt32 index, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindAttribLocationARB((UInt32)programObj, (UInt32)index, (String)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Bind a named buffer object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="buffer">
            /// <para>
            /// Specifies the name of a buffer object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBindBufferARB")]
            public static
            void BindBuffer(OpenTK.Graphics.OpenGL.BufferTargetArb target, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (UInt32)buffer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Bind a named buffer object
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target to which the buffer object is bound. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="buffer">
            /// <para>
            /// Specifies the name of a buffer object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBindBufferARB")]
            public static
            void BindBuffer(OpenTK.Graphics.OpenGL.BufferTargetArb target, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glBindProgramARB")]
            public static
            void BindProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindProgramARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)program);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glBindProgramARB")]
            public static
            void BindProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindProgramARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)program);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Creates and initializes a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
            /// </para>
            /// </param>
            /// <param name="usage">
            /// <para>
            /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferDataARB")]
            public static
            void BufferData(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr size, IntPtr data, OpenTK.Graphics.OpenGL.BufferUsageArb usage)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBufferDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)size, (IntPtr)data, (OpenTK.Graphics.OpenGL.BufferUsageArb)usage);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Creates and initializes a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
            /// </para>
            /// </param>
            /// <param name="usage">
            /// <para>
            /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferDataARB")]
            public static
            void BufferData<T2>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute] T2[] data, OpenTK.Graphics.OpenGL.BufferUsageArb usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.BufferUsageArb)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Creates and initializes a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
            /// </para>
            /// </param>
            /// <param name="usage">
            /// <para>
            /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferDataARB")]
            public static
            void BufferData<T2>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute] T2[,] data, OpenTK.Graphics.OpenGL.BufferUsageArb usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.BufferUsageArb)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Creates and initializes a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
            /// </para>
            /// </param>
            /// <param name="usage">
            /// <para>
            /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferDataARB")]
            public static
            void BufferData<T2>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute] T2[,,] data, OpenTK.Graphics.OpenGL.BufferUsageArb usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.BufferUsageArb)usage);
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Creates and initializes a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the buffer object's new data store.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.
            /// </para>
            /// </param>
            /// <param name="usage">
            /// <para>
            /// Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferDataARB")]
            public static
            void BufferData<T2>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr size, [InAttribute, OutAttribute] ref T2 data, OpenTK.Graphics.OpenGL.BufferUsageArb usage)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.BufferUsageArb)usage);
                        data = (T2)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Updates a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being replaced.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the new data that will be copied into the data store.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferSubDataARB")]
            public static
            void BufferSubData(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Updates a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being replaced.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the new data that will be copied into the data store.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferSubDataARB")]
            public static
            void BufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Updates a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being replaced.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the new data that will be copied into the data store.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferSubDataARB")]
            public static
            void BufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Updates a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being replaced.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the new data that will be copied into the data store.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferSubDataARB")]
            public static
            void BufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Updates a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being replaced.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the new data that will be copied into the data store.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glBufferSubDataARB")]
            public static
            void BufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbColorBufferFloat", Version = "1.5", EntryPoint = "glClampColorARB")]
            public static
            void ClampColor(OpenTK.Graphics.OpenGL.ArbColorBufferFloat target, OpenTK.Graphics.OpenGL.ArbColorBufferFloat clamp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClampColorARB((OpenTK.Graphics.OpenGL.ArbColorBufferFloat)target, (OpenTK.Graphics.OpenGL.ArbColorBufferFloat)clamp);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Select active texture unit
            /// </summary>
            /// <param name="texture">
            /// <para>
            /// Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least two. texture must be one of GL_TEXTURE, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial value is GL_TEXTURE0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glClientActiveTextureARB")]
            public static
            void ClientActiveTexture(OpenTK.Graphics.OpenGL.TextureUnit texture)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClientActiveTextureARB((OpenTK.Graphics.OpenGL.TextureUnit)texture);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Compiles a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the shader object to be compiled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glCompileShaderARB")]
            public static
            void CompileShader(Int32 shaderObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompileShaderARB((UInt32)shaderObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Compiles a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the shader object to be compiled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glCompileShaderARB")]
            public static
            void CompileShader(UInt32 shaderObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompileShaderARB((UInt32)shaderObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage1DARB")]
            public static
            void CompressedTexImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, Int32 imageSize, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTexImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage1DARB")]
            public static
            void CompressedTexImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T6[] data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage1DARB")]
            public static
            void CompressedTexImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T6[,] data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage1DARB")]
            public static
            void CompressedTexImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T6[,,] data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support texture images that are at least 64 texels wide. The height of the 1D texture image is 1.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage1DARB")]
            public static
            void CompressedTexImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T6 data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T6)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be Must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage2DARB")]
            public static
            void CompressedTexImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTexImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be Must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage2DARB")]
            public static
            void CompressedTexImage2D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[] data)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be Must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage2DARB")]
            public static
            void CompressedTexImage2D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,] data)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be Must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage2DARB")]
            public static
            void CompressedTexImage2D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T7[,,] data)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels wide and cube-mapped texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be Must be 2 sup n + 2 ( border ) for some integer . All implementations support 2D texture images that are at least 64 texels high and cube-mapped texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage2DARB")]
            public static
            void CompressedTexImage2D<T7>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T7 data)
                where T7 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T7)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage3DARB")]
            public static
            void CompressedTexImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTexImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage3DARB")]
            public static
            void CompressedTexImage3D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage3DARB")]
            public static
            void CompressedTexImage3D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage3DARB")]
            public static
            void CompressedTexImage3D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture image in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels wide.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels high.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture image including the border if any. If the GL version does not support non-power-of-two sizes, this value must be 2 sup n + 2 ( border ) for some integer . All implementations support 3D texture images that are at least 16 texels deep.
            /// </para>
            /// </param>
            /// <param name="border">
            /// <para>
            /// Specifies the width of the border. Must be either 0 or 1.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexImage3DARB")]
            public static
            void CompressedTexImage3D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 border, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)border, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T8)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage1DARB")]
            public static
            void CompressedTexSubImage1D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTexSubImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage1DARB")]
            public static
            void CompressedTexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T6[] data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage1DARB")]
            public static
            void CompressedTexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T6[,] data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage1DARB")]
            public static
            void CompressedTexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T6[,,] data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a one-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_1D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage1DARB")]
            public static
            void CompressedTexSubImage1D<T6>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T6 data)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage1DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T6)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage2DARB")]
            public static
            void CompressedTexSubImage2D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTexSubImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage2DARB")]
            public static
            void CompressedTexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T8[] data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage2DARB")]
            public static
            void CompressedTexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T8[,] data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage2DARB")]
            public static
            void CompressedTexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T8[,,] data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a two-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage2DARB")]
            public static
            void CompressedTexSubImage2D<T8>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 width, Int32 height, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T8 data)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage2DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)width, (Int32)height, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T8)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage3DARB")]
            public static
            void CompressedTexSubImage3D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCompressedTexSubImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage3DARB")]
            public static
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T10[] data)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage3DARB")]
            public static
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T10[,] data)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage3DARB")]
            public static
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] T10[,,] data)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify a three-dimensional texture subimage in a compressed format
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target texture. Must be GL_TEXTURE_3D.
            /// </para>
            /// </param>
            /// <param name="level">
            /// <para>
            /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="xoffset">
            /// <para>
            /// Specifies a texel offset in the x direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="yoffset">
            /// <para>
            /// Specifies a texel offset in the y direction within the texture array.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// Specifies the width of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="height">
            /// <para>
            /// Specifies the height of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth of the texture subimage.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// Specifies the format of the compressed image data stored at address data.
            /// </para>
            /// </param>
            /// <param name="imageSize">
            /// <para>
            /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the compressed image data in memory.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glCompressedTexSubImage3DARB")]
            public static
            void CompressedTexSubImage3D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 width, Int32 height, Int32 depth, OpenTK.Graphics.OpenGL.PixelFormat format, Int32 imageSize, [InAttribute, OutAttribute] ref T10 data)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glCompressedTexSubImage3DARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)width, (Int32)height, (Int32)depth, (OpenTK.Graphics.OpenGL.PixelFormat)format, (Int32)imageSize, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T10)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glCreateProgramObjectARB")]
            public static
            Int32 CreateProgramObject()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glCreateProgramObjectARB();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glCreateShaderObjectARB")]
            public static
            Int32 CreateShaderObject(OpenTK.Graphics.OpenGL.ArbShaderObjects shaderType)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glCreateShaderObjectARB((OpenTK.Graphics.OpenGL.ArbShaderObjects)shaderType);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glCurrentPaletteMatrixARB")]
            public static
            void CurrentPaletteMatrix(Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCurrentPaletteMatrixARB((Int32)index);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named buffer objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array of buffer objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glDeleteBuffersARB")]
            public static
            void DeleteBuffers(Int32 n, Int32[] buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* buffers_ptr = buffers)
                        {
                            Delegates.glDeleteBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named buffer objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array of buffer objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glDeleteBuffersARB")]
            public static
            void DeleteBuffers(Int32 n, ref Int32 buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* buffers_ptr = &buffers)
                        {
                            Delegates.glDeleteBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named buffer objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array of buffer objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glDeleteBuffersARB")]
            public static
            unsafe void DeleteBuffers(Int32 n, Int32* buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteBuffersARB((Int32)n, (UInt32*)buffers);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named buffer objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array of buffer objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glDeleteBuffersARB")]
            public static
            void DeleteBuffers(Int32 n, UInt32[] buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* buffers_ptr = buffers)
                        {
                            Delegates.glDeleteBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named buffer objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array of buffer objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glDeleteBuffersARB")]
            public static
            void DeleteBuffers(Int32 n, ref UInt32 buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* buffers_ptr = &buffers)
                        {
                            Delegates.glDeleteBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named buffer objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array of buffer objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glDeleteBuffersARB")]
            public static
            unsafe void DeleteBuffers(Int32 n, UInt32* buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteBuffersARB((Int32)n, (UInt32*)buffers);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glDeleteObjectARB")]
            public static
            void DeleteObject(Int32 obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteObjectARB((UInt32)obj);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glDeleteObjectARB")]
            public static
            void DeleteObject(UInt32 obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteObjectARB((UInt32)obj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDeleteProgramsARB")]
            public static
            void DeleteProgram(Int32 n, Int32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = programs)
                        {
                            Delegates.glDeleteProgramsARB((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDeleteProgramsARB")]
            public static
            void DeleteProgram(Int32 n, ref Int32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = &programs)
                        {
                            Delegates.glDeleteProgramsARB((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDeleteProgramsARB")]
            public static
            unsafe void DeleteProgram(Int32 n, Int32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteProgramsARB((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDeleteProgramsARB")]
            public static
            void DeleteProgram(Int32 n, UInt32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = programs)
                        {
                            Delegates.glDeleteProgramsARB((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDeleteProgramsARB")]
            public static
            void DeleteProgram(Int32 n, ref UInt32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = &programs)
                        {
                            Delegates.glDeleteProgramsARB((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDeleteProgramsARB")]
            public static
            unsafe void DeleteProgram(Int32 n, UInt32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteProgramsARB((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glDeleteQueriesARB")]
            public static
            void DeleteQueries(Int32 n, Int32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = ids)
                        {
                            Delegates.glDeleteQueriesARB((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glDeleteQueriesARB")]
            public static
            void DeleteQueries(Int32 n, ref Int32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = &ids)
                        {
                            Delegates.glDeleteQueriesARB((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glDeleteQueriesARB")]
            public static
            unsafe void DeleteQueries(Int32 n, Int32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteQueriesARB((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glDeleteQueriesARB")]
            public static
            void DeleteQueries(Int32 n, UInt32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = ids)
                        {
                            Delegates.glDeleteQueriesARB((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glDeleteQueriesARB")]
            public static
            void DeleteQueries(Int32 n, ref UInt32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = &ids)
                        {
                            Delegates.glDeleteQueriesARB((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Delete named query objects
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query objects to be deleted.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array of query objects to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glDeleteQueriesARB")]
            public static
            unsafe void DeleteQueries(Int32 n, UInt32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteQueriesARB((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glDetachObjectARB")]
            public static
            void DetachObject(Int32 containerObj, Int32 attachedObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDetachObjectARB((UInt32)containerObj, (UInt32)attachedObj);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glDetachObjectARB")]
            public static
            void DetachObject(UInt32 containerObj, UInt32 attachedObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDetachObjectARB((UInt32)containerObj, (UInt32)attachedObj);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDisableVertexAttribArrayARB")]
            public static
            void DisableVertexAttribArray(Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableVertexAttribArrayARB((UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glDisableVertexAttribArrayARB")]
            public static
            void DisableVertexAttribArray(UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDisableVertexAttribArrayARB((UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbDrawInstanced", Version = "2.0", EntryPoint = "glDrawArraysInstancedARB")]
            public static
            void DrawArraysInstanced(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 first, Int32 count, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawArraysInstancedARB((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)first, (Int32)count, (Int32)primcount);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbDrawBuffers", Version = "1.5", EntryPoint = "glDrawBuffersARB")]
            public static
            void DrawBuffers(Int32 n, OpenTK.Graphics.OpenGL.ArbDrawBuffers[] bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.ArbDrawBuffers* bufs_ptr = bufs)
                        {
                            Delegates.glDrawBuffersARB((Int32)n, (OpenTK.Graphics.OpenGL.ArbDrawBuffers*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbDrawBuffers", Version = "1.5", EntryPoint = "glDrawBuffersARB")]
            public static
            void DrawBuffers(Int32 n, ref OpenTK.Graphics.OpenGL.ArbDrawBuffers bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.ArbDrawBuffers* bufs_ptr = &bufs)
                        {
                            Delegates.glDrawBuffersARB((Int32)n, (OpenTK.Graphics.OpenGL.ArbDrawBuffers*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbDrawBuffers", Version = "1.5", EntryPoint = "glDrawBuffersARB")]
            public static
            unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.OpenGL.ArbDrawBuffers* bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawBuffersARB((Int32)n, (OpenTK.Graphics.OpenGL.ArbDrawBuffers*)bufs);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedARB")]
            public static
            void DrawElementsInstanced(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawElementsInstancedARB((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedARB")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedARB((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedARB")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedARB((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedARB")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedARB((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbDrawInstanced", Version = "2.0", EntryPoint = "glDrawElementsInstancedARB")]
            public static
            void DrawElementsInstanced<T3>(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glDrawElementsInstancedARB((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount);
                        indices = (T3)indices_ptr.Target;
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Enable or disable a generic vertex attribute array
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be enabled or disabled.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glEnableVertexAttribArrayARB")]
            public static
            void EnableVertexAttribArray(Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableVertexAttribArrayARB((UInt32)index);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Enable or disable a generic vertex attribute array
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be enabled or disabled.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glEnableVertexAttribArrayARB")]
            public static
            void EnableVertexAttribArray(UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEnableVertexAttribArrayARB((UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glEndQueryARB")]
            public static
            void EndQuery(OpenTK.Graphics.OpenGL.ArbOcclusionQuery target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndQueryARB((OpenTK.Graphics.OpenGL.ArbOcclusionQuery)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glFramebufferTextureARB")]
            public static
            void FramebufferTexture(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureARB((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glFramebufferTextureARB")]
            public static
            void FramebufferTexture(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureARB((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glFramebufferTextureFaceARB")]
            public static
            void FramebufferTextureFace(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level, OpenTK.Graphics.OpenGL.TextureTarget face)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureFaceARB((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.TextureTarget)face);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glFramebufferTextureFaceARB")]
            public static
            void FramebufferTextureFace(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level, OpenTK.Graphics.OpenGL.TextureTarget face)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureFaceARB((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (OpenTK.Graphics.OpenGL.TextureTarget)face);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glFramebufferTextureLayerARB")]
            public static
            void FramebufferTextureLayer(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, Int32 texture, Int32 level, Int32 layer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureLayerARB((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glFramebufferTextureLayerARB")]
            public static
            void FramebufferTextureLayer(OpenTK.Graphics.OpenGL.FramebufferTarget target, OpenTK.Graphics.OpenGL.FramebufferAttachment attachment, UInt32 texture, Int32 level, Int32 layer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFramebufferTextureLayerARB((OpenTK.Graphics.OpenGL.FramebufferTarget)target, (OpenTK.Graphics.OpenGL.FramebufferAttachment)attachment, (UInt32)texture, (Int32)level, (Int32)layer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate buffer object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer object names to be generated.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array in which the generated buffer object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGenBuffersARB")]
            public static
            void GenBuffers(Int32 n, [OutAttribute] Int32[] buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* buffers_ptr = buffers)
                        {
                            Delegates.glGenBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate buffer object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer object names to be generated.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array in which the generated buffer object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGenBuffersARB")]
            public static
            void GenBuffers(Int32 n, [OutAttribute] out Int32 buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* buffers_ptr = &buffers)
                        {
                            Delegates.glGenBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                            buffers = *buffers_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate buffer object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer object names to be generated.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array in which the generated buffer object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGenBuffersARB")]
            public static
            unsafe void GenBuffers(Int32 n, [OutAttribute] Int32* buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenBuffersARB((Int32)n, (UInt32*)buffers);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate buffer object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer object names to be generated.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array in which the generated buffer object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGenBuffersARB")]
            public static
            void GenBuffers(Int32 n, [OutAttribute] UInt32[] buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* buffers_ptr = buffers)
                        {
                            Delegates.glGenBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate buffer object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer object names to be generated.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array in which the generated buffer object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGenBuffersARB")]
            public static
            void GenBuffers(Int32 n, [OutAttribute] out UInt32 buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* buffers_ptr = &buffers)
                        {
                            Delegates.glGenBuffersARB((Int32)n, (UInt32*)buffers_ptr);
                            buffers = *buffers_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate buffer object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffer object names to be generated.
            /// </para>
            /// </param>
            /// <param name="buffers">
            /// <para>
            /// Specifies an array in which the generated buffer object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGenBuffersARB")]
            public static
            unsafe void GenBuffers(Int32 n, [OutAttribute] UInt32* buffers)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenBuffersARB((Int32)n, (UInt32*)buffers);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGenProgramsARB")]
            public static
            void GenProgram(Int32 n, [OutAttribute] Int32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = programs)
                        {
                            Delegates.glGenProgramsARB((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGenProgramsARB")]
            public static
            void GenProgram(Int32 n, [OutAttribute] out Int32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = &programs)
                        {
                            Delegates.glGenProgramsARB((Int32)n, (UInt32*)programs_ptr);
                            programs = *programs_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGenProgramsARB")]
            public static
            unsafe void GenProgram(Int32 n, [OutAttribute] Int32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenProgramsARB((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGenProgramsARB")]
            public static
            void GenProgram(Int32 n, [OutAttribute] UInt32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = programs)
                        {
                            Delegates.glGenProgramsARB((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGenProgramsARB")]
            public static
            void GenProgram(Int32 n, [OutAttribute] out UInt32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = &programs)
                        {
                            Delegates.glGenProgramsARB((Int32)n, (UInt32*)programs_ptr);
                            programs = *programs_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGenProgramsARB")]
            public static
            unsafe void GenProgram(Int32 n, [OutAttribute] UInt32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenProgramsARB((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGenQueriesARB")]
            public static
            void GenQueries(Int32 n, [OutAttribute] Int32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = ids)
                        {
                            Delegates.glGenQueriesARB((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGenQueriesARB")]
            public static
            void GenQueries(Int32 n, [OutAttribute] out Int32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = &ids)
                        {
                            Delegates.glGenQueriesARB((Int32)n, (UInt32*)ids_ptr);
                            ids = *ids_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGenQueriesARB")]
            public static
            unsafe void GenQueries(Int32 n, [OutAttribute] Int32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenQueriesARB((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGenQueriesARB")]
            public static
            void GenQueries(Int32 n, [OutAttribute] UInt32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = ids)
                        {
                            Delegates.glGenQueriesARB((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGenQueriesARB")]
            public static
            void GenQueries(Int32 n, [OutAttribute] out UInt32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = &ids)
                        {
                            Delegates.glGenQueriesARB((Int32)n, (UInt32*)ids_ptr);
                            ids = *ids_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Generate query object names
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of query object names to be generated.
            /// </para>
            /// </param>
            /// <param name="ids">
            /// <para>
            /// Specifies an array in which the generated query object names are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGenQueriesARB")]
            public static
            unsafe void GenQueries(Int32 n, [OutAttribute] UInt32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenQueriesARB((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active attribute variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the attribute variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the attribute variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glGetActiveAttribARB")]
            public static
            void GetActiveAttrib(Int32 programObj, Int32 index, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.ArbVertexShader type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.ArbVertexShader* type_ptr = &type)
                        {
                            Delegates.glGetActiveAttribARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.ArbVertexShader*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active attribute variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the attribute variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the attribute variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glGetActiveAttribARB")]
            public static
            unsafe void GetActiveAttrib(Int32 programObj, Int32 index, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.ArbVertexShader* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetActiveAttribARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.ArbVertexShader*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active attribute variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the attribute variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the attribute variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glGetActiveAttribARB")]
            public static
            void GetActiveAttrib(UInt32 programObj, UInt32 index, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.ArbVertexShader type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.ArbVertexShader* type_ptr = &type)
                        {
                            Delegates.glGetActiveAttribARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.ArbVertexShader*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active attribute variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the attribute variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the attribute variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the attribute variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glGetActiveAttribARB")]
            public static
            unsafe void GetActiveAttrib(UInt32 programObj, UInt32 index, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.ArbVertexShader* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetActiveAttribARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.ArbVertexShader*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active uniform variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetActiveUniformARB")]
            public static
            void GetActiveUniform(Int32 programObj, Int32 index, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.ArbShaderObjects type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.ArbShaderObjects* type_ptr = &type)
                        {
                            Delegates.glGetActiveUniformARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.ArbShaderObjects*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active uniform variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetActiveUniformARB")]
            public static
            unsafe void GetActiveUniform(Int32 programObj, Int32 index, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.ArbShaderObjects* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetActiveUniformARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.ArbShaderObjects*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active uniform variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetActiveUniformARB")]
            public static
            void GetActiveUniform(UInt32 programObj, UInt32 index, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.ArbShaderObjects type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.ArbShaderObjects* type_ptr = &type)
                        {
                            Delegates.glGetActiveUniformARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.ArbShaderObjects*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns information about an active uniform variable for the specified program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Returns the size of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Returns the data type of the uniform variable.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Returns a null terminated string containing the name of the uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetActiveUniformARB")]
            public static
            unsafe void GetActiveUniform(UInt32 programObj, UInt32 index, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.ArbShaderObjects* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetActiveUniformARB((UInt32)programObj, (UInt32)index, (Int32)maxLength, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.ArbShaderObjects*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
            public static
            void GetAttachedObjects(Int32 containerObj, Int32 maxCount, [OutAttribute] out Int32 count, [OutAttribute] out Int32 obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        fixed (Int32* obj_ptr = &obj)
                        {
                            Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count_ptr, (UInt32*)obj_ptr);
                            count = *count_ptr;
                            obj = *obj_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
            public static
            unsafe void GetAttachedObjects(Int32 containerObj, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] Int32[] obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Int32* obj_ptr = obj)
                    {
                        Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count, (UInt32*)obj_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
            public static
            unsafe void GetAttachedObjects(Int32 containerObj, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] Int32* obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count, (UInt32*)obj);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
            public static
            void GetAttachedObjects(UInt32 containerObj, Int32 maxCount, [OutAttribute] out Int32 count, [OutAttribute] out UInt32 obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* count_ptr = &count)
                        fixed (UInt32* obj_ptr = &obj)
                        {
                            Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count_ptr, (UInt32*)obj_ptr);
                            count = *count_ptr;
                            obj = *obj_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
            public static
            unsafe void GetAttachedObjects(UInt32 containerObj, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] UInt32[] obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (UInt32* obj_ptr = obj)
                    {
                        Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count, (UInt32*)obj_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetAttachedObjectsARB")]
            public static
            unsafe void GetAttachedObjects(UInt32 containerObj, Int32 maxCount, [OutAttribute] Int32* count, [OutAttribute] UInt32* obj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetAttachedObjectsARB((UInt32)containerObj, (Int32)maxCount, (Int32*)count, (UInt32*)obj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the location of an attribute variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glGetAttribLocationARB")]
            public static
            Int32 GetAttribLocation(Int32 programObj, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetAttribLocationARB((UInt32)programObj, (String)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the location of an attribute variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Points to a null terminated string containing the name of the attribute variable whose location is to be queried.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexShader", Version = "1.2", EntryPoint = "glGetAttribLocationARB")]
            public static
            Int32 GetAttribLocation(UInt32 programObj, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetAttribLocationARB((UInt32)programObj, (String)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferParameterivARB")]
            public static
            void GetBufferParameter(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferParameterNameArb pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetBufferParameterivARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferParameterNameArb)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferParameterivARB")]
            public static
            void GetBufferParameter(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferParameterNameArb pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetBufferParameterivARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferParameterNameArb)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferParameterivARB")]
            public static
            unsafe void GetBufferParameter(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferParameterNameArb pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetBufferParameterivARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferParameterNameArb)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferPointervARB")]
            public static
            void GetBufferPointer(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferPointerNameArb pname, [OutAttribute] IntPtr @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetBufferPointervARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferPointerNameArb)pname, (IntPtr)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferPointervARB")]
            public static
            void GetBufferPointer<T2>(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferPointerNameArb pname, [InAttribute, OutAttribute] T2[] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferPointervARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferPointerNameArb)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferPointervARB")]
            public static
            void GetBufferPointer<T2>(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferPointerNameArb pname, [InAttribute, OutAttribute] T2[,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferPointervARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferPointerNameArb)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferPointervARB")]
            public static
            void GetBufferPointer<T2>(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferPointerNameArb pname, [InAttribute, OutAttribute] T2[,,] @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferPointervARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferPointerNameArb)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferPointervARB")]
            public static
            void GetBufferPointer<T2>(OpenTK.Graphics.OpenGL.ArbVertexBufferObject target, OpenTK.Graphics.OpenGL.BufferPointerNameArb pname, [InAttribute, OutAttribute] ref T2 @params)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferPointervARB((OpenTK.Graphics.OpenGL.ArbVertexBufferObject)target, (OpenTK.Graphics.OpenGL.BufferPointerNameArb)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                        @params = (T2)@params_ptr.Target;
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being returned.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the location where buffer object data is returned.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferSubDataARB")]
            public static
            void GetBufferSubData(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [OutAttribute] IntPtr data)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being returned.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the location where buffer object data is returned.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferSubDataARB")]
            public static
            void GetBufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being returned.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the location where buffer object data is returned.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferSubDataARB")]
            public static
            void GetBufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being returned.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the location where buffer object data is returned.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferSubDataARB")]
            public static
            void GetBufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] T3[,,] data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a subset of a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="offset">
            /// <para>
            /// Specifies the offset into the buffer object's data store from which data will be returned, measured in bytes.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the size in bytes of the data store region being returned.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Specifies a pointer to the location where buffer object data is returned.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glGetBufferSubDataARB")]
            public static
            void GetBufferSubData<T3>(OpenTK.Graphics.OpenGL.BufferTargetArb target, IntPtr offset, IntPtr size, [InAttribute, OutAttribute] ref T3 data)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle data_ptr = GCHandle.Alloc(data, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetBufferSubDataARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (IntPtr)offset, (IntPtr)size, (IntPtr)data_ptr.AddrOfPinnedObject());
                        data = (T3)data_ptr.Target;
                    }
                    finally
                    {
                        data_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a compressed texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3D GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
            /// </para>
            /// </param>
            /// <param name="lod">
            /// <para>
            /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="img">
            /// <para>
            /// Returns the compressed texture image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glGetCompressedTexImageARB")]
            public static
            void GetCompressedTexImage(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, [OutAttribute] IntPtr img)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCompressedTexImageARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (IntPtr)img);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a compressed texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3D GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
            /// </para>
            /// </param>
            /// <param name="lod">
            /// <para>
            /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="img">
            /// <para>
            /// Returns the compressed texture image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glGetCompressedTexImageARB")]
            public static
            void GetCompressedTexImage<T2>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, [InAttribute, OutAttribute] T2[] img)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTexImageARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a compressed texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3D GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
            /// </para>
            /// </param>
            /// <param name="lod">
            /// <para>
            /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="img">
            /// <para>
            /// Returns the compressed texture image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glGetCompressedTexImageARB")]
            public static
            void GetCompressedTexImage<T2>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, [InAttribute, OutAttribute] T2[,] img)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTexImageARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a compressed texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3D GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
            /// </para>
            /// </param>
            /// <param name="lod">
            /// <para>
            /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="img">
            /// <para>
            /// Returns the compressed texture image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glGetCompressedTexImageARB")]
            public static
            void GetCompressedTexImage<T2>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, [InAttribute, OutAttribute] T2[,,] img)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTexImageARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (IntPtr)img_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a compressed texture image
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies which texture is to be obtained. GL_TEXTURE_1D, GL_TEXTURE_2D, and GL_TEXTURE_3D GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z are accepted.
            /// </para>
            /// </param>
            /// <param name="lod">
            /// <para>
            /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level is the th mipmap reduction image.
            /// </para>
            /// </param>
            /// <param name="img">
            /// <para>
            /// Returns the compressed texture image.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTextureCompression", Version = "1.2", EntryPoint = "glGetCompressedTexImageARB")]
            public static
            void GetCompressedTexImage<T2>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, [InAttribute, OutAttribute] ref T2 img)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle img_ptr = GCHandle.Alloc(img, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetCompressedTexImageARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (IntPtr)img_ptr.AddrOfPinnedObject());
                        img = (T2)img_ptr.Target;
                    }
                    finally
                    {
                        img_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetHandleARB")]
            public static
            Int32 GetHandle(OpenTK.Graphics.OpenGL.ArbShaderObjects pname)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetHandleARB((OpenTK.Graphics.OpenGL.ArbShaderObjects)pname);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetInfoLogARB")]
            public static
            void GetInfoLog(Int32 obj, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetInfoLogARB((UInt32)obj, (Int32)maxLength, (Int32*)length_ptr, (StringBuilder)infoLog);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetInfoLogARB")]
            public static
            unsafe void GetInfoLog(Int32 obj, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetInfoLogARB((UInt32)obj, (Int32)maxLength, (Int32*)length, (StringBuilder)infoLog);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetInfoLogARB")]
            public static
            void GetInfoLog(UInt32 obj, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder infoLog)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetInfoLogARB((UInt32)obj, (Int32)maxLength, (Int32*)length_ptr, (StringBuilder)infoLog);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetInfoLogARB")]
            public static
            unsafe void GetInfoLog(UInt32 obj, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] StringBuilder infoLog)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetInfoLogARB((UInt32)obj, (Int32)maxLength, (Int32*)length, (StringBuilder)infoLog);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterfvARB")]
            public static
            void GetObjectParameter(Int32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetObjectParameterfvARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterfvARB")]
            public static
            void GetObjectParameter(Int32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectParameterfvARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterfvARB")]
            public static
            unsafe void GetObjectParameter(Int32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectParameterfvARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterfvARB")]
            public static
            void GetObjectParameter(UInt32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetObjectParameterfvARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterfvARB")]
            public static
            void GetObjectParameter(UInt32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectParameterfvARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterfvARB")]
            public static
            unsafe void GetObjectParameter(UInt32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectParameterfvARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterivARB")]
            public static
            void GetObjectParameter(Int32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetObjectParameterivARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterivARB")]
            public static
            void GetObjectParameter(Int32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectParameterivARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterivARB")]
            public static
            unsafe void GetObjectParameter(Int32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectParameterivARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterivARB")]
            public static
            void GetObjectParameter(UInt32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetObjectParameterivARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterivARB")]
            public static
            void GetObjectParameter(UInt32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectParameterivARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetObjectParameterivARB")]
            public static
            unsafe void GetObjectParameter(UInt32 obj, OpenTK.Graphics.OpenGL.ArbShaderObjects pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectParameterivARB((UInt32)obj, (OpenTK.Graphics.OpenGL.ArbShaderObjects)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterdvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterdvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterdvARB")]
            public static
            unsafe void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterdvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterdvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterdvARB")]
            public static
            unsafe void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterfvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterfvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterfvARB")]
            public static
            unsafe void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterfvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterfvARB")]
            public static
            void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramEnvParameterfvARB")]
            public static
            unsafe void GetProgramEnvParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramivARB")]
            public static
            void GetProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramivARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramivARB")]
            public static
            unsafe void GetProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramivARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterdvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterdvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterdvARB")]
            public static
            unsafe void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterdvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterdvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterdvARB")]
            public static
            unsafe void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterdvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterfvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterfvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterfvARB")]
            public static
            unsafe void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, Int32 index, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterfvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterfvARB")]
            public static
            void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramLocalParameterfvARB")]
            public static
            unsafe void GetProgramLocalParameter(OpenTK.Graphics.OpenGL.ArbVertexProgram target, UInt32 index, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterfvARB((OpenTK.Graphics.OpenGL.ArbVertexProgram)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramStringARB")]
            public static
            void GetProgramString(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramStringARB")]
            public static
            void GetProgramString<T2>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [InAttribute, OutAttribute] T2[] @string)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramStringARB")]
            public static
            void GetProgramString<T2>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [InAttribute, OutAttribute] T2[,] @string)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramStringARB")]
            public static
            void GetProgramString<T2>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [InAttribute, OutAttribute] T2[,,] @string)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetProgramStringARB")]
            public static
            void GetProgramString<T2>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [InAttribute, OutAttribute] ref T2 @string)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T2)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryivARB")]
            public static
            void GetQuery(OpenTK.Graphics.OpenGL.ArbOcclusionQuery target, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetQueryivARB((OpenTK.Graphics.OpenGL.ArbOcclusionQuery)target, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryivARB")]
            public static
            void GetQuery(OpenTK.Graphics.OpenGL.ArbOcclusionQuery target, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetQueryivARB((OpenTK.Graphics.OpenGL.ArbOcclusionQuery)target, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryivARB")]
            public static
            unsafe void GetQuery(OpenTK.Graphics.OpenGL.ArbOcclusionQuery target, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetQueryivARB((OpenTK.Graphics.OpenGL.ArbOcclusionQuery)target, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectivARB")]
            public static
            void GetQueryObject(Int32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetQueryObjectivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectivARB")]
            public static
            void GetQueryObject(Int32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetQueryObjectivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectivARB")]
            public static
            unsafe void GetQueryObject(Int32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetQueryObjectivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectivARB")]
            public static
            void GetQueryObject(UInt32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetQueryObjectivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectivARB")]
            public static
            void GetQueryObject(UInt32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetQueryObjectivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectivARB")]
            public static
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetQueryObjectivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectuivARB")]
            public static
            void GetQueryObject(UInt32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetQueryObjectuivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectuivARB")]
            public static
            void GetQueryObject(UInt32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetQueryObjectuivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return parameters of a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies the name of a query object.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or GL_QUERY_RESULT_AVAILABLE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glGetQueryObjectuivARB")]
            public static
            unsafe void GetQueryObject(UInt32 id, OpenTK.Graphics.OpenGL.ArbOcclusionQuery pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetQueryObjectuivARB((UInt32)id, (OpenTK.Graphics.OpenGL.ArbOcclusionQuery)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the source code string from a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the shader object to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the character buffer for storing the returned source code string.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the length of the string returned in source (excluding the null terminator).
            /// </para>
            /// </param>
            /// <param name="source">
            /// <para>
            /// Specifies an array of characters that is used to return the source code string.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetShaderSourceARB")]
            public static
            void GetShaderSource(Int32 obj, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder source)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetShaderSourceARB((UInt32)obj, (Int32)maxLength, (Int32*)length_ptr, (StringBuilder)source);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the source code string from a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the shader object to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the character buffer for storing the returned source code string.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the length of the string returned in source (excluding the null terminator).
            /// </para>
            /// </param>
            /// <param name="source">
            /// <para>
            /// Specifies an array of characters that is used to return the source code string.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetShaderSourceARB")]
            public static
            unsafe void GetShaderSource(Int32 obj, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] StringBuilder source)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetShaderSourceARB((UInt32)obj, (Int32)maxLength, (Int32*)length, (StringBuilder)source);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the source code string from a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the shader object to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the character buffer for storing the returned source code string.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the length of the string returned in source (excluding the null terminator).
            /// </para>
            /// </param>
            /// <param name="source">
            /// <para>
            /// Specifies an array of characters that is used to return the source code string.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetShaderSourceARB")]
            public static
            void GetShaderSource(UInt32 obj, Int32 maxLength, [OutAttribute] out Int32 length, [OutAttribute] StringBuilder source)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glGetShaderSourceARB((UInt32)obj, (Int32)maxLength, (Int32*)length_ptr, (StringBuilder)source);
                            length = *length_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the source code string from a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the shader object to be queried.
            /// </para>
            /// </param>
            /// <param name="bufSize">
            /// <para>
            /// Specifies the size of the character buffer for storing the returned source code string.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Returns the length of the string returned in source (excluding the null terminator).
            /// </para>
            /// </param>
            /// <param name="source">
            /// <para>
            /// Specifies an array of characters that is used to return the source code string.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetShaderSourceARB")]
            public static
            unsafe void GetShaderSource(UInt32 obj, Int32 maxLength, [OutAttribute] Int32* length, [OutAttribute] StringBuilder source)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetShaderSourceARB((UInt32)obj, (Int32)maxLength, (Int32*)length, (StringBuilder)source);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformfvARB")]
            public static
            void GetUniform(Int32 programObj, Int32 location, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetUniformfvARB((UInt32)programObj, (Int32)location, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformfvARB")]
            public static
            void GetUniform(Int32 programObj, Int32 location, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetUniformfvARB((UInt32)programObj, (Int32)location, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformfvARB")]
            public static
            unsafe void GetUniform(Int32 programObj, Int32 location, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetUniformfvARB((UInt32)programObj, (Int32)location, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformfvARB")]
            public static
            void GetUniform(UInt32 programObj, Int32 location, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetUniformfvARB((UInt32)programObj, (Int32)location, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformfvARB")]
            public static
            void GetUniform(UInt32 programObj, Int32 location, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetUniformfvARB((UInt32)programObj, (Int32)location, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformfvARB")]
            public static
            unsafe void GetUniform(UInt32 programObj, Int32 location, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetUniformfvARB((UInt32)programObj, (Int32)location, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformivARB")]
            public static
            void GetUniform(Int32 programObj, Int32 location, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetUniformivARB((UInt32)programObj, (Int32)location, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformivARB")]
            public static
            void GetUniform(Int32 programObj, Int32 location, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetUniformivARB((UInt32)programObj, (Int32)location, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformivARB")]
            public static
            unsafe void GetUniform(Int32 programObj, Int32 location, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetUniformivARB((UInt32)programObj, (Int32)location, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformivARB")]
            public static
            void GetUniform(UInt32 programObj, Int32 location, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetUniformivARB((UInt32)programObj, (Int32)location, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformivARB")]
            public static
            void GetUniform(UInt32 programObj, Int32 location, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetUniformivARB((UInt32)programObj, (Int32)location, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the value of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be queried.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the value of the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformivARB")]
            public static
            unsafe void GetUniform(UInt32 programObj, Int32 location, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetUniformivARB((UInt32)programObj, (Int32)location, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the location of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformLocationARB")]
            public static
            Int32 GetUniformLocation(Int32 programObj, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetUniformLocationARB((UInt32)programObj, (String)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns the location of a uniform variable
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="name">
            /// <para>
            /// Points to a null terminated string containing the name of the uniform variable whose location is to be queried.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glGetUniformLocationARB")]
            public static
            Int32 GetUniformLocation(UInt32 programObj, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetUniformLocationARB((UInt32)programObj, (String)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribdvARB")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribdvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribdvARB")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribdvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribdvARB")]
            public static
            unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribdvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribdvARB")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribdvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribdvARB")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribdvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribdvARB")]
            public static
            unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribdvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribfvARB")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribfvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribfvARB")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribfvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribfvARB")]
            public static
            unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribfvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribfvARB")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribfvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribfvARB")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribfvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribfvARB")]
            public static
            unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribfvARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribivARB")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribivARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribivARB")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribivARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribivARB")]
            public static
            unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribivARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribivARB")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribivARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribivARB")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribivARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribivARB")]
            public static
            unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribParameterArb pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribivARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glGetVertexAttribPointervARB")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb pname, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervARB((UInt32)index, (OpenTK.Graphics.OpenGL.VertexAttribPointerParameterArb)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if a name corresponds to a buffer object
            /// </summary>
            /// <param name="buffer">
            /// <para>
            /// Specifies a value that may be the name of a buffer object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glIsBufferARB")]
            public static
            bool IsBuffer(Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsBufferARB((UInt32)buffer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if a name corresponds to a buffer object
            /// </summary>
            /// <param name="buffer">
            /// <para>
            /// Specifies a value that may be the name of a buffer object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glIsBufferARB")]
            public static
            bool IsBuffer(UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsBufferARB((UInt32)buffer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determines if a name corresponds to a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies a potential program object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glIsProgramARB")]
            public static
            bool IsProgram(Int32 program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsProgramARB((UInt32)program);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determines if a name corresponds to a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies a potential program object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glIsProgramARB")]
            public static
            bool IsProgram(UInt32 program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsProgramARB((UInt32)program);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if a name corresponds to a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies a value that may be the name of a query object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glIsQueryARB")]
            public static
            bool IsQuery(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsQueryARB((UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determine if a name corresponds to a query object
            /// </summary>
            /// <param name="id">
            /// <para>
            /// Specifies a value that may be the name of a query object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbOcclusionQuery", Version = "1.5", EntryPoint = "glIsQueryARB")]
            public static
            bool IsQuery(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsQueryARB((UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Links a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program object to be linked.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glLinkProgramARB")]
            public static
            void LinkProgram(Int32 programObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLinkProgramARB((UInt32)programObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Links a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program object to be linked.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glLinkProgramARB")]
            public static
            void LinkProgram(UInt32 programObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLinkProgramARB((UInt32)programObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replace the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glLoadTransposeMatrixdARB")]
            public static
            void LoadTransposeMatrix(Double[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = m)
                        {
                            Delegates.glLoadTransposeMatrixdARB((Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replace the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glLoadTransposeMatrixdARB")]
            public static
            void LoadTransposeMatrix(ref Double m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = &m)
                        {
                            Delegates.glLoadTransposeMatrixdARB((Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replace the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glLoadTransposeMatrixdARB")]
            public static
            unsafe void LoadTransposeMatrix(Double* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLoadTransposeMatrixdARB((Double*)m);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replace the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glLoadTransposeMatrixfARB")]
            public static
            void LoadTransposeMatrix(Single[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = m)
                        {
                            Delegates.glLoadTransposeMatrixfARB((Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replace the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glLoadTransposeMatrixfARB")]
            public static
            void LoadTransposeMatrix(ref Single m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = &m)
                        {
                            Delegates.glLoadTransposeMatrixfARB((Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replace the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glLoadTransposeMatrixfARB")]
            public static
            unsafe void LoadTransposeMatrix(Single* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLoadTransposeMatrixfARB((Single*)m);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Map a buffer object's data store
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the target buffer object being mapped. The symbolic constant must be GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER.
            /// </para>
            /// </param>
            /// <param name="access">
            /// <para>
            /// Specifies the access policy, indicating whether it will be possible to read from, write to, or both read from and write to the buffer object's mapped data store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glMapBufferARB")]
            public static
            unsafe System.IntPtr MapBuffer(OpenTK.Graphics.OpenGL.BufferTargetArb target, OpenTK.Graphics.OpenGL.ArbVertexBufferObject access)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glMapBufferARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target, (OpenTK.Graphics.OpenGL.ArbVertexBufferObject)access);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexPointerARB")]
            public static
            void MatrixIndexPointer(Int32 size, OpenTK.Graphics.OpenGL.ArbMatrixPalette type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixIndexPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbMatrixPalette)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexPointerARB")]
            public static
            void MatrixIndexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbMatrixPalette type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMatrixIndexPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbMatrixPalette)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexPointerARB")]
            public static
            void MatrixIndexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbMatrixPalette type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMatrixIndexPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbMatrixPalette)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexPointerARB")]
            public static
            void MatrixIndexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbMatrixPalette type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMatrixIndexPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbMatrixPalette)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexPointerARB")]
            public static
            void MatrixIndexPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbMatrixPalette type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMatrixIndexPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbMatrixPalette)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexubvARB")]
            public static
            void MatrixIndex(Int32 size, Byte[] indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* indices_ptr = indices)
                        {
                            Delegates.glMatrixIndexubvARB((Int32)size, (Byte*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexubvARB")]
            public static
            void MatrixIndex(Int32 size, ref Byte indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* indices_ptr = &indices)
                        {
                            Delegates.glMatrixIndexubvARB((Int32)size, (Byte*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexubvARB")]
            public static
            unsafe void MatrixIndex(Int32 size, Byte* indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixIndexubvARB((Int32)size, (Byte*)indices);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexuivARB")]
            public static
            void MatrixIndex(Int32 size, Int32[] indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* indices_ptr = indices)
                        {
                            Delegates.glMatrixIndexuivARB((Int32)size, (UInt32*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexuivARB")]
            public static
            void MatrixIndex(Int32 size, ref Int32 indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* indices_ptr = &indices)
                        {
                            Delegates.glMatrixIndexuivARB((Int32)size, (UInt32*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexuivARB")]
            public static
            unsafe void MatrixIndex(Int32 size, Int32* indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixIndexuivARB((Int32)size, (UInt32*)indices);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexuivARB")]
            public static
            void MatrixIndex(Int32 size, UInt32[] indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* indices_ptr = indices)
                        {
                            Delegates.glMatrixIndexuivARB((Int32)size, (UInt32*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexuivARB")]
            public static
            void MatrixIndex(Int32 size, ref UInt32 indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* indices_ptr = &indices)
                        {
                            Delegates.glMatrixIndexuivARB((Int32)size, (UInt32*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexuivARB")]
            public static
            unsafe void MatrixIndex(Int32 size, UInt32* indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixIndexuivARB((Int32)size, (UInt32*)indices);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexusvARB")]
            public static
            void MatrixIndex(Int32 size, Int16[] indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* indices_ptr = indices)
                        {
                            Delegates.glMatrixIndexusvARB((Int32)size, (UInt16*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexusvARB")]
            public static
            void MatrixIndex(Int32 size, ref Int16 indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* indices_ptr = &indices)
                        {
                            Delegates.glMatrixIndexusvARB((Int32)size, (UInt16*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexusvARB")]
            public static
            unsafe void MatrixIndex(Int32 size, Int16* indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixIndexusvARB((Int32)size, (UInt16*)indices);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexusvARB")]
            public static
            void MatrixIndex(Int32 size, UInt16[] indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* indices_ptr = indices)
                        {
                            Delegates.glMatrixIndexusvARB((Int32)size, (UInt16*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexusvARB")]
            public static
            void MatrixIndex(Int32 size, ref UInt16 indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* indices_ptr = &indices)
                        {
                            Delegates.glMatrixIndexusvARB((Int32)size, (UInt16*)indices_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMatrixPalette", Version = "1.1", EntryPoint = "glMatrixIndexusvARB")]
            public static
            unsafe void MatrixIndex(Int32 size, UInt16* indices)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMatrixIndexusvARB((Int32)size, (UInt16*)indices);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1dARB")]
            public static
            void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Double s)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1dARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double)s);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1dvARB")]
            public static
            unsafe void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1fARB")]
            public static
            void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Single s)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1fARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single)s);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1fvARB")]
            public static
            unsafe void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1iARB")]
            public static
            void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Int32 s)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1iARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32)s);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1ivARB")]
            public static
            unsafe void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1sARB")]
            public static
            void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Int16 s)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1sARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16)s);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord1svARB")]
            public static
            unsafe void MultiTexCoord1(OpenTK.Graphics.OpenGL.TextureUnit target, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2dARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Double s, Double t)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2dARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double)s, (Double)t);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2dvARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord2dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2dvARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord2dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2dvARB")]
            public static
            unsafe void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2fARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Single s, Single t)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2fARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single)s, (Single)t);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2fvARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord2fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2fvARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord2fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2fvARB")]
            public static
            unsafe void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2iARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Int32 s, Int32 t)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2iARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32)s, (Int32)t);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2ivARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord2ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2ivARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord2ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2ivARB")]
            public static
            unsafe void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2sARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Int16 s, Int16 t)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2sARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16)s, (Int16)t);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2svARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord2svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2svARB")]
            public static
            void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord2svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord2svARB")]
            public static
            unsafe void MultiTexCoord2(OpenTK.Graphics.OpenGL.TextureUnit target, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3dARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Double s, Double t, Double r)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3dARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double)s, (Double)t, (Double)r);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3dvARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord3dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3dvARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord3dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3dvARB")]
            public static
            unsafe void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3fARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Single s, Single t, Single r)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3fARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single)s, (Single)t, (Single)r);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3fvARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord3fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3fvARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord3fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3fvARB")]
            public static
            unsafe void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3iARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Int32 s, Int32 t, Int32 r)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3iARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32)s, (Int32)t, (Int32)r);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3ivARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord3ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3ivARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord3ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3ivARB")]
            public static
            unsafe void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3sARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Int16 s, Int16 t, Int16 r)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3sARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16)s, (Int16)t, (Int16)r);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3svARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord3svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3svARB")]
            public static
            void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord3svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord3svARB")]
            public static
            unsafe void MultiTexCoord3(OpenTK.Graphics.OpenGL.TextureUnit target, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4dARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Double s, Double t, Double r, Double q)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4dARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double)s, (Double)t, (Double)r, (Double)q);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4dvARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord4dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4dvARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord4dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4dvARB")]
            public static
            unsafe void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4dvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4fARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Single s, Single t, Single r, Single q)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4fARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single)s, (Single)t, (Single)r, (Single)q);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4fvARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord4fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4fvARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord4fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4fvARB")]
            public static
            unsafe void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4fvARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4iARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Int32 s, Int32 t, Int32 r, Int32 q)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4iARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32)s, (Int32)t, (Int32)r, (Int32)q);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4ivARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord4ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4ivARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord4ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4ivARB")]
            public static
            unsafe void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4ivARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4sARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Int16 s, Int16 t, Int16 r, Int16 q)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4sARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16)s, (Int16)t, (Int16)r, (Int16)q);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4svARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord4svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4svARB")]
            public static
            void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord4svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set the current texture coordinates
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies the texture unit whose coordinates should be modified. The number of texture units is implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTURE, where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
            /// </para>
            /// </param>
            /// <param name="s">
            /// <para>
            /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present in all forms of the command.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbMultitexture", Version = "1.2", EntryPoint = "glMultiTexCoord4svARB")]
            public static
            unsafe void MultiTexCoord4(OpenTK.Graphics.OpenGL.TextureUnit target, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4svARB((OpenTK.Graphics.OpenGL.TextureUnit)target, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Multiply the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Points to 16 consecutive values that are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glMultTransposeMatrixdARB")]
            public static
            void MultTransposeMatrix(Double[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = m)
                        {
                            Delegates.glMultTransposeMatrixdARB((Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Multiply the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Points to 16 consecutive values that are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glMultTransposeMatrixdARB")]
            public static
            void MultTransposeMatrix(ref Double m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* m_ptr = &m)
                        {
                            Delegates.glMultTransposeMatrixdARB((Double*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Multiply the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Points to 16 consecutive values that are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glMultTransposeMatrixdARB")]
            public static
            unsafe void MultTransposeMatrix(Double* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultTransposeMatrixdARB((Double*)m);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Multiply the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Points to 16 consecutive values that are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glMultTransposeMatrixfARB")]
            public static
            void MultTransposeMatrix(Single[] m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = m)
                        {
                            Delegates.glMultTransposeMatrixfARB((Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Multiply the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Points to 16 consecutive values that are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glMultTransposeMatrixfARB")]
            public static
            void MultTransposeMatrix(ref Single m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* m_ptr = &m)
                        {
                            Delegates.glMultTransposeMatrixfARB((Single*)m_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Multiply the current matrix with the specified row-major ordered matrix
            /// </summary>
            /// <param name="m">
            /// <para>
            /// Points to 16 consecutive values that are used as the elements of a 4 times 4 row-major matrix.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbTransposeMatrix", Version = "1.2", EntryPoint = "glMultTransposeMatrixfARB")]
            public static
            unsafe void MultTransposeMatrix(Single* m)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultTransposeMatrixfARB((Single*)m);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbPointParameters", Version = "1.0", EntryPoint = "glPointParameterfARB")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.ArbPointParameters pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterfARB((OpenTK.Graphics.OpenGL.ArbPointParameters)pname, (Single)param);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbPointParameters", Version = "1.0", EntryPoint = "glPointParameterfvARB")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.ArbPointParameters pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glPointParameterfvARB((OpenTK.Graphics.OpenGL.ArbPointParameters)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbPointParameters", Version = "1.0", EntryPoint = "glPointParameterfvARB")]
            public static
            unsafe void PointParameter(OpenTK.Graphics.OpenGL.ArbPointParameters pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterfvARB((OpenTK.Graphics.OpenGL.ArbPointParameters)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4dARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4dARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dvARB")]
            public static
            unsafe void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4dvARB")]
            public static
            unsafe void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4fARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4fARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fvARB")]
            public static
            unsafe void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fvARB")]
            public static
            void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramEnvParameter4fvARB")]
            public static
            unsafe void ProgramEnvParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4dARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4dARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dvARB")]
            public static
            unsafe void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, ref Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4dvARB")]
            public static
            unsafe void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4dvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4fARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4fARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fvARB")]
            public static
            unsafe void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fvARB")]
            public static
            void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramLocalParameter4fvARB")]
            public static
            unsafe void ProgramLocalParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameter4fvARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glProgramParameteriARB")]
            public static
            void ProgramParameter(Int32 program, OpenTK.Graphics.OpenGL.ArbGeometryShader4 pname, Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameteriARB((UInt32)program, (OpenTK.Graphics.OpenGL.ArbGeometryShader4)pname, (Int32)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbGeometryShader4", Version = "3.0", EntryPoint = "glProgramParameteriARB")]
            public static
            void ProgramParameter(UInt32 program, OpenTK.Graphics.OpenGL.ArbGeometryShader4 pname, Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameteriARB((UInt32)program, (OpenTK.Graphics.OpenGL.ArbGeometryShader4)pname, (Int32)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramStringARB")]
            public static
            void ProgramString(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.ArbVertexProgram format, Int32 len, IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.ArbVertexProgram)format, (Int32)len, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramStringARB")]
            public static
            void ProgramString<T3>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.ArbVertexProgram format, Int32 len, [InAttribute, OutAttribute] T3[] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.ArbVertexProgram)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramStringARB")]
            public static
            void ProgramString<T3>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.ArbVertexProgram format, Int32 len, [InAttribute, OutAttribute] T3[,] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.ArbVertexProgram)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramStringARB")]
            public static
            void ProgramString<T3>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.ArbVertexProgram format, Int32 len, [InAttribute, OutAttribute] T3[,,] @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.ArbVertexProgram)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glProgramStringARB")]
            public static
            void ProgramString<T3>(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, OpenTK.Graphics.OpenGL.ArbVertexProgram format, Int32 len, [InAttribute, OutAttribute] ref T3 @string)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glProgramStringARB((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (OpenTK.Graphics.OpenGL.ArbVertexProgram)format, (Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T3)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify multisample coverage parameters
            /// </summary>
            /// <param name="value">
            /// <para>
            /// Specify a single floating-point sample coverage value. The value is clamped to the range [0 ,1]. The initial value is 1.0.
            /// </para>
            /// </param>
            /// <param name="invert">
            /// <para>
            /// Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and GL_FALSE are accepted. The initial value is GL_FALSE.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbMultisample", Version = "1.2", EntryPoint = "glSampleCoverageARB")]
            public static
            void SampleCoverage(Single value, bool invert)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleCoverageARB((Single)value, (bool)invert);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replaces the source code in a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the handle of the shader object whose source code is to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements in the string and length arrays.
            /// </para>
            /// </param>
            /// <param name="string">
            /// <para>
            /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies an array of string lengths.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glShaderSourceARB")]
            public static
            void ShaderSource(Int32 shaderObj, Int32 count, String[] @string, ref Int32 length)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glShaderSourceARB((UInt32)shaderObj, (Int32)count, (String[])@string, (Int32*)length_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replaces the source code in a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the handle of the shader object whose source code is to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements in the string and length arrays.
            /// </para>
            /// </param>
            /// <param name="string">
            /// <para>
            /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies an array of string lengths.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glShaderSourceARB")]
            public static
            unsafe void ShaderSource(Int32 shaderObj, Int32 count, String[] @string, Int32* length)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderSourceARB((UInt32)shaderObj, (Int32)count, (String[])@string, (Int32*)length);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replaces the source code in a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the handle of the shader object whose source code is to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements in the string and length arrays.
            /// </para>
            /// </param>
            /// <param name="string">
            /// <para>
            /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies an array of string lengths.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glShaderSourceARB")]
            public static
            void ShaderSource(UInt32 shaderObj, Int32 count, String[] @string, ref Int32 length)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        {
                            Delegates.glShaderSourceARB((UInt32)shaderObj, (Int32)count, (String[])@string, (Int32*)length_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Replaces the source code in a shader object
            /// </summary>
            /// <param name="shader">
            /// <para>
            /// Specifies the handle of the shader object whose source code is to be replaced.
            /// </para>
            /// </param>
            /// <param name="count">
            /// <para>
            /// Specifies the number of elements in the string and length arrays.
            /// </para>
            /// </param>
            /// <param name="string">
            /// <para>
            /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
            /// </para>
            /// </param>
            /// <param name="length">
            /// <para>
            /// Specifies an array of string lengths.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glShaderSourceARB")]
            public static
            unsafe void ShaderSource(UInt32 shaderObj, Int32 count, String[] @string, Int32* length)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glShaderSourceARB((UInt32)shaderObj, (Int32)count, (String[])@string, (Int32*)length);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbTextureBufferObject", Version = "3.0", EntryPoint = "glTexBufferARB")]
            public static
            void TexBuffer(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ArbTextureBufferObject internalformat, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexBufferARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ArbTextureBufferObject)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbTextureBufferObject", Version = "3.0", EntryPoint = "glTexBufferARB")]
            public static
            void TexBuffer(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.ArbTextureBufferObject internalformat, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexBufferARB((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.ArbTextureBufferObject)internalformat, (UInt32)buffer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1fARB")]
            public static
            void Uniform1(Int32 location, Single v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1fARB((Int32)location, (Single)v0);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1fvARB")]
            public static
            void Uniform1(Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniform1fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1fvARB")]
            public static
            void Uniform1(Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniform1fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1fvARB")]
            public static
            unsafe void Uniform1(Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1fvARB((Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1iARB")]
            public static
            void Uniform1(Int32 location, Int32 v0)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1iARB((Int32)location, (Int32)v0);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1ivARB")]
            public static
            void Uniform1(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform1ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1ivARB")]
            public static
            void Uniform1(Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glUniform1ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform1ivARB")]
            public static
            unsafe void Uniform1(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform1ivARB((Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2fARB")]
            public static
            void Uniform2(Int32 location, Single v0, Single v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2fARB((Int32)location, (Single)v0, (Single)v1);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2fvARB")]
            public static
            void Uniform2(Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniform2fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2fvARB")]
            public static
            void Uniform2(Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniform2fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2fvARB")]
            public static
            unsafe void Uniform2(Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2fvARB((Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2iARB")]
            public static
            void Uniform2(Int32 location, Int32 v0, Int32 v1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2iARB((Int32)location, (Int32)v0, (Int32)v1);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2ivARB")]
            public static
            void Uniform2(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform2ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform2ivARB")]
            public static
            unsafe void Uniform2(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform2ivARB((Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3fARB")]
            public static
            void Uniform3(Int32 location, Single v0, Single v1, Single v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3fARB((Int32)location, (Single)v0, (Single)v1, (Single)v2);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3fvARB")]
            public static
            void Uniform3(Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniform3fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3fvARB")]
            public static
            void Uniform3(Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniform3fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3fvARB")]
            public static
            unsafe void Uniform3(Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3fvARB((Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3iARB")]
            public static
            void Uniform3(Int32 location, Int32 v0, Int32 v1, Int32 v2)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3iARB((Int32)location, (Int32)v0, (Int32)v1, (Int32)v2);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3ivARB")]
            public static
            void Uniform3(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform3ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3ivARB")]
            public static
            void Uniform3(Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glUniform3ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform3ivARB")]
            public static
            unsafe void Uniform3(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform3ivARB((Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4fARB")]
            public static
            void Uniform4(Int32 location, Single v0, Single v1, Single v2, Single v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4fARB((Int32)location, (Single)v0, (Single)v1, (Single)v2, (Single)v3);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4fvARB")]
            public static
            void Uniform4(Int32 location, Int32 count, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniform4fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4fvARB")]
            public static
            void Uniform4(Int32 location, Int32 count, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniform4fvARB((Int32)location, (Int32)count, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4fvARB")]
            public static
            unsafe void Uniform4(Int32 location, Int32 count, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4fvARB((Int32)location, (Int32)count, (Single*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4iARB")]
            public static
            void Uniform4(Int32 location, Int32 v0, Int32 v1, Int32 v2, Int32 v3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4iARB((Int32)location, (Int32)v0, (Int32)v1, (Int32)v2, (Int32)v3);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4ivARB")]
            public static
            void Uniform4(Int32 location, Int32 count, Int32[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = value)
                        {
                            Delegates.glUniform4ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4ivARB")]
            public static
            void Uniform4(Int32 location, Int32 count, ref Int32 value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* value_ptr = &value)
                        {
                            Delegates.glUniform4ivARB((Int32)location, (Int32)count, (Int32*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the value of a uniform variable for the current program object
            /// </summary>
            /// <param name="location">
            /// <para>
            /// Specifies the location of the uniform variable to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified uniform variable.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniform4ivARB")]
            public static
            unsafe void Uniform4(Int32 location, Int32 count, Int32* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniform4ivARB((Int32)location, (Int32)count, (Int32*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix2fvARB")]
            public static
            void UniformMatrix2(Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniformMatrix2fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix2fvARB")]
            public static
            void UniformMatrix2(Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniformMatrix2fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix2fvARB")]
            public static
            unsafe void UniformMatrix2(Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniformMatrix2fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix3fvARB")]
            public static
            void UniformMatrix3(Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniformMatrix3fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix3fvARB")]
            public static
            void UniformMatrix3(Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniformMatrix3fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix3fvARB")]
            public static
            unsafe void UniformMatrix3(Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniformMatrix3fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix4fvARB")]
            public static
            void UniformMatrix4(Int32 location, Int32 count, bool transpose, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glUniformMatrix4fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix4fvARB")]
            public static
            void UniformMatrix4(Int32 location, Int32 count, bool transpose, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glUniformMatrix4fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUniformMatrix4fvARB")]
            public static
            unsafe void UniformMatrix4(Int32 location, Int32 count, bool transpose, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUniformMatrix4fvARB((Int32)location, (Int32)count, (bool)transpose, (Single*)value);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBufferObject", Version = "1.2", EntryPoint = "glUnmapBufferARB")]
            public static
            bool UnmapBuffer(OpenTK.Graphics.OpenGL.BufferTargetArb target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glUnmapBufferARB((OpenTK.Graphics.OpenGL.BufferTargetArb)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUseProgramObjectARB")]
            public static
            void UseProgramObject(Int32 programObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUseProgramObjectARB((UInt32)programObj);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glUseProgramObjectARB")]
            public static
            void UseProgramObject(UInt32 programObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUseProgramObjectARB((UInt32)programObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Validates a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program object to be validated.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glValidateProgramARB")]
            public static
            void ValidateProgram(Int32 programObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glValidateProgramARB((UInt32)programObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Validates a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the handle of the program object to be validated.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbShaderObjects", Version = "1.2", EntryPoint = "glValidateProgramARB")]
            public static
            void ValidateProgram(UInt32 programObj)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glValidateProgramARB((UInt32)programObj);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1dARB")]
            public static
            void VertexAttrib1(Int32 index, Double x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dARB((UInt32)index, (Double)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1dARB")]
            public static
            void VertexAttrib1(UInt32 index, Double x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dARB((UInt32)index, (Double)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1dvARB")]
            public static
            unsafe void VertexAttrib1(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1dvARB")]
            public static
            unsafe void VertexAttrib1(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1fARB")]
            public static
            void VertexAttrib1(Int32 index, Single x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fARB((UInt32)index, (Single)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1fARB")]
            public static
            void VertexAttrib1(UInt32 index, Single x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fARB((UInt32)index, (Single)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1fvARB")]
            public static
            unsafe void VertexAttrib1(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1fvARB")]
            public static
            unsafe void VertexAttrib1(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1sARB")]
            public static
            void VertexAttrib1(Int32 index, Int16 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1sARB((UInt32)index, (Int16)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1sARB")]
            public static
            void VertexAttrib1(UInt32 index, Int16 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1sARB((UInt32)index, (Int16)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1svARB")]
            public static
            unsafe void VertexAttrib1(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib1svARB")]
            public static
            unsafe void VertexAttrib1(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dARB")]
            public static
            void VertexAttrib2(Int32 index, Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dARB((UInt32)index, (Double)x, (Double)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dARB")]
            public static
            void VertexAttrib2(UInt32 index, Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dARB((UInt32)index, (Double)x, (Double)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dvARB")]
            public static
            void VertexAttrib2(Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dvARB")]
            public static
            void VertexAttrib2(Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dvARB")]
            public static
            unsafe void VertexAttrib2(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dvARB")]
            public static
            void VertexAttrib2(UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dvARB")]
            public static
            void VertexAttrib2(UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2dvARB")]
            public static
            unsafe void VertexAttrib2(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fARB")]
            public static
            void VertexAttrib2(Int32 index, Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fARB((UInt32)index, (Single)x, (Single)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fARB")]
            public static
            void VertexAttrib2(UInt32 index, Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fARB((UInt32)index, (Single)x, (Single)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fvARB")]
            public static
            void VertexAttrib2(Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fvARB")]
            public static
            void VertexAttrib2(Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fvARB")]
            public static
            unsafe void VertexAttrib2(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fvARB")]
            public static
            void VertexAttrib2(UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fvARB")]
            public static
            void VertexAttrib2(UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2fvARB")]
            public static
            unsafe void VertexAttrib2(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2sARB")]
            public static
            void VertexAttrib2(Int32 index, Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2sARB((UInt32)index, (Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2sARB")]
            public static
            void VertexAttrib2(UInt32 index, Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2sARB((UInt32)index, (Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2svARB")]
            public static
            void VertexAttrib2(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2svARB")]
            public static
            void VertexAttrib2(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2svARB")]
            public static
            unsafe void VertexAttrib2(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2svARB")]
            public static
            void VertexAttrib2(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2svARB")]
            public static
            void VertexAttrib2(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib2svARB")]
            public static
            unsafe void VertexAttrib2(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dARB")]
            public static
            void VertexAttrib3(Int32 index, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dARB((UInt32)index, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dARB")]
            public static
            void VertexAttrib3(UInt32 index, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dARB((UInt32)index, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dvARB")]
            public static
            void VertexAttrib3(Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dvARB")]
            public static
            void VertexAttrib3(Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dvARB")]
            public static
            unsafe void VertexAttrib3(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dvARB")]
            public static
            void VertexAttrib3(UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dvARB")]
            public static
            void VertexAttrib3(UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3dvARB")]
            public static
            unsafe void VertexAttrib3(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fARB")]
            public static
            void VertexAttrib3(Int32 index, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fARB((UInt32)index, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fARB")]
            public static
            void VertexAttrib3(UInt32 index, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fARB((UInt32)index, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fvARB")]
            public static
            void VertexAttrib3(Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fvARB")]
            public static
            void VertexAttrib3(Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fvARB")]
            public static
            unsafe void VertexAttrib3(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fvARB")]
            public static
            void VertexAttrib3(UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fvARB")]
            public static
            void VertexAttrib3(UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3fvARB")]
            public static
            unsafe void VertexAttrib3(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3sARB")]
            public static
            void VertexAttrib3(Int32 index, Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3sARB((UInt32)index, (Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3sARB")]
            public static
            void VertexAttrib3(UInt32 index, Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3sARB((UInt32)index, (Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3svARB")]
            public static
            void VertexAttrib3(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3svARB")]
            public static
            void VertexAttrib3(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3svARB")]
            public static
            unsafe void VertexAttrib3(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3svARB")]
            public static
            void VertexAttrib3(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3svARB")]
            public static
            void VertexAttrib3(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib3svARB")]
            public static
            unsafe void VertexAttrib3(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4bvARB")]
            public static
            void VertexAttrib4(UInt32 index, SByte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4bvARB((UInt32)index, (SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4bvARB")]
            public static
            void VertexAttrib4(UInt32 index, ref SByte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4bvARB((UInt32)index, (SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4bvARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, SByte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4bvARB((UInt32)index, (SByte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dARB")]
            public static
            void VertexAttrib4(Int32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dARB((UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dARB")]
            public static
            void VertexAttrib4(UInt32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dARB((UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dvARB")]
            public static
            void VertexAttrib4(Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dvARB")]
            public static
            void VertexAttrib4(Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dvARB")]
            public static
            unsafe void VertexAttrib4(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dvARB")]
            public static
            void VertexAttrib4(UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dvARB")]
            public static
            void VertexAttrib4(UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4dvARB((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4dvARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dvARB((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fARB")]
            public static
            void VertexAttrib4(Int32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fARB((UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fARB")]
            public static
            void VertexAttrib4(UInt32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fARB((UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fvARB")]
            public static
            void VertexAttrib4(Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fvARB")]
            public static
            void VertexAttrib4(Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fvARB")]
            public static
            unsafe void VertexAttrib4(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fvARB")]
            public static
            void VertexAttrib4(UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fvARB")]
            public static
            void VertexAttrib4(UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4fvARB((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4fvARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fvARB((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ivARB")]
            public static
            void VertexAttrib4(Int32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4ivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ivARB")]
            public static
            void VertexAttrib4(Int32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4ivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ivARB")]
            public static
            unsafe void VertexAttrib4(Int32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ivARB((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ivARB")]
            public static
            void VertexAttrib4(UInt32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4ivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ivARB")]
            public static
            void VertexAttrib4(UInt32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4ivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ivARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ivARB((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NbvARB")]
            public static
            void VertexAttrib4N(UInt32 index, SByte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NbvARB((UInt32)index, (SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NbvARB")]
            public static
            void VertexAttrib4N(UInt32 index, ref SByte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NbvARB((UInt32)index, (SByte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NbvARB")]
            public static
            unsafe void VertexAttrib4N(UInt32 index, SByte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NbvARB((UInt32)index, (SByte*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NivARB")]
            public static
            void VertexAttrib4N(Int32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NivARB")]
            public static
            void VertexAttrib4N(Int32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NivARB")]
            public static
            unsafe void VertexAttrib4N(Int32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NivARB((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NivARB")]
            public static
            void VertexAttrib4N(UInt32 index, Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NivARB")]
            public static
            void VertexAttrib4N(UInt32 index, ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NivARB((UInt32)index, (Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NivARB")]
            public static
            unsafe void VertexAttrib4N(UInt32 index, Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NivARB((UInt32)index, (Int32*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NsvARB")]
            public static
            void VertexAttrib4N(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NsvARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NsvARB")]
            public static
            void VertexAttrib4N(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NsvARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NsvARB")]
            public static
            unsafe void VertexAttrib4N(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NsvARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NsvARB")]
            public static
            void VertexAttrib4N(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NsvARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NsvARB")]
            public static
            void VertexAttrib4N(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NsvARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NsvARB")]
            public static
            unsafe void VertexAttrib4N(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NsvARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubARB")]
            public static
            void VertexAttrib4N(Int32 index, Byte x, Byte y, Byte z, Byte w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NubARB((UInt32)index, (Byte)x, (Byte)y, (Byte)z, (Byte)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubARB")]
            public static
            void VertexAttrib4N(UInt32 index, Byte x, Byte y, Byte z, Byte w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NubARB((UInt32)index, (Byte)x, (Byte)y, (Byte)z, (Byte)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubvARB")]
            public static
            void VertexAttrib4N(Int32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubvARB")]
            public static
            void VertexAttrib4N(Int32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubvARB")]
            public static
            unsafe void VertexAttrib4N(Int32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NubvARB((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubvARB")]
            public static
            void VertexAttrib4N(UInt32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubvARB")]
            public static
            void VertexAttrib4N(UInt32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NubvARB")]
            public static
            unsafe void VertexAttrib4N(UInt32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NubvARB((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NuivARB")]
            public static
            void VertexAttrib4N(UInt32 index, UInt32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NuivARB((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NuivARB")]
            public static
            void VertexAttrib4N(UInt32 index, ref UInt32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NuivARB((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NuivARB")]
            public static
            unsafe void VertexAttrib4N(UInt32 index, UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NuivARB((UInt32)index, (UInt32*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NusvARB")]
            public static
            void VertexAttrib4N(UInt32 index, UInt16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4NusvARB((UInt32)index, (UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NusvARB")]
            public static
            void VertexAttrib4N(UInt32 index, ref UInt16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4NusvARB((UInt32)index, (UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4NusvARB")]
            public static
            unsafe void VertexAttrib4N(UInt32 index, UInt16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4NusvARB((UInt32)index, (UInt16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4sARB")]
            public static
            void VertexAttrib4(Int32 index, Int16 x, Int16 y, Int16 z, Int16 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4sARB((UInt32)index, (Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4sARB")]
            public static
            void VertexAttrib4(UInt32 index, Int16 x, Int16 y, Int16 z, Int16 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4sARB((UInt32)index, (Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4svARB")]
            public static
            void VertexAttrib4(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4svARB")]
            public static
            void VertexAttrib4(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4svARB")]
            public static
            unsafe void VertexAttrib4(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4svARB")]
            public static
            void VertexAttrib4(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4svARB")]
            public static
            void VertexAttrib4(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4svARB((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4svARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4svARB((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ubvARB")]
            public static
            void VertexAttrib4(Int32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4ubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ubvARB")]
            public static
            void VertexAttrib4(Int32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4ubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ubvARB")]
            public static
            unsafe void VertexAttrib4(Int32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ubvARB((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ubvARB")]
            public static
            void VertexAttrib4(UInt32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4ubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ubvARB")]
            public static
            void VertexAttrib4(UInt32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4ubvARB((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4ubvARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ubvARB((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4uivARB")]
            public static
            void VertexAttrib4(UInt32 index, UInt32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4uivARB((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4uivARB")]
            public static
            void VertexAttrib4(UInt32 index, ref UInt32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4uivARB((UInt32)index, (UInt32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4uivARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, UInt32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4uivARB((UInt32)index, (UInt32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4usvARB")]
            public static
            void VertexAttrib4(UInt32 index, UInt16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4usvARB((UInt32)index, (UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4usvARB")]
            public static
            void VertexAttrib4(UInt32 index, ref UInt16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4usvARB((UInt32)index, (UInt16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttrib4usvARB")]
            public static
            unsafe void VertexAttrib4(UInt32 index, UInt16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4usvARB((UInt32)index, (UInt16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbInstancedArrays", Version = "2.0", EntryPoint = "glVertexAttribDivisorARB")]
            public static
            void VertexAttribDivisor(Int32 index, Int32 divisor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribDivisorARB((UInt32)index, (UInt32)divisor);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbInstancedArrays", Version = "2.0", EntryPoint = "glVertexAttribDivisorARB")]
            public static
            void VertexAttribDivisor(UInt32 index, UInt32 divisor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribDivisorARB((UInt32)index, (UInt32)divisor);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[] pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,] pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,,] pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] ref T5 pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T5)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[] pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,] pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] T5[,,] pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexProgram", Version = "1.3", EntryPoint = "glVertexAttribPointerARB")]
            public static
            void VertexAttribPointer<T5>(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb type, bool normalized, Int32 stride, [InAttribute, OutAttribute] ref T5 pointer)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerARB((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.VertexAttribPointerTypeArb)type, (bool)normalized, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T5)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glVertexBlendARB")]
            public static
            void VertexBlend(Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexBlendARB((Int32)count);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightbvARB")]
            public static
            void Weight(Int32 size, SByte[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* weights_ptr = weights)
                        {
                            Delegates.glWeightbvARB((Int32)size, (SByte*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightbvARB")]
            public static
            void Weight(Int32 size, ref SByte weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* weights_ptr = &weights)
                        {
                            Delegates.glWeightbvARB((Int32)size, (SByte*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightbvARB")]
            public static
            unsafe void Weight(Int32 size, SByte* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightbvARB((Int32)size, (SByte*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightdvARB")]
            public static
            void Weight(Int32 size, Double[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* weights_ptr = weights)
                        {
                            Delegates.glWeightdvARB((Int32)size, (Double*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightdvARB")]
            public static
            void Weight(Int32 size, ref Double weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* weights_ptr = &weights)
                        {
                            Delegates.glWeightdvARB((Int32)size, (Double*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightdvARB")]
            public static
            unsafe void Weight(Int32 size, Double* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightdvARB((Int32)size, (Double*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightfvARB")]
            public static
            void Weight(Int32 size, Single[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* weights_ptr = weights)
                        {
                            Delegates.glWeightfvARB((Int32)size, (Single*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightfvARB")]
            public static
            void Weight(Int32 size, ref Single weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* weights_ptr = &weights)
                        {
                            Delegates.glWeightfvARB((Int32)size, (Single*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightfvARB")]
            public static
            unsafe void Weight(Int32 size, Single* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightfvARB((Int32)size, (Single*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightivARB")]
            public static
            void Weight(Int32 size, Int32[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* weights_ptr = weights)
                        {
                            Delegates.glWeightivARB((Int32)size, (Int32*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightivARB")]
            public static
            void Weight(Int32 size, ref Int32 weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* weights_ptr = &weights)
                        {
                            Delegates.glWeightivARB((Int32)size, (Int32*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightivARB")]
            public static
            unsafe void Weight(Int32 size, Int32* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightivARB((Int32)size, (Int32*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightPointerARB")]
            public static
            void WeightPointer(Int32 size, OpenTK.Graphics.OpenGL.ArbVertexBlend type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbVertexBlend)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightPointerARB")]
            public static
            void WeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbVertexBlend type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glWeightPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbVertexBlend)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightPointerARB")]
            public static
            void WeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbVertexBlend type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glWeightPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbVertexBlend)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightPointerARB")]
            public static
            void WeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbVertexBlend type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glWeightPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbVertexBlend)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightPointerARB")]
            public static
            void WeightPointer<T3>(Int32 size, OpenTK.Graphics.OpenGL.ArbVertexBlend type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glWeightPointerARB((Int32)size, (OpenTK.Graphics.OpenGL.ArbVertexBlend)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightsvARB")]
            public static
            void Weight(Int32 size, Int16[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* weights_ptr = weights)
                        {
                            Delegates.glWeightsvARB((Int32)size, (Int16*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightsvARB")]
            public static
            void Weight(Int32 size, ref Int16 weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* weights_ptr = &weights)
                        {
                            Delegates.glWeightsvARB((Int32)size, (Int16*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightsvARB")]
            public static
            unsafe void Weight(Int32 size, Int16* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightsvARB((Int32)size, (Int16*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightubvARB")]
            public static
            void Weight(Int32 size, Byte[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* weights_ptr = weights)
                        {
                            Delegates.glWeightubvARB((Int32)size, (Byte*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightubvARB")]
            public static
            void Weight(Int32 size, ref Byte weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* weights_ptr = &weights)
                        {
                            Delegates.glWeightubvARB((Int32)size, (Byte*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightubvARB")]
            public static
            unsafe void Weight(Int32 size, Byte* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightubvARB((Int32)size, (Byte*)weights);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightuivARB")]
            public static
            void Weight(Int32 size, UInt32[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* weights_ptr = weights)
                        {
                            Delegates.glWeightuivARB((Int32)size, (UInt32*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightuivARB")]
            public static
            void Weight(Int32 size, ref UInt32 weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* weights_ptr = &weights)
                        {
                            Delegates.glWeightuivARB((Int32)size, (UInt32*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightuivARB")]
            public static
            unsafe void Weight(Int32 size, UInt32* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightuivARB((Int32)size, (UInt32*)weights);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightusvARB")]
            public static
            void Weight(Int32 size, UInt16[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* weights_ptr = weights)
                        {
                            Delegates.glWeightusvARB((Int32)size, (UInt16*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightusvARB")]
            public static
            void Weight(Int32 size, ref UInt16 weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* weights_ptr = &weights)
                        {
                            Delegates.glWeightusvARB((Int32)size, (UInt16*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbVertexBlend", Version = "1.1", EntryPoint = "glWeightusvARB")]
            public static
            unsafe void Weight(Int32 size, UInt16* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWeightusvARB((Int32)size, (UInt16*)weights);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dARB")]
            public static
            void WindowPos2(Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2dARB((Double)x, (Double)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dvARB")]
            public static
            void WindowPos2(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glWindowPos2dvARB((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dvARB")]
            public static
            void WindowPos2(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glWindowPos2dvARB((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dvARB")]
            public static
            unsafe void WindowPos2(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2dvARB((Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fARB")]
            public static
            void WindowPos2(Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2fARB((Single)x, (Single)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fvARB")]
            public static
            void WindowPos2(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glWindowPos2fvARB((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fvARB")]
            public static
            void WindowPos2(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glWindowPos2fvARB((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fvARB")]
            public static
            unsafe void WindowPos2(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2fvARB((Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2iARB")]
            public static
            void WindowPos2(Int32 x, Int32 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2iARB((Int32)x, (Int32)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2ivARB")]
            public static
            void WindowPos2(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glWindowPos2ivARB((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2ivARB")]
            public static
            void WindowPos2(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glWindowPos2ivARB((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2ivARB")]
            public static
            unsafe void WindowPos2(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2ivARB((Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2sARB")]
            public static
            void WindowPos2(Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2sARB((Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2svARB")]
            public static
            void WindowPos2(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glWindowPos2svARB((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2svARB")]
            public static
            void WindowPos2(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glWindowPos2svARB((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos2svARB")]
            public static
            unsafe void WindowPos2(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2svARB((Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dARB")]
            public static
            void WindowPos3(Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3dARB((Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dvARB")]
            public static
            void WindowPos3(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glWindowPos3dvARB((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dvARB")]
            public static
            void WindowPos3(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glWindowPos3dvARB((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dvARB")]
            public static
            unsafe void WindowPos3(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3dvARB((Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fARB")]
            public static
            void WindowPos3(Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3fARB((Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fvARB")]
            public static
            void WindowPos3(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glWindowPos3fvARB((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fvARB")]
            public static
            void WindowPos3(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glWindowPos3fvARB((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fvARB")]
            public static
            unsafe void WindowPos3(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3fvARB((Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3iARB")]
            public static
            void WindowPos3(Int32 x, Int32 y, Int32 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3iARB((Int32)x, (Int32)y, (Int32)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3ivARB")]
            public static
            void WindowPos3(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glWindowPos3ivARB((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3ivARB")]
            public static
            void WindowPos3(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glWindowPos3ivARB((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3ivARB")]
            public static
            unsafe void WindowPos3(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3ivARB((Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3sARB")]
            public static
            void WindowPos3(Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3sARB((Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3svARB")]
            public static
            void WindowPos3(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glWindowPos3svARB((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3svARB")]
            public static
            void WindowPos3(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glWindowPos3svARB((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "ArbWindowPos", Version = "1.0", EntryPoint = "glWindowPos3svARB")]
            public static
            unsafe void WindowPos3(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3svARB((Int16*)v);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Ati
        {
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glAlphaFragmentOp1ATI")]
            public static
            void AlphaFragmentOp1(OpenTK.Graphics.OpenGL.AtiFragmentShader op, Int32 dst, Int32 dstMod, Int32 arg1, Int32 arg1Rep, Int32 arg1Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAlphaFragmentOp1ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glAlphaFragmentOp1ATI")]
            public static
            void AlphaFragmentOp1(OpenTK.Graphics.OpenGL.AtiFragmentShader op, UInt32 dst, UInt32 dstMod, UInt32 arg1, UInt32 arg1Rep, UInt32 arg1Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAlphaFragmentOp1ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glAlphaFragmentOp2ATI")]
            public static
            void AlphaFragmentOp2(OpenTK.Graphics.OpenGL.AtiFragmentShader op, Int32 dst, Int32 dstMod, Int32 arg1, Int32 arg1Rep, Int32 arg1Mod, Int32 arg2, Int32 arg2Rep, Int32 arg2Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAlphaFragmentOp2ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glAlphaFragmentOp2ATI")]
            public static
            void AlphaFragmentOp2(OpenTK.Graphics.OpenGL.AtiFragmentShader op, UInt32 dst, UInt32 dstMod, UInt32 arg1, UInt32 arg1Rep, UInt32 arg1Mod, UInt32 arg2, UInt32 arg2Rep, UInt32 arg2Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAlphaFragmentOp2ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glAlphaFragmentOp3ATI")]
            public static
            void AlphaFragmentOp3(OpenTK.Graphics.OpenGL.AtiFragmentShader op, Int32 dst, Int32 dstMod, Int32 arg1, Int32 arg1Rep, Int32 arg1Mod, Int32 arg2, Int32 arg2Rep, Int32 arg2Mod, Int32 arg3, Int32 arg3Rep, Int32 arg3Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAlphaFragmentOp3ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod, (UInt32)arg3, (UInt32)arg3Rep, (UInt32)arg3Mod);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glAlphaFragmentOp3ATI")]
            public static
            void AlphaFragmentOp3(OpenTK.Graphics.OpenGL.AtiFragmentShader op, UInt32 dst, UInt32 dstMod, UInt32 arg1, UInt32 arg1Rep, UInt32 arg1Mod, UInt32 arg2, UInt32 arg2Rep, UInt32 arg2Mod, UInt32 arg3, UInt32 arg3Rep, UInt32 arg3Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAlphaFragmentOp3ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod, (UInt32)arg3, (UInt32)arg3Rep, (UInt32)arg3Mod);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glArrayObjectATI")]
            public static
            void ArrayObject(OpenTK.Graphics.OpenGL.EnableCap array, Int32 size, OpenTK.Graphics.OpenGL.AtiVertexArrayObject type, Int32 stride, Int32 buffer, Int32 offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glArrayObjectATI((OpenTK.Graphics.OpenGL.EnableCap)array, (Int32)size, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)type, (Int32)stride, (UInt32)buffer, (UInt32)offset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glArrayObjectATI")]
            public static
            void ArrayObject(OpenTK.Graphics.OpenGL.EnableCap array, Int32 size, OpenTK.Graphics.OpenGL.AtiVertexArrayObject type, Int32 stride, UInt32 buffer, UInt32 offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glArrayObjectATI((OpenTK.Graphics.OpenGL.EnableCap)array, (Int32)size, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)type, (Int32)stride, (UInt32)buffer, (UInt32)offset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glBeginFragmentShaderATI")]
            public static
            void BeginFragmentShader()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginFragmentShaderATI();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glBindFragmentShaderATI")]
            public static
            void BindFragmentShader(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindFragmentShaderATI((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glBindFragmentShaderATI")]
            public static
            void BindFragmentShader(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindFragmentShaderATI((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glClientActiveVertexStreamATI")]
            public static
            void ClientActiveVertexStream(OpenTK.Graphics.OpenGL.AtiVertexStreams stream)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClientActiveVertexStreamATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glColorFragmentOp1ATI")]
            public static
            void ColorFragmentOp1(OpenTK.Graphics.OpenGL.AtiFragmentShader op, Int32 dst, Int32 dstMask, Int32 dstMod, Int32 arg1, Int32 arg1Rep, Int32 arg1Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorFragmentOp1ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMask, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glColorFragmentOp1ATI")]
            public static
            void ColorFragmentOp1(OpenTK.Graphics.OpenGL.AtiFragmentShader op, UInt32 dst, UInt32 dstMask, UInt32 dstMod, UInt32 arg1, UInt32 arg1Rep, UInt32 arg1Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorFragmentOp1ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMask, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glColorFragmentOp2ATI")]
            public static
            void ColorFragmentOp2(OpenTK.Graphics.OpenGL.AtiFragmentShader op, Int32 dst, Int32 dstMask, Int32 dstMod, Int32 arg1, Int32 arg1Rep, Int32 arg1Mod, Int32 arg2, Int32 arg2Rep, Int32 arg2Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorFragmentOp2ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMask, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glColorFragmentOp2ATI")]
            public static
            void ColorFragmentOp2(OpenTK.Graphics.OpenGL.AtiFragmentShader op, UInt32 dst, UInt32 dstMask, UInt32 dstMod, UInt32 arg1, UInt32 arg1Rep, UInt32 arg1Mod, UInt32 arg2, UInt32 arg2Rep, UInt32 arg2Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorFragmentOp2ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMask, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glColorFragmentOp3ATI")]
            public static
            void ColorFragmentOp3(OpenTK.Graphics.OpenGL.AtiFragmentShader op, Int32 dst, Int32 dstMask, Int32 dstMod, Int32 arg1, Int32 arg1Rep, Int32 arg1Mod, Int32 arg2, Int32 arg2Rep, Int32 arg2Mod, Int32 arg3, Int32 arg3Rep, Int32 arg3Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorFragmentOp3ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMask, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod, (UInt32)arg3, (UInt32)arg3Rep, (UInt32)arg3Mod);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glColorFragmentOp3ATI")]
            public static
            void ColorFragmentOp3(OpenTK.Graphics.OpenGL.AtiFragmentShader op, UInt32 dst, UInt32 dstMask, UInt32 dstMod, UInt32 arg1, UInt32 arg1Rep, UInt32 arg1Mod, UInt32 arg2, UInt32 arg2Rep, UInt32 arg2Mod, UInt32 arg3, UInt32 arg3Rep, UInt32 arg3Mod)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorFragmentOp3ATI((OpenTK.Graphics.OpenGL.AtiFragmentShader)op, (UInt32)dst, (UInt32)dstMask, (UInt32)dstMod, (UInt32)arg1, (UInt32)arg1Rep, (UInt32)arg1Mod, (UInt32)arg2, (UInt32)arg2Rep, (UInt32)arg2Mod, (UInt32)arg3, (UInt32)arg3Rep, (UInt32)arg3Mod);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glDeleteFragmentShaderATI")]
            public static
            void DeleteFragmentShader(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFragmentShaderATI((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glDeleteFragmentShaderATI")]
            public static
            void DeleteFragmentShader(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFragmentShaderATI((UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "AtiDrawBuffers", Version = "1.2", EntryPoint = "glDrawBuffersATI")]
            public static
            void DrawBuffers(Int32 n, OpenTK.Graphics.OpenGL.AtiDrawBuffers[] bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.AtiDrawBuffers* bufs_ptr = bufs)
                        {
                            Delegates.glDrawBuffersATI((Int32)n, (OpenTK.Graphics.OpenGL.AtiDrawBuffers*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "AtiDrawBuffers", Version = "1.2", EntryPoint = "glDrawBuffersATI")]
            public static
            void DrawBuffers(Int32 n, ref OpenTK.Graphics.OpenGL.AtiDrawBuffers bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.AtiDrawBuffers* bufs_ptr = &bufs)
                        {
                            Delegates.glDrawBuffersATI((Int32)n, (OpenTK.Graphics.OpenGL.AtiDrawBuffers*)bufs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies a list of color buffers to be drawn into
            /// </summary>
            /// <param name="n">
            /// <para>
            /// Specifies the number of buffers in bufs.
            /// </para>
            /// </param>
            /// <param name="bufs">
            /// <para>
            /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiDrawBuffers", Version = "1.2", EntryPoint = "glDrawBuffersATI")]
            public static
            unsafe void DrawBuffers(Int32 n, OpenTK.Graphics.OpenGL.AtiDrawBuffers* bufs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawBuffersATI((Int32)n, (OpenTK.Graphics.OpenGL.AtiDrawBuffers*)bufs);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glDrawElementArrayATI")]
            public static
            void DrawElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawElementArrayATI((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)count);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glDrawRangeElementArrayATI")]
            public static
            void DrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 start, Int32 end, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawRangeElementArrayATI((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glDrawRangeElementArrayATI")]
            public static
            void DrawRangeElementArray(OpenTK.Graphics.OpenGL.BeginMode mode, UInt32 start, UInt32 end, Int32 count)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawRangeElementArrayATI((OpenTK.Graphics.OpenGL.BeginMode)mode, (UInt32)start, (UInt32)end, (Int32)count);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glElementPointerATI")]
            public static
            void ElementPointer(OpenTK.Graphics.OpenGL.AtiElementArray type, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glElementPointerATI((OpenTK.Graphics.OpenGL.AtiElementArray)type, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glElementPointerATI")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AtiElementArray type, [InAttribute, OutAttribute] T1[] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerATI((OpenTK.Graphics.OpenGL.AtiElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glElementPointerATI")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AtiElementArray type, [InAttribute, OutAttribute] T1[,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerATI((OpenTK.Graphics.OpenGL.AtiElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glElementPointerATI")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AtiElementArray type, [InAttribute, OutAttribute] T1[,,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerATI((OpenTK.Graphics.OpenGL.AtiElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiElementArray", Version = "1.2", EntryPoint = "glElementPointerATI")]
            public static
            void ElementPointer<T1>(OpenTK.Graphics.OpenGL.AtiElementArray type, [InAttribute, OutAttribute] ref T1 pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glElementPointerATI((OpenTK.Graphics.OpenGL.AtiElementArray)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T1)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glEndFragmentShaderATI")]
            public static
            void EndFragmentShader()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndFragmentShaderATI();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glFreeObjectBufferATI")]
            public static
            void FreeObjectBuffer(Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFreeObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glFreeObjectBufferATI")]
            public static
            void FreeObjectBuffer(UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFreeObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glGenFragmentShadersATI")]
            public static
            Int32 GenFragmentShaders(Int32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenFragmentShadersATI((UInt32)range);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glGenFragmentShadersATI")]
            public static
            Int32 GenFragmentShaders(UInt32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenFragmentShadersATI((UInt32)range);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetArrayObjectfvATI")]
            public static
            void GetArrayObject(OpenTK.Graphics.OpenGL.EnableCap array, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetArrayObjectfvATI((OpenTK.Graphics.OpenGL.EnableCap)array, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetArrayObjectfvATI")]
            public static
            unsafe void GetArrayObject(OpenTK.Graphics.OpenGL.EnableCap array, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetArrayObjectfvATI((OpenTK.Graphics.OpenGL.EnableCap)array, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetArrayObjectivATI")]
            public static
            void GetArrayObject(OpenTK.Graphics.OpenGL.EnableCap array, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetArrayObjectivATI((OpenTK.Graphics.OpenGL.EnableCap)array, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetArrayObjectivATI")]
            public static
            unsafe void GetArrayObject(OpenTK.Graphics.OpenGL.EnableCap array, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetArrayObjectivATI((OpenTK.Graphics.OpenGL.EnableCap)array, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferfvATI")]
            public static
            void GetObjectBuffer(Int32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectBufferfvATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferfvATI")]
            public static
            unsafe void GetObjectBuffer(Int32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectBufferfvATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferfvATI")]
            public static
            void GetObjectBuffer(UInt32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectBufferfvATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferfvATI")]
            public static
            unsafe void GetObjectBuffer(UInt32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectBufferfvATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferivATI")]
            public static
            void GetObjectBuffer(Int32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectBufferivATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferivATI")]
            public static
            unsafe void GetObjectBuffer(Int32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectBufferivATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferivATI")]
            public static
            void GetObjectBuffer(UInt32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetObjectBufferivATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetObjectBufferivATI")]
            public static
            unsafe void GetObjectBuffer(UInt32 buffer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetObjectBufferivATI((UInt32)buffer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glGetTexBumpParameterfvATI")]
            public static
            void GetTexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, [OutAttribute] Single[] param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* param_ptr = param)
                        {
                            Delegates.glGetTexBumpParameterfvATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Single*)param_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glGetTexBumpParameterfvATI")]
            public static
            void GetTexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, [OutAttribute] out Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* param_ptr = &param)
                        {
                            Delegates.glGetTexBumpParameterfvATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Single*)param_ptr);
                            param = *param_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glGetTexBumpParameterfvATI")]
            public static
            unsafe void GetTexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, [OutAttribute] Single* param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTexBumpParameterfvATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Single*)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glGetTexBumpParameterivATI")]
            public static
            void GetTexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, [OutAttribute] Int32[] param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* param_ptr = param)
                        {
                            Delegates.glGetTexBumpParameterivATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Int32*)param_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glGetTexBumpParameterivATI")]
            public static
            void GetTexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, [OutAttribute] out Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* param_ptr = &param)
                        {
                            Delegates.glGetTexBumpParameterivATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Int32*)param_ptr);
                            param = *param_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glGetTexBumpParameterivATI")]
            public static
            unsafe void GetTexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, [OutAttribute] Int32* param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTexBumpParameterivATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Int32*)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectfvATI")]
            public static
            void GetVariantArrayObject(Int32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVariantArrayObjectfvATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectfvATI")]
            public static
            unsafe void GetVariantArrayObject(Int32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantArrayObjectfvATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectfvATI")]
            public static
            void GetVariantArrayObject(UInt32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVariantArrayObjectfvATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectfvATI")]
            public static
            unsafe void GetVariantArrayObject(UInt32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantArrayObjectfvATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectivATI")]
            public static
            void GetVariantArrayObject(Int32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVariantArrayObjectivATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectivATI")]
            public static
            unsafe void GetVariantArrayObject(Int32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantArrayObjectivATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectivATI")]
            public static
            void GetVariantArrayObject(UInt32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVariantArrayObjectivATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glGetVariantArrayObjectivATI")]
            public static
            unsafe void GetVariantArrayObject(UInt32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVariantArrayObjectivATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectfvATI")]
            public static
            void GetVertexAttribArrayObject(Int32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribArrayObjectfvATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectfvATI")]
            public static
            void GetVertexAttribArrayObject(Int32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribArrayObjectfvATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectfvATI")]
            public static
            unsafe void GetVertexAttribArrayObject(Int32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribArrayObjectfvATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectfvATI")]
            public static
            void GetVertexAttribArrayObject(UInt32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribArrayObjectfvATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectfvATI")]
            public static
            void GetVertexAttribArrayObject(UInt32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribArrayObjectfvATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectfvATI")]
            public static
            unsafe void GetVertexAttribArrayObject(UInt32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribArrayObjectfvATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectivATI")]
            public static
            void GetVertexAttribArrayObject(Int32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribArrayObjectivATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectivATI")]
            public static
            void GetVertexAttribArrayObject(Int32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribArrayObjectivATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectivATI")]
            public static
            unsafe void GetVertexAttribArrayObject(Int32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribArrayObjectivATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectivATI")]
            public static
            void GetVertexAttribArrayObject(UInt32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetVertexAttribArrayObjectivATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectivATI")]
            public static
            void GetVertexAttribArrayObject(UInt32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribArrayObjectivATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glGetVertexAttribArrayObjectivATI")]
            public static
            unsafe void GetVertexAttribArrayObject(UInt32 index, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribArrayObjectivATI((UInt32)index, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glIsObjectBufferATI")]
            public static
            bool IsObjectBuffer(Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glIsObjectBufferATI")]
            public static
            bool IsObjectBuffer(UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiMapObjectBuffer", Version = "1.2", EntryPoint = "glMapObjectBufferATI")]
            public static
            unsafe System.IntPtr MapObjectBuffer(Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glMapObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiMapObjectBuffer", Version = "1.2", EntryPoint = "glMapObjectBufferATI")]
            public static
            unsafe System.IntPtr MapObjectBuffer(UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glMapObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glNewObjectBufferATI")]
            public static
            Int32 NewObjectBuffer(Int32 size, IntPtr pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject usage)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glNewObjectBufferATI((Int32)size, (IntPtr)pointer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)usage);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glNewObjectBufferATI")]
            public static
            Int32 NewObjectBuffer<T1>(Int32 size, [InAttribute, OutAttribute] T1[] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject usage)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        return Delegates.glNewObjectBufferATI((Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)usage);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glNewObjectBufferATI")]
            public static
            Int32 NewObjectBuffer<T1>(Int32 size, [InAttribute, OutAttribute] T1[,] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject usage)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        return Delegates.glNewObjectBufferATI((Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)usage);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glNewObjectBufferATI")]
            public static
            Int32 NewObjectBuffer<T1>(Int32 size, [InAttribute, OutAttribute] T1[,,] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject usage)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        return Delegates.glNewObjectBufferATI((Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)usage);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glNewObjectBufferATI")]
            public static
            Int32 NewObjectBuffer<T1>(Int32 size, [InAttribute, OutAttribute] ref T1 pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject usage)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Int32 retval = Delegates.glNewObjectBufferATI((Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)usage);
                        pointer = (T1)pointer_ptr.Target;
                        return retval;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Byte nx, Byte ny, Byte nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3bATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte)nx, (SByte)ny, (SByte)nz);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, SByte nx, SByte ny, SByte nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3bATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte)nx, (SByte)ny, (SByte)nz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Byte[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* coords_ptr = coords)
                        {
                            Delegates.glNormalStream3bvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Byte coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* coords_ptr = &coords)
                        {
                            Delegates.glNormalStream3bvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bvATI")]
            public static
            unsafe void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Byte* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3bvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte*)coords);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, SByte[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* coords_ptr = coords)
                        {
                            Delegates.glNormalStream3bvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref SByte coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (SByte* coords_ptr = &coords)
                        {
                            Delegates.glNormalStream3bvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3bvATI")]
            public static
            unsafe void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, SByte* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3bvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (SByte*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3dATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double nx, Double ny, Double nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3dATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double)nx, (Double)ny, (Double)nz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3dvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = coords)
                        {
                            Delegates.glNormalStream3dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3dvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Double coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = &coords)
                        {
                            Delegates.glNormalStream3dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3dvATI")]
            public static
            unsafe void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3fATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single nx, Single ny, Single nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3fATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single)nx, (Single)ny, (Single)nz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3fvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = coords)
                        {
                            Delegates.glNormalStream3fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3fvATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Single coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = &coords)
                        {
                            Delegates.glNormalStream3fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3fvATI")]
            public static
            unsafe void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3iATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32 nx, Int32 ny, Int32 nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3iATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32)nx, (Int32)ny, (Int32)nz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3ivATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = coords)
                        {
                            Delegates.glNormalStream3ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3ivATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int32 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = &coords)
                        {
                            Delegates.glNormalStream3ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3ivATI")]
            public static
            unsafe void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3sATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16 nx, Int16 ny, Int16 nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3sATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16)nx, (Int16)ny, (Int16)nz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3svATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = coords)
                        {
                            Delegates.glNormalStream3svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3svATI")]
            public static
            void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int16 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = &coords)
                        {
                            Delegates.glNormalStream3svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glNormalStream3svATI")]
            public static
            unsafe void NormalStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalStream3svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glPassTexCoordATI")]
            public static
            void PassTexCoor(Int32 dst, Int32 coord, OpenTK.Graphics.OpenGL.AtiFragmentShader swizzle)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPassTexCoordATI((UInt32)dst, (UInt32)coord, (OpenTK.Graphics.OpenGL.AtiFragmentShader)swizzle);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glPassTexCoordATI")]
            public static
            void PassTexCoor(UInt32 dst, UInt32 coord, OpenTK.Graphics.OpenGL.AtiFragmentShader swizzle)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPassTexCoordATI((UInt32)dst, (UInt32)coord, (OpenTK.Graphics.OpenGL.AtiFragmentShader)swizzle);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiPnTriangles", Version = "1.2", EntryPoint = "glPNTrianglesfATI")]
            public static
            void PNTriangles(OpenTK.Graphics.OpenGL.AtiPnTriangles pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPNTrianglesfATI((OpenTK.Graphics.OpenGL.AtiPnTriangles)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiPnTriangles", Version = "1.2", EntryPoint = "glPNTrianglesiATI")]
            public static
            void PNTriangles(OpenTK.Graphics.OpenGL.AtiPnTriangles pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPNTrianglesiATI((OpenTK.Graphics.OpenGL.AtiPnTriangles)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSampleMapATI")]
            public static
            void SampleMap(Int32 dst, Int32 interp, OpenTK.Graphics.OpenGL.AtiFragmentShader swizzle)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleMapATI((UInt32)dst, (UInt32)interp, (OpenTK.Graphics.OpenGL.AtiFragmentShader)swizzle);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSampleMapATI")]
            public static
            void SampleMap(UInt32 dst, UInt32 interp, OpenTK.Graphics.OpenGL.AtiFragmentShader swizzle)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleMapATI((UInt32)dst, (UInt32)interp, (OpenTK.Graphics.OpenGL.AtiFragmentShader)swizzle);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSetFragmentShaderConstantATI")]
            public static
            void SetFragmentShaderConstant(Int32 dst, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glSetFragmentShaderConstantATI((UInt32)dst, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSetFragmentShaderConstantATI")]
            public static
            void SetFragmentShaderConstant(Int32 dst, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glSetFragmentShaderConstantATI((UInt32)dst, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSetFragmentShaderConstantATI")]
            public static
            unsafe void SetFragmentShaderConstant(Int32 dst, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetFragmentShaderConstantATI((UInt32)dst, (Single*)value);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSetFragmentShaderConstantATI")]
            public static
            void SetFragmentShaderConstant(UInt32 dst, Single[] value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = value)
                        {
                            Delegates.glSetFragmentShaderConstantATI((UInt32)dst, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSetFragmentShaderConstantATI")]
            public static
            void SetFragmentShaderConstant(UInt32 dst, ref Single value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* value_ptr = &value)
                        {
                            Delegates.glSetFragmentShaderConstantATI((UInt32)dst, (Single*)value_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiFragmentShader", Version = "1.2", EntryPoint = "glSetFragmentShaderConstantATI")]
            public static
            unsafe void SetFragmentShaderConstant(UInt32 dst, Single* value)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetFragmentShaderConstantATI((UInt32)dst, (Single*)value);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set front and/or back function and reference value for stencil testing
            /// </summary>
            /// <param name="face">
            /// <para>
            /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
            /// </para>
            /// </param>
            /// <param name="func">
            /// <para>
            /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
            /// </para>
            /// </param>
            /// <param name="ref">
            /// <para>
            /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="mask">
            /// <para>
            /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "AtiSeparateStencil", Version = "1.2", EntryPoint = "glStencilFuncSeparateATI")]
            public static
            void StencilFuncSeparate(OpenTK.Graphics.OpenGL.StencilFunction frontfunc, OpenTK.Graphics.OpenGL.StencilFunction backfunc, Int32 @ref, Int32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glStencilFuncSeparateATI((OpenTK.Graphics.OpenGL.StencilFunction)frontfunc, (OpenTK.Graphics.OpenGL.StencilFunction)backfunc, (Int32)@ref, (UInt32)mask);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set front and/or back function and reference value for stencil testing
            /// </summary>
            /// <param name="face">
            /// <para>
            /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
            /// </para>
            /// </param>
            /// <param name="func">
            /// <para>
            /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
            /// </para>
            /// </param>
            /// <param name="ref">
            /// <para>
            /// Specifies the reference value for the stencil test. ref is clamped to the range [0, 2 sup n - 1], where is the number of bitplanes in the stencil buffer. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="mask">
            /// <para>
            /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiSeparateStencil", Version = "1.2", EntryPoint = "glStencilFuncSeparateATI")]
            public static
            void StencilFuncSeparate(OpenTK.Graphics.OpenGL.StencilFunction frontfunc, OpenTK.Graphics.OpenGL.StencilFunction backfunc, Int32 @ref, UInt32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glStencilFuncSeparateATI((OpenTK.Graphics.OpenGL.StencilFunction)frontfunc, (OpenTK.Graphics.OpenGL.StencilFunction)backfunc, (Int32)@ref, (UInt32)mask);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set front and/or back stencil test actions
            /// </summary>
            /// <param name="face">
            /// <para>
            /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
            /// </para>
            /// </param>
            /// <param name="sfail">
            /// <para>
            /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.
            /// </para>
            /// </param>
            /// <param name="dpfail">
            /// <para>
            /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
            /// </para>
            /// </param>
            /// <param name="dppass">
            /// <para>
            /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "AtiSeparateStencil", Version = "1.2", EntryPoint = "glStencilOpSeparateATI")]
            public static
            void StencilOpSeparate(OpenTK.Graphics.OpenGL.AtiSeparateStencil face, OpenTK.Graphics.OpenGL.StencilOp sfail, OpenTK.Graphics.OpenGL.StencilOp dpfail, OpenTK.Graphics.OpenGL.StencilOp dppass)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glStencilOpSeparateATI((OpenTK.Graphics.OpenGL.AtiSeparateStencil)face, (OpenTK.Graphics.OpenGL.StencilOp)sfail, (OpenTK.Graphics.OpenGL.StencilOp)dpfail, (OpenTK.Graphics.OpenGL.StencilOp)dppass);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glTexBumpParameterfvATI")]
            public static
            void TexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, Single[] param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* param_ptr = param)
                        {
                            Delegates.glTexBumpParameterfvATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Single*)param_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glTexBumpParameterfvATI")]
            public static
            void TexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, ref Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* param_ptr = &param)
                        {
                            Delegates.glTexBumpParameterfvATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Single*)param_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glTexBumpParameterfvATI")]
            public static
            unsafe void TexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, Single* param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexBumpParameterfvATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Single*)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glTexBumpParameterivATI")]
            public static
            void TexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, Int32[] param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* param_ptr = param)
                        {
                            Delegates.glTexBumpParameterivATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Int32*)param_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glTexBumpParameterivATI")]
            public static
            void TexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, ref Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* param_ptr = &param)
                        {
                            Delegates.glTexBumpParameterivATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Int32*)param_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiEnvmapBumpmap", Version = "1.2", EntryPoint = "glTexBumpParameterivATI")]
            public static
            unsafe void TexBumpParameter(OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap pname, Int32* param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexBumpParameterivATI((OpenTK.Graphics.OpenGL.AtiEnvmapBumpmap)pname, (Int32*)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiMapObjectBuffer", Version = "1.2", EntryPoint = "glUnmapObjectBufferATI")]
            public static
            void UnmapObjectBuffer(Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUnmapObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiMapObjectBuffer", Version = "1.2", EntryPoint = "glUnmapObjectBufferATI")]
            public static
            void UnmapObjectBuffer(UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUnmapObjectBufferATI((UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer(Int32 buffer, Int32 offset, Int32 size, IntPtr pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(Int32 buffer, Int32 offset, Int32 size, [InAttribute, OutAttribute] T3[] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(Int32 buffer, Int32 offset, Int32 size, [InAttribute, OutAttribute] T3[,] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(Int32 buffer, Int32 offset, Int32 size, [InAttribute, OutAttribute] T3[,,] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(Int32 buffer, Int32 offset, Int32 size, [InAttribute, OutAttribute] ref T3 pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer(UInt32 buffer, UInt32 offset, Int32 size, IntPtr pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(UInt32 buffer, UInt32 offset, Int32 size, [InAttribute, OutAttribute] T3[] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(UInt32 buffer, UInt32 offset, Int32 size, [InAttribute, OutAttribute] T3[,] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(UInt32 buffer, UInt32 offset, Int32 size, [InAttribute, OutAttribute] T3[,,] pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glUpdateObjectBufferATI")]
            public static
            void UpdateObjectBuffer<T3>(UInt32 buffer, UInt32 offset, Int32 size, [InAttribute, OutAttribute] ref T3 pointer, OpenTK.Graphics.OpenGL.AtiVertexArrayObject preserve)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glUpdateObjectBufferATI((UInt32)buffer, (UInt32)offset, (Int32)size, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)preserve);
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glVariantArrayObjectATI")]
            public static
            void VariantArrayObject(Int32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject type, Int32 stride, Int32 buffer, Int32 offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantArrayObjectATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)type, (Int32)stride, (UInt32)buffer, (UInt32)offset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexArrayObject", Version = "1.2", EntryPoint = "glVariantArrayObjectATI")]
            public static
            void VariantArrayObject(UInt32 id, OpenTK.Graphics.OpenGL.AtiVertexArrayObject type, Int32 stride, UInt32 buffer, UInt32 offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVariantArrayObjectATI((UInt32)id, (OpenTK.Graphics.OpenGL.AtiVertexArrayObject)type, (Int32)stride, (UInt32)buffer, (UInt32)offset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glVertexAttribArrayObjectATI")]
            public static
            void VertexAttribArrayObject(Int32 index, Int32 size, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject type, bool normalized, Int32 stride, Int32 buffer, Int32 offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribArrayObjectATI((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)type, (bool)normalized, (Int32)stride, (UInt32)buffer, (UInt32)offset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexAttribArrayObject", Version = "1.2", EntryPoint = "glVertexAttribArrayObjectATI")]
            public static
            void VertexAttribArrayObject(UInt32 index, Int32 size, OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject type, bool normalized, Int32 stride, UInt32 buffer, UInt32 offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribArrayObjectATI((UInt32)index, (Int32)size, (OpenTK.Graphics.OpenGL.AtiVertexAttribArrayObject)type, (bool)normalized, (Int32)stride, (UInt32)buffer, (UInt32)offset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexBlendEnvfATI")]
            public static
            void VertexBlendEnv(OpenTK.Graphics.OpenGL.AtiVertexStreams pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexBlendEnvfATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexBlendEnviATI")]
            public static
            void VertexBlendEnv(OpenTK.Graphics.OpenGL.AtiVertexStreams pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexBlendEnviATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1dATI")]
            public static
            void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1dATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1dvATI")]
            public static
            unsafe void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1fATI")]
            public static
            void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1fATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1fvATI")]
            public static
            unsafe void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1iATI")]
            public static
            void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1iATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1ivATI")]
            public static
            unsafe void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1sATI")]
            public static
            void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1sATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream1svATI")]
            public static
            unsafe void VertexStream1(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream1svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2dATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2dATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double)x, (Double)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2dvATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = coords)
                        {
                            Delegates.glVertexStream2dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2dvATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Double coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream2dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2dvATI")]
            public static
            unsafe void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2fATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2fATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single)x, (Single)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2fvATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = coords)
                        {
                            Delegates.glVertexStream2fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2fvATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Single coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream2fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2fvATI")]
            public static
            unsafe void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2iATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32 x, Int32 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2iATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32)x, (Int32)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2ivATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = coords)
                        {
                            Delegates.glVertexStream2ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2ivATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int32 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream2ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2ivATI")]
            public static
            unsafe void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2sATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2sATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2svATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = coords)
                        {
                            Delegates.glVertexStream2svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2svATI")]
            public static
            void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int16 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream2svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream2svATI")]
            public static
            unsafe void VertexStream2(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream2svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3dATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3dATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3dvATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = coords)
                        {
                            Delegates.glVertexStream3dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3dvATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Double coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream3dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3dvATI")]
            public static
            unsafe void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3fATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3fATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3fvATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = coords)
                        {
                            Delegates.glVertexStream3fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3fvATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Single coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream3fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3fvATI")]
            public static
            unsafe void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3iATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32 x, Int32 y, Int32 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3iATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32)x, (Int32)y, (Int32)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3ivATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = coords)
                        {
                            Delegates.glVertexStream3ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3ivATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int32 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream3ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3ivATI")]
            public static
            unsafe void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3sATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3sATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3svATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = coords)
                        {
                            Delegates.glVertexStream3svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3svATI")]
            public static
            void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int16 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream3svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream3svATI")]
            public static
            unsafe void VertexStream3(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream3svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4dATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4dATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4dvATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = coords)
                        {
                            Delegates.glVertexStream4dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4dvATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Double coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream4dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4dvATI")]
            public static
            unsafe void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Double* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4dvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Double*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4fATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4fATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4fvATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = coords)
                        {
                            Delegates.glVertexStream4fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4fvATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Single coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream4fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4fvATI")]
            public static
            unsafe void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Single* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4fvATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Single*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4iATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4iATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4ivATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = coords)
                        {
                            Delegates.glVertexStream4ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4ivATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int32 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream4ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4ivATI")]
            public static
            unsafe void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int32* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4ivATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int32*)coords);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4sATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16 x, Int16 y, Int16 z, Int16 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4sATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4svATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16[] coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = coords)
                        {
                            Delegates.glVertexStream4svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4svATI")]
            public static
            void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, ref Int16 coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* coords_ptr = &coords)
                        {
                            Delegates.glVertexStream4svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "AtiVertexStreams", Version = "1.2", EntryPoint = "glVertexStream4svATI")]
            public static
            unsafe void VertexStream4(OpenTK.Graphics.OpenGL.AtiVertexStreams stream, Int16* coords)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexStream4svATI((OpenTK.Graphics.OpenGL.AtiVertexStreams)stream, (Int16*)coords);
#if DEBUG
                }
#endif
            }
        }



        public static partial class Gremedy
        {
            [AutoGenerated(Category = "GremedyFrameTerminator", Version = "1.0", EntryPoint = "glFrameTerminatorGREMEDY")]
            public static
            void FrameTerminator()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFrameTerminatorGREMEDY();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "GremedyStringMarker", Version = "1.0", EntryPoint = "glStringMarkerGREMEDY")]
            public static
            void StringMarker(Int32 len, IntPtr @string)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glStringMarkerGREMEDY((Int32)len, (IntPtr)@string);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "GremedyStringMarker", Version = "1.0", EntryPoint = "glStringMarkerGREMEDY")]
            public static
            void StringMarker<T1>(Int32 len, [InAttribute, OutAttribute] T1[] @string)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glStringMarkerGREMEDY((Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "GremedyStringMarker", Version = "1.0", EntryPoint = "glStringMarkerGREMEDY")]
            public static
            void StringMarker<T1>(Int32 len, [InAttribute, OutAttribute] T1[,] @string)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glStringMarkerGREMEDY((Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "GremedyStringMarker", Version = "1.0", EntryPoint = "glStringMarkerGREMEDY")]
            public static
            void StringMarker<T1>(Int32 len, [InAttribute, OutAttribute] T1[,,] @string)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glStringMarkerGREMEDY((Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "GremedyStringMarker", Version = "1.0", EntryPoint = "glStringMarkerGREMEDY")]
            public static
            void StringMarker<T1>(Int32 len, [InAttribute, OutAttribute] ref T1 @string)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @string_ptr = GCHandle.Alloc(@string, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glStringMarkerGREMEDY((Int32)len, (IntPtr)@string_ptr.AddrOfPinnedObject());
                        @string = (T1)@string_ptr.Target;
                    }
                    finally
                    {
                        @string_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }
        }

        public static partial class HP
        {
            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glGetImageTransformParameterfvHP")]
            public static
            void GetImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetImageTransformParameterfvHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glGetImageTransformParameterfvHP")]
            public static
            void GetImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetImageTransformParameterfvHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glGetImageTransformParameterfvHP")]
            public static
            unsafe void GetImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetImageTransformParameterfvHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glGetImageTransformParameterivHP")]
            public static
            void GetImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetImageTransformParameterivHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glGetImageTransformParameterivHP")]
            public static
            void GetImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetImageTransformParameterivHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glGetImageTransformParameterivHP")]
            public static
            unsafe void GetImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetImageTransformParameterivHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glImageTransformParameterfHP")]
            public static
            void ImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glImageTransformParameterfHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glImageTransformParameterfvHP")]
            public static
            void ImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glImageTransformParameterfvHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glImageTransformParameterfvHP")]
            public static
            unsafe void ImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glImageTransformParameterfvHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glImageTransformParameteriHP")]
            public static
            void ImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glImageTransformParameteriHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glImageTransformParameterivHP")]
            public static
            void ImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glImageTransformParameterivHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "HpImageTransform", Version = "1.1", EntryPoint = "glImageTransformParameterivHP")]
            public static
            unsafe void ImageTransformParameter(OpenTK.Graphics.OpenGL.HpImageTransform target, OpenTK.Graphics.OpenGL.HpImageTransform pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glImageTransformParameterivHP((OpenTK.Graphics.OpenGL.HpImageTransform)target, (OpenTK.Graphics.OpenGL.HpImageTransform)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Ibm
        {
            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glColorPointerListIBM")]
            public static
            void ColorPointerList(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glColorPointerListIBM")]
            public static
            void ColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glColorPointerListIBM")]
            public static
            void ColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glColorPointerListIBM")]
            public static
            void ColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glColorPointerListIBM")]
            public static
            void ColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.ColorPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.ColorPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glEdgeFlagPointerListIBM")]
            public static
            void EdgeFlagPointerList(Int32 stride, bool[] pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* pointer_ptr = pointer)
                        {
                            Delegates.glEdgeFlagPointerListIBM((Int32)stride, (bool*)pointer_ptr, (Int32)ptrstride);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glEdgeFlagPointerListIBM")]
            public static
            void EdgeFlagPointerList(Int32 stride, ref bool pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (bool* pointer_ptr = &pointer)
                        {
                            Delegates.glEdgeFlagPointerListIBM((Int32)stride, (bool*)pointer_ptr, (Int32)ptrstride);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glEdgeFlagPointerListIBM")]
            public static
            unsafe void EdgeFlagPointerList(Int32 stride, bool* pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEdgeFlagPointerListIBM((Int32)stride, (bool*)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glFogCoordPointerListIBM")]
            public static
            void FogCoordPointerList(OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoordPointerListIBM((OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glFogCoordPointerListIBM")]
            public static
            void FogCoordPointerList<T2>(OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerListIBM((OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glFogCoordPointerListIBM")]
            public static
            void FogCoordPointerList<T2>(OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerListIBM((OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glFogCoordPointerListIBM")]
            public static
            void FogCoordPointerList<T2>(OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerListIBM((OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glFogCoordPointerListIBM")]
            public static
            void FogCoordPointerList<T2>(OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glFogCoordPointerListIBM((OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glIndexPointerListIBM")]
            public static
            void IndexPointerList(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glIndexPointerListIBM((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glIndexPointerListIBM")]
            public static
            void IndexPointerList<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerListIBM((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glIndexPointerListIBM")]
            public static
            void IndexPointerList<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerListIBM((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glIndexPointerListIBM")]
            public static
            void IndexPointerList<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerListIBM((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glIndexPointerListIBM")]
            public static
            void IndexPointerList<T2>(OpenTK.Graphics.OpenGL.IndexPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIndexPointerListIBM((OpenTK.Graphics.OpenGL.IndexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawArraysIBM")]
            public static
            void MultiModeDrawArrays(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] first, Int32[] count, Int32 primcount, Int32 modestride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
                        fixed (Int32* first_ptr = first)
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiModeDrawArraysIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount, (Int32)modestride);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawArraysIBM")]
            public static
            void MultiModeDrawArrays(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 first, ref Int32 count, Int32 primcount, Int32 modestride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
                        fixed (Int32* first_ptr = &first)
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiModeDrawArraysIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)first_ptr, (Int32*)count_ptr, (Int32)primcount, (Int32)modestride);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawArraysIBM")]
            public static
            unsafe void MultiModeDrawArrays(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* first, Int32* count, Int32 primcount, Int32 modestride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiModeDrawArraysIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode, (Int32*)first, (Int32*)count, (Int32)primcount, (Int32)modestride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 modestride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
                        fixed (Int32* count_ptr = count)
                        {
                            Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)modestride);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode[] mode, Int32[] count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = mode)
                        fixed (Int32* count_ptr = count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                                indices = (T3)indices_ptr.Target;
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 modestride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
                        fixed (Int32* count_ptr = &count)
                        {
                            Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)modestride);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            void MultiModeDrawElements<T3>(ref OpenTK.Graphics.OpenGL.BeginMode mode, ref Int32 count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Graphics.OpenGL.BeginMode* mode_ptr = &mode)
                        fixed (Int32* count_ptr = &count)
                        {
                            GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                            try
                            {
                                Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode_ptr, (Int32*)count_ptr, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                                indices = (T3)indices_ptr.Target;
                            }
                            finally
                            {
                                indices_ptr.Free();
                            }
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            unsafe void MultiModeDrawElements(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, IntPtr indices, Int32 primcount, Int32 modestride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices, (Int32)primcount, (Int32)modestride);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] T3[,,] indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "IbmMultimodeDrawArrays", Version = "1.1", EntryPoint = "glMultiModeDrawElementsIBM")]
            public static
            unsafe void MultiModeDrawElements<T3>(OpenTK.Graphics.OpenGL.BeginMode* mode, Int32* count, OpenTK.Graphics.OpenGL.DrawElementsType type, [InAttribute, OutAttribute] ref T3 indices, Int32 primcount, Int32 modestride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle indices_ptr = GCHandle.Alloc(indices, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMultiModeDrawElementsIBM((OpenTK.Graphics.OpenGL.BeginMode*)mode, (Int32*)count, (OpenTK.Graphics.OpenGL.DrawElementsType)type, (IntPtr)indices_ptr.AddrOfPinnedObject(), (Int32)primcount, (Int32)modestride);
                        indices = (T3)indices_ptr.Target;
                    }
                    finally
                    {
                        indices_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glNormalPointerListIBM")]
            public static
            void NormalPointerList(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalPointerListIBM((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glNormalPointerListIBM")]
            public static
            void NormalPointerList<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerListIBM((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glNormalPointerListIBM")]
            public static
            void NormalPointerList<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerListIBM((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glNormalPointerListIBM")]
            public static
            void NormalPointerList<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerListIBM((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glNormalPointerListIBM")]
            public static
            void NormalPointerList<T2>(OpenTK.Graphics.OpenGL.NormalPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer, Int32 ptrstride)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointerListIBM((OpenTK.Graphics.OpenGL.NormalPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glSecondaryColorPointerListIBM")]
            public static
            void SecondaryColorPointerList(Int32 size, OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glSecondaryColorPointerListIBM")]
            public static
            void SecondaryColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glSecondaryColorPointerListIBM")]
            public static
            void SecondaryColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glSecondaryColorPointerListIBM")]
            public static
            void SecondaryColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glSecondaryColorPointerListIBM")]
            public static
            void SecondaryColorPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.IbmVertexArrayLists type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glSecondaryColorPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.IbmVertexArrayLists)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glTexCoordPointerListIBM")]
            public static
            void TexCoordPointerList(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoordPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glTexCoordPointerListIBM")]
            public static
            void TexCoordPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glTexCoordPointerListIBM")]
            public static
            void TexCoordPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glTexCoordPointerListIBM")]
            public static
            void TexCoordPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glTexCoordPointerListIBM")]
            public static
            void TexCoordPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.TexCoordPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.TexCoordPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glVertexPointerListIBM")]
            public static
            void VertexPointerList(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, IntPtr pointer, Int32 ptrstride)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer, (Int32)ptrstride);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glVertexPointerListIBM")]
            public static
            void VertexPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glVertexPointerListIBM")]
            public static
            void VertexPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glVertexPointerListIBM")]
            public static
            void VertexPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] T3[,,] pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "IbmVertexArrayLists", Version = "1.1", EntryPoint = "glVertexPointerListIBM")]
            public static
            void VertexPointerList<T3>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, Int32 stride, [InAttribute, OutAttribute] ref T3 pointer, Int32 ptrstride)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointerListIBM((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject(), (Int32)ptrstride);
                        pointer = (T3)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }
        }

        public static partial class Ingr
        {
            /// <summary>
            /// Specify pixel arithmetic for RGB and alpha components separately
            /// </summary>
            /// <param name="srcRGB">
            /// <para>
            /// Specifies how the red, green, and blue blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. The initial value is GL_ONE.
            /// </para>
            /// </param>
            /// <param name="dstRGB">
            /// <para>
            /// Specifies how the red, green, and blue destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
            /// </para>
            /// </param>
            /// <param name="srcAlpha">
            /// <para>
            /// Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. The initial value is GL_ONE.
            /// </para>
            /// </param>
            /// <param name="dstAlpha">
            /// <para>
            /// Specified how the alpha destination blending factor is computed. The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IngrBlendFuncSeparate", Version = "1.0", EntryPoint = "glBlendFuncSeparateINGR")]
            public static
            void BlendFuncSeparate(OpenTK.Graphics.OpenGL.All sfactorRGB, OpenTK.Graphics.OpenGL.All dfactorRGB, OpenTK.Graphics.OpenGL.All sfactorAlpha, OpenTK.Graphics.OpenGL.All dfactorAlpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBlendFuncSeparateINGR((OpenTK.Graphics.OpenGL.All)sfactorRGB, (OpenTK.Graphics.OpenGL.All)dfactorRGB, (OpenTK.Graphics.OpenGL.All)sfactorAlpha, (OpenTK.Graphics.OpenGL.All)dfactorAlpha);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Intel
        {
            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glColorPointervINTEL")]
            public static
            void ColorPointer(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glColorPointervINTEL")]
            public static
            void ColorPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glColorPointervINTEL")]
            public static
            void ColorPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glColorPointervINTEL")]
            public static
            void ColorPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of colors
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first color element in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glColorPointervINTEL")]
            public static
            void ColorPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glNormalPointervINTEL")]
            public static
            void NormalPointer(OpenTK.Graphics.OpenGL.NormalPointerType type, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormalPointervINTEL((OpenTK.Graphics.OpenGL.NormalPointerType)type, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glNormalPointervINTEL")]
            public static
            void NormalPointer<T1>(OpenTK.Graphics.OpenGL.NormalPointerType type, [InAttribute, OutAttribute] T1[] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointervINTEL((OpenTK.Graphics.OpenGL.NormalPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glNormalPointervINTEL")]
            public static
            void NormalPointer<T1>(OpenTK.Graphics.OpenGL.NormalPointerType type, [InAttribute, OutAttribute] T1[,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointervINTEL((OpenTK.Graphics.OpenGL.NormalPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glNormalPointervINTEL")]
            public static
            void NormalPointer<T1>(OpenTK.Graphics.OpenGL.NormalPointerType type, [InAttribute, OutAttribute] T1[,,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointervINTEL((OpenTK.Graphics.OpenGL.NormalPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of normals
            /// </summary>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glNormalPointervINTEL")]
            public static
            void NormalPointer<T1>(OpenTK.Graphics.OpenGL.NormalPointerType type, [InAttribute, OutAttribute] ref T1 pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glNormalPointervINTEL((OpenTK.Graphics.OpenGL.NormalPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T1)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glTexCoordPointervINTEL")]
            public static
            void TexCoordPointer(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoordPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glTexCoordPointervINTEL")]
            public static
            void TexCoordPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glTexCoordPointervINTEL")]
            public static
            void TexCoordPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glTexCoordPointervINTEL")]
            public static
            void TexCoordPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of texture coordinates
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array elements are understood to be tightly packed. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glTexCoordPointervINTEL")]
            public static
            void TexCoordPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexCoordPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glVertexPointervINTEL")]
            public static
            void VertexPointer(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glVertexPointervINTEL")]
            public static
            void VertexPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glVertexPointervINTEL")]
            public static
            void VertexPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glVertexPointervINTEL")]
            public static
            void VertexPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of vertex data
            /// </summary>
            /// <param name="size">
            /// <para>
            /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "IntelParallelArrays", Version = "1.1", EntryPoint = "glVertexPointervINTEL")]
            public static
            void VertexPointer<T2>(Int32 size, OpenTK.Graphics.OpenGL.VertexPointerType type, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexPointervINTEL((Int32)size, (OpenTK.Graphics.OpenGL.VertexPointerType)type, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }
        }

        public static partial class Mesa
        {
            [AutoGenerated(Category = "MesaResizeBuffers", Version = "1.0", EntryPoint = "glResizeBuffersMESA")]
            public static
            void ResizeBuffers()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glResizeBuffersMESA();
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dMESA")]
            public static
            void WindowPos2(Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2dMESA((Double)x, (Double)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dvMESA")]
            public static
            void WindowPos2(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glWindowPos2dvMESA((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dvMESA")]
            public static
            void WindowPos2(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glWindowPos2dvMESA((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2dvMESA")]
            public static
            unsafe void WindowPos2(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2dvMESA((Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fMESA")]
            public static
            void WindowPos2(Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2fMESA((Single)x, (Single)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fvMESA")]
            public static
            void WindowPos2(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glWindowPos2fvMESA((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fvMESA")]
            public static
            void WindowPos2(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glWindowPos2fvMESA((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2fvMESA")]
            public static
            unsafe void WindowPos2(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2fvMESA((Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2iMESA")]
            public static
            void WindowPos2(Int32 x, Int32 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2iMESA((Int32)x, (Int32)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2ivMESA")]
            public static
            void WindowPos2(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glWindowPos2ivMESA((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2ivMESA")]
            public static
            void WindowPos2(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glWindowPos2ivMESA((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2ivMESA")]
            public static
            unsafe void WindowPos2(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2ivMESA((Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2sMESA")]
            public static
            void WindowPos2(Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2sMESA((Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2svMESA")]
            public static
            void WindowPos2(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glWindowPos2svMESA((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2svMESA")]
            public static
            void WindowPos2(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glWindowPos2svMESA((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos2svMESA")]
            public static
            unsafe void WindowPos2(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos2svMESA((Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dMESA")]
            public static
            void WindowPos3(Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3dMESA((Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dvMESA")]
            public static
            void WindowPos3(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glWindowPos3dvMESA((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dvMESA")]
            public static
            void WindowPos3(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glWindowPos3dvMESA((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3dvMESA")]
            public static
            unsafe void WindowPos3(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3dvMESA((Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fMESA")]
            public static
            void WindowPos3(Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3fMESA((Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fvMESA")]
            public static
            void WindowPos3(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glWindowPos3fvMESA((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fvMESA")]
            public static
            void WindowPos3(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glWindowPos3fvMESA((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3fvMESA")]
            public static
            unsafe void WindowPos3(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3fvMESA((Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3iMESA")]
            public static
            void WindowPos3(Int32 x, Int32 y, Int32 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3iMESA((Int32)x, (Int32)y, (Int32)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3ivMESA")]
            public static
            void WindowPos3(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glWindowPos3ivMESA((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3ivMESA")]
            public static
            void WindowPos3(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glWindowPos3ivMESA((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3ivMESA")]
            public static
            unsafe void WindowPos3(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3ivMESA((Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3sMESA")]
            public static
            void WindowPos3(Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3sMESA((Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3svMESA")]
            public static
            void WindowPos3(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glWindowPos3svMESA((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3svMESA")]
            public static
            void WindowPos3(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glWindowPos3svMESA((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos3svMESA")]
            public static
            unsafe void WindowPos3(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos3svMESA((Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4dMESA")]
            public static
            void WindowPos4(Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4dMESA((Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4dvMESA")]
            public static
            void WindowPos4(Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glWindowPos4dvMESA((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4dvMESA")]
            public static
            void WindowPos4(ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glWindowPos4dvMESA((Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4dvMESA")]
            public static
            unsafe void WindowPos4(Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4dvMESA((Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4fMESA")]
            public static
            void WindowPos4(Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4fMESA((Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4fvMESA")]
            public static
            void WindowPos4(Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glWindowPos4fvMESA((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4fvMESA")]
            public static
            void WindowPos4(ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glWindowPos4fvMESA((Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4fvMESA")]
            public static
            unsafe void WindowPos4(Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4fvMESA((Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4iMESA")]
            public static
            void WindowPos4(Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4iMESA((Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4ivMESA")]
            public static
            void WindowPos4(Int32[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = v)
                        {
                            Delegates.glWindowPos4ivMESA((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4ivMESA")]
            public static
            void WindowPos4(ref Int32 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* v_ptr = &v)
                        {
                            Delegates.glWindowPos4ivMESA((Int32*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4ivMESA")]
            public static
            unsafe void WindowPos4(Int32* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4ivMESA((Int32*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4sMESA")]
            public static
            void WindowPos4(Int16 x, Int16 y, Int16 z, Int16 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4sMESA((Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4svMESA")]
            public static
            void WindowPos4(Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glWindowPos4svMESA((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4svMESA")]
            public static
            void WindowPos4(ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glWindowPos4svMESA((Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the raster position in window coordinates for pixel operations
            /// </summary>
            /// <param name="x">
            /// <para>
            /// Specify the , , coordinates for the raster position.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "MesaWindowPos", Version = "1.0", EntryPoint = "glWindowPos4svMESA")]
            public static
            unsafe void WindowPos4(Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glWindowPos4svMESA((Int16*)v);
#if DEBUG
                }
#endif
            }
        }

        public static partial class NV
        {
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glActiveVaryingNV")]
            public static
            void ActiveVarying(Int32 program, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glActiveVaryingNV((UInt32)program, (String)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glActiveVaryingNV")]
            public static
            void ActiveVarying(UInt32 program, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glActiveVaryingNV((UInt32)program, (String)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glAreProgramsResidentNV")]
            public static
            bool AreProgramsResident(Int32 n, Int32[] programs, [OutAttribute] bool[] residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = programs)
                        fixed (bool* residences_ptr = residences)
                        {
                            return Delegates.glAreProgramsResidentNV((Int32)n, (UInt32*)programs_ptr, (bool*)residences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glAreProgramsResidentNV")]
            public static
            bool AreProgramsResident(Int32 n, ref Int32 programs, [OutAttribute] out bool residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = &programs)
                        fixed (bool* residences_ptr = &residences)
                        {
                            bool retval = Delegates.glAreProgramsResidentNV((Int32)n, (UInt32*)programs_ptr, (bool*)residences_ptr);
                            residences = *residences_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glAreProgramsResidentNV")]
            public static
            unsafe bool AreProgramsResident(Int32 n, Int32* programs, [OutAttribute] bool* residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glAreProgramsResidentNV((Int32)n, (UInt32*)programs, (bool*)residences);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glAreProgramsResidentNV")]
            public static
            bool AreProgramsResident(Int32 n, UInt32[] programs, [OutAttribute] bool[] residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = programs)
                        fixed (bool* residences_ptr = residences)
                        {
                            return Delegates.glAreProgramsResidentNV((Int32)n, (UInt32*)programs_ptr, (bool*)residences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glAreProgramsResidentNV")]
            public static
            bool AreProgramsResident(Int32 n, ref UInt32 programs, [OutAttribute] out bool residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = &programs)
                        fixed (bool* residences_ptr = &residences)
                        {
                            bool retval = Delegates.glAreProgramsResidentNV((Int32)n, (UInt32*)programs_ptr, (bool*)residences_ptr);
                            residences = *residences_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glAreProgramsResidentNV")]
            public static
            unsafe bool AreProgramsResident(Int32 n, UInt32* programs, [OutAttribute] bool* residences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glAreProgramsResidentNV((Int32)n, (UInt32*)programs, (bool*)residences);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvConditionalRender", Version = "", EntryPoint = "glBeginConditionalRenderNV")]
            public static
            void BeginConditionalRender(Int32 id, OpenTK.Graphics.OpenGL.NvConditionalRender mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginConditionalRenderNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvConditionalRender)mode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvConditionalRender", Version = "", EntryPoint = "glBeginConditionalRenderNV")]
            public static
            void BeginConditionalRender(UInt32 id, OpenTK.Graphics.OpenGL.NvConditionalRender mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginConditionalRenderNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvConditionalRender)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glBeginOcclusionQueryNV")]
            public static
            void BeginOcclusionQuery(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginOcclusionQueryNV((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glBeginOcclusionQueryNV")]
            public static
            void BeginOcclusionQuery(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginOcclusionQueryNV((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBeginTransformFeedbackNV")]
            public static
            void BeginTransformFeedback(OpenTK.Graphics.OpenGL.NvTransformFeedback primitiveMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBeginTransformFeedbackNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)primitiveMode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBindBufferBaseNV")]
            public static
            void BindBufferBase(OpenTK.Graphics.OpenGL.NvTransformFeedback target, Int32 index, Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferBaseNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)target, (UInt32)index, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBindBufferBaseNV")]
            public static
            void BindBufferBase(OpenTK.Graphics.OpenGL.NvTransformFeedback target, UInt32 index, UInt32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferBaseNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)target, (UInt32)index, (UInt32)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBindBufferOffsetNV")]
            public static
            void BindBufferOffset(OpenTK.Graphics.OpenGL.NvTransformFeedback target, Int32 index, Int32 buffer, IntPtr offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferOffsetNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBindBufferOffsetNV")]
            public static
            void BindBufferOffset(OpenTK.Graphics.OpenGL.NvTransformFeedback target, UInt32 index, UInt32 buffer, IntPtr offset)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferOffsetNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBindBufferRangeNV")]
            public static
            void BindBufferRange(OpenTK.Graphics.OpenGL.NvTransformFeedback target, Int32 index, Int32 buffer, IntPtr offset, IntPtr size)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferRangeNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glBindBufferRangeNV")]
            public static
            void BindBufferRange(OpenTK.Graphics.OpenGL.NvTransformFeedback target, UInt32 index, UInt32 buffer, IntPtr offset, IntPtr size)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindBufferRangeNV((OpenTK.Graphics.OpenGL.NvTransformFeedback)target, (UInt32)index, (UInt32)buffer, (IntPtr)offset, (IntPtr)size);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glBindProgramNV")]
            public static
            void BindProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glBindProgramNV")]
            public static
            void BindProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glBindTransformFeedbackNV")]
            public static
            void BindTransformFeedback(OpenTK.Graphics.OpenGL.NvTransformFeedback2 target, Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindTransformFeedbackNV((OpenTK.Graphics.OpenGL.NvTransformFeedback2)target, (UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glBindTransformFeedbackNV")]
            public static
            void BindTransformFeedback(OpenTK.Graphics.OpenGL.NvTransformFeedback2 target, UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glBindTransformFeedbackNV((OpenTK.Graphics.OpenGL.NvTransformFeedback2)target, (UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify the clear value for the depth buffer
            /// </summary>
            /// <param name="depth">
            /// <para>
            /// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvDepthBufferFloat", Version = "2.0", EntryPoint = "glClearDepthdNV")]
            public static
            void ClearDepth(Double depth)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glClearDepthdNV((Double)depth);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor3hNV")]
            public static
            void Color3h(OpenTK.Half red, OpenTK.Half green, OpenTK.Half blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor3hNV((OpenTK.Half)red, (OpenTK.Half)green, (OpenTK.Half)blue);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor3hvNV")]
            public static
            void Color3h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glColor3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor3hvNV")]
            public static
            void Color3h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glColor3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor3hvNV")]
            public static
            unsafe void Color3h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor3hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor4hNV")]
            public static
            void Color4h(OpenTK.Half red, OpenTK.Half green, OpenTK.Half blue, OpenTK.Half alpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4hNV((OpenTK.Half)red, (OpenTK.Half)green, (OpenTK.Half)blue, (OpenTK.Half)alpha);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor4hvNV")]
            public static
            void Color4h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glColor4hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor4hvNV")]
            public static
            void Color4h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glColor4hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glColor4hvNV")]
            public static
            unsafe void Color4h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerInputNV")]
            public static
            void CombinerInput(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners input, OpenTK.Graphics.OpenGL.NvRegisterCombiners mapping, OpenTK.Graphics.OpenGL.NvRegisterCombiners componentUsage)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerInputNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)input, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)mapping, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)componentUsage);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerOutputNV")]
            public static
            void CombinerOutput(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners abOutput, OpenTK.Graphics.OpenGL.NvRegisterCombiners cdOutput, OpenTK.Graphics.OpenGL.NvRegisterCombiners sumOutput, OpenTK.Graphics.OpenGL.NvRegisterCombiners scale, OpenTK.Graphics.OpenGL.NvRegisterCombiners bias, bool abDotProduct, bool cdDotProduct, bool muxSum)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerOutputNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)abOutput, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)cdOutput, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)sumOutput, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)scale, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)bias, (bool)abDotProduct, (bool)cdDotProduct, (bool)muxSum);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerParameterfNV")]
            public static
            void CombinerParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerParameterfNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerParameterfvNV")]
            public static
            void CombinerParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glCombinerParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerParameterfvNV")]
            public static
            unsafe void CombinerParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerParameteriNV")]
            public static
            void CombinerParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerParameteriNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerParameterivNV")]
            public static
            void CombinerParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glCombinerParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glCombinerParameterivNV")]
            public static
            unsafe void CombinerParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners2", Version = "1.1", EntryPoint = "glCombinerStageParameterfvNV")]
            public static
            void CombinerStageParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners2 stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners2 pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glCombinerStageParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners2)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners2)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners2", Version = "1.1", EntryPoint = "glCombinerStageParameterfvNV")]
            public static
            void CombinerStageParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners2 stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners2 pname, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glCombinerStageParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners2)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners2)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners2", Version = "1.1", EntryPoint = "glCombinerStageParameterfvNV")]
            public static
            unsafe void CombinerStageParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners2 stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners2 pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCombinerStageParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners2)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners2)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glDeleteFencesNV")]
            public static
            void DeleteFences(Int32 n, Int32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = fences)
                        {
                            Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glDeleteFencesNV")]
            public static
            void DeleteFences(Int32 n, ref Int32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = &fences)
                        {
                            Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glDeleteFencesNV")]
            public static
            unsafe void DeleteFences(Int32 n, Int32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glDeleteFencesNV")]
            public static
            void DeleteFences(Int32 n, UInt32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = fences)
                        {
                            Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glDeleteFencesNV")]
            public static
            void DeleteFences(Int32 n, ref UInt32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = &fences)
                        {
                            Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glDeleteFencesNV")]
            public static
            unsafe void DeleteFences(Int32 n, UInt32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteFencesNV((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glDeleteOcclusionQueriesNV")]
            public static
            void DeleteOcclusionQueries(Int32 n, Int32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = ids)
                        {
                            Delegates.glDeleteOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glDeleteOcclusionQueriesNV")]
            public static
            void DeleteOcclusionQueries(Int32 n, ref Int32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = &ids)
                        {
                            Delegates.glDeleteOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glDeleteOcclusionQueriesNV")]
            public static
            unsafe void DeleteOcclusionQueries(Int32 n, Int32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteOcclusionQueriesNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glDeleteOcclusionQueriesNV")]
            public static
            void DeleteOcclusionQueries(Int32 n, UInt32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = ids)
                        {
                            Delegates.glDeleteOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glDeleteOcclusionQueriesNV")]
            public static
            void DeleteOcclusionQueries(Int32 n, ref UInt32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = &ids)
                        {
                            Delegates.glDeleteOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glDeleteOcclusionQueriesNV")]
            public static
            unsafe void DeleteOcclusionQueries(Int32 n, UInt32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteOcclusionQueriesNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glDeleteProgramsNV")]
            public static
            void DeleteProgram(Int32 n, Int32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = programs)
                        {
                            Delegates.glDeleteProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glDeleteProgramsNV")]
            public static
            void DeleteProgram(Int32 n, ref Int32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = &programs)
                        {
                            Delegates.glDeleteProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glDeleteProgramsNV")]
            public static
            unsafe void DeleteProgram(Int32 n, Int32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteProgramsNV((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glDeleteProgramsNV")]
            public static
            void DeleteProgram(Int32 n, UInt32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = programs)
                        {
                            Delegates.glDeleteProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glDeleteProgramsNV")]
            public static
            void DeleteProgram(Int32 n, ref UInt32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = &programs)
                        {
                            Delegates.glDeleteProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Deletes a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be deleted.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glDeleteProgramsNV")]
            public static
            unsafe void DeleteProgram(Int32 n, UInt32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteProgramsNV((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
            public static
            void DeleteTransformFeedback(Int32 n, Int32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = ids)
                        {
                            Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
            public static
            void DeleteTransformFeedback(Int32 n, ref Int32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = &ids)
                        {
                            Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
            public static
            unsafe void DeleteTransformFeedback(Int32 n, Int32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
            public static
            void DeleteTransformFeedback(Int32 n, UInt32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = ids)
                        {
                            Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
            public static
            void DeleteTransformFeedback(Int32 n, ref UInt32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = &ids)
                        {
                            Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDeleteTransformFeedbacksNV")]
            public static
            unsafe void DeleteTransformFeedback(Int32 n, UInt32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteTransformFeedbacksNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvDepthBufferFloat", Version = "2.0", EntryPoint = "glDepthBoundsdNV")]
            public static
            void DepthBounds(Double zmin, Double zmax)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDepthBoundsdNV((Double)zmin, (Double)zmax);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify mapping of depth values from normalized device coordinates to window coordinates
            /// </summary>
            /// <param name="nearVal">
            /// <para>
            /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="farVal">
            /// <para>
            /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvDepthBufferFloat", Version = "2.0", EntryPoint = "glDepthRangedNV")]
            public static
            void DepthRange(Double zNear, Double zFar)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDepthRangedNV((Double)zNear, (Double)zFar);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDrawTransformFeedbackNV")]
            public static
            void DrawTransformFeedback(OpenTK.Graphics.OpenGL.NvTransformFeedback2 mode, Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawTransformFeedbackNV((OpenTK.Graphics.OpenGL.NvTransformFeedback2)mode, (UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glDrawTransformFeedbackNV")]
            public static
            void DrawTransformFeedback(OpenTK.Graphics.OpenGL.NvTransformFeedback2 mode, UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawTransformFeedbackNV((OpenTK.Graphics.OpenGL.NvTransformFeedback2)mode, (UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvConditionalRender", Version = "", EntryPoint = "glEndConditionalRenderNV")]
            public static
            void EndConditionalRender()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndConditionalRenderNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glEndOcclusionQueryNV")]
            public static
            void EndOcclusionQuery()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndOcclusionQueryNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glEndTransformFeedbackNV")]
            public static
            void EndTransformFeedback()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEndTransformFeedbackNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glEvalMapsNV")]
            public static
            void EvalMap(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glEvalMapsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glExecuteProgramNV")]
            public static
            void ExecuteProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glExecuteProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glExecuteProgramNV")]
            public static
            void ExecuteProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glExecuteProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glExecuteProgramNV")]
            public static
            unsafe void ExecuteProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glExecuteProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glExecuteProgramNV")]
            public static
            void ExecuteProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glExecuteProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glExecuteProgramNV")]
            public static
            void ExecuteProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glExecuteProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glExecuteProgramNV")]
            public static
            unsafe void ExecuteProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glExecuteProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glFinalCombinerInputNV")]
            public static
            void FinalCombinerInput(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners input, OpenTK.Graphics.OpenGL.NvRegisterCombiners mapping, OpenTK.Graphics.OpenGL.NvRegisterCombiners componentUsage)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinalCombinerInputNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)input, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)mapping, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)componentUsage);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glFinishFenceNV")]
            public static
            void FinishFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinishFenceNV((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glFinishFenceNV")]
            public static
            void FinishFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinishFenceNV((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPixelDataRange", Version = "1.2", EntryPoint = "glFlushPixelDataRangeNV")]
            public static
            void FlushPixelDataRange(OpenTK.Graphics.OpenGL.NvPixelDataRange target)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFlushPixelDataRangeNV((OpenTK.Graphics.OpenGL.NvPixelDataRange)target);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexArrayRange", Version = "1.1", EntryPoint = "glFlushVertexArrayRangeNV")]
            public static
            void FlushVertexArrayRange()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFlushVertexArrayRangeNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glFogCoordhNV")]
            public static
            void FogCoordh(OpenTK.Half fog)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoordhNV((OpenTK.Half)fog);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glFogCoordhvNV")]
            public static
            unsafe void FogCoordh(OpenTK.Half* fog)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogCoordhvNV((OpenTK.Half*)fog);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGenFencesNV")]
            public static
            void GenFences(Int32 n, [OutAttribute] Int32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = fences)
                        {
                            Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGenFencesNV")]
            public static
            void GenFences(Int32 n, [OutAttribute] out Int32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* fences_ptr = &fences)
                        {
                            Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                            fences = *fences_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGenFencesNV")]
            public static
            unsafe void GenFences(Int32 n, [OutAttribute] Int32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenFencesNV((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGenFencesNV")]
            public static
            void GenFences(Int32 n, [OutAttribute] UInt32[] fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = fences)
                        {
                            Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGenFencesNV")]
            public static
            void GenFences(Int32 n, [OutAttribute] out UInt32 fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* fences_ptr = &fences)
                        {
                            Delegates.glGenFencesNV((Int32)n, (UInt32*)fences_ptr);
                            fences = *fences_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGenFencesNV")]
            public static
            unsafe void GenFences(Int32 n, [OutAttribute] UInt32* fences)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenFencesNV((Int32)n, (UInt32*)fences);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGenOcclusionQueriesNV")]
            public static
            void GenOcclusionQueries(Int32 n, [OutAttribute] Int32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = ids)
                        {
                            Delegates.glGenOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGenOcclusionQueriesNV")]
            public static
            void GenOcclusionQueries(Int32 n, [OutAttribute] out Int32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = &ids)
                        {
                            Delegates.glGenOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                            ids = *ids_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGenOcclusionQueriesNV")]
            public static
            unsafe void GenOcclusionQueries(Int32 n, [OutAttribute] Int32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenOcclusionQueriesNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGenOcclusionQueriesNV")]
            public static
            void GenOcclusionQueries(Int32 n, [OutAttribute] UInt32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = ids)
                        {
                            Delegates.glGenOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGenOcclusionQueriesNV")]
            public static
            void GenOcclusionQueries(Int32 n, [OutAttribute] out UInt32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = &ids)
                        {
                            Delegates.glGenOcclusionQueriesNV((Int32)n, (UInt32*)ids_ptr);
                            ids = *ids_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGenOcclusionQueriesNV")]
            public static
            unsafe void GenOcclusionQueries(Int32 n, [OutAttribute] UInt32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenOcclusionQueriesNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGenProgramsNV")]
            public static
            void GenProgram(Int32 n, [OutAttribute] Int32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = programs)
                        {
                            Delegates.glGenProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGenProgramsNV")]
            public static
            void GenProgram(Int32 n, [OutAttribute] out Int32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = &programs)
                        {
                            Delegates.glGenProgramsNV((Int32)n, (UInt32*)programs_ptr);
                            programs = *programs_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGenProgramsNV")]
            public static
            unsafe void GenProgram(Int32 n, [OutAttribute] Int32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenProgramsNV((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGenProgramsNV")]
            public static
            void GenProgram(Int32 n, [OutAttribute] UInt32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = programs)
                        {
                            Delegates.glGenProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGenProgramsNV")]
            public static
            void GenProgram(Int32 n, [OutAttribute] out UInt32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = &programs)
                        {
                            Delegates.glGenProgramsNV((Int32)n, (UInt32*)programs_ptr);
                            programs = *programs_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGenProgramsNV")]
            public static
            unsafe void GenProgram(Int32 n, [OutAttribute] UInt32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenProgramsNV((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
            public static
            void GenTransformFeedback(Int32 n, [OutAttribute] Int32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = ids)
                        {
                            Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
            public static
            void GenTransformFeedback(Int32 n, [OutAttribute] out Int32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* ids_ptr = &ids)
                        {
                            Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                            ids = *ids_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
            public static
            unsafe void GenTransformFeedback(Int32 n, [OutAttribute] Int32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
            public static
            void GenTransformFeedback(Int32 n, [OutAttribute] UInt32[] ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = ids)
                        {
                            Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
            public static
            void GenTransformFeedback(Int32 n, [OutAttribute] out UInt32 ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* ids_ptr = &ids)
                        {
                            Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids_ptr);
                            ids = *ids_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glGenTransformFeedbacksNV")]
            public static
            unsafe void GenTransformFeedback(Int32 n, [OutAttribute] UInt32* ids)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGenTransformFeedbacksNV((Int32)n, (UInt32*)ids);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetActiveVaryingNV")]
            public static
            void GetActiveVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.NvTransformFeedback type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.NvTransformFeedback* type_ptr = &type)
                        {
                            Delegates.glGetActiveVaryingNV((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.NvTransformFeedback*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetActiveVaryingNV")]
            public static
            unsafe void GetActiveVarying(Int32 program, Int32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.NvTransformFeedback* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetActiveVaryingNV((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.NvTransformFeedback*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetActiveVaryingNV")]
            public static
            void GetActiveVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] out Int32 length, [OutAttribute] out Int32 size, [OutAttribute] out OpenTK.Graphics.OpenGL.NvTransformFeedback type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* length_ptr = &length)
                        fixed (Int32* size_ptr = &size)
                        fixed (OpenTK.Graphics.OpenGL.NvTransformFeedback* type_ptr = &type)
                        {
                            Delegates.glGetActiveVaryingNV((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length_ptr, (Int32*)size_ptr, (OpenTK.Graphics.OpenGL.NvTransformFeedback*)type_ptr, (StringBuilder)name);
                            length = *length_ptr;
                            size = *size_ptr;
                            type = *type_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetActiveVaryingNV")]
            public static
            unsafe void GetActiveVarying(UInt32 program, UInt32 index, Int32 bufSize, [OutAttribute] Int32* length, [OutAttribute] Int32* size, [OutAttribute] OpenTK.Graphics.OpenGL.NvTransformFeedback* type, [OutAttribute] StringBuilder name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetActiveVaryingNV((UInt32)program, (UInt32)index, (Int32)bufSize, (Int32*)length, (Int32*)size, (OpenTK.Graphics.OpenGL.NvTransformFeedback*)type, (StringBuilder)name);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerInputParameterfvNV")]
            public static
            void GetCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetCombinerInputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerInputParameterfvNV")]
            public static
            void GetCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetCombinerInputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerInputParameterfvNV")]
            public static
            unsafe void GetCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCombinerInputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerInputParameterivNV")]
            public static
            void GetCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetCombinerInputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerInputParameterivNV")]
            public static
            void GetCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetCombinerInputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerInputParameterivNV")]
            public static
            unsafe void GetCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCombinerInputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerOutputParameterfvNV")]
            public static
            void GetCombinerOutputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetCombinerOutputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerOutputParameterfvNV")]
            public static
            void GetCombinerOutputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetCombinerOutputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerOutputParameterfvNV")]
            public static
            unsafe void GetCombinerOutputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCombinerOutputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerOutputParameterivNV")]
            public static
            void GetCombinerOutputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetCombinerOutputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerOutputParameterivNV")]
            public static
            void GetCombinerOutputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetCombinerOutputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetCombinerOutputParameterivNV")]
            public static
            unsafe void GetCombinerOutputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners portion, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCombinerOutputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)portion, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners2", Version = "1.1", EntryPoint = "glGetCombinerStageParameterfvNV")]
            public static
            void GetCombinerStageParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners2 stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners2 pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetCombinerStageParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners2)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners2)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners2", Version = "1.1", EntryPoint = "glGetCombinerStageParameterfvNV")]
            public static
            void GetCombinerStageParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners2 stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners2 pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetCombinerStageParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners2)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners2)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners2", Version = "1.1", EntryPoint = "glGetCombinerStageParameterfvNV")]
            public static
            unsafe void GetCombinerStageParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners2 stage, OpenTK.Graphics.OpenGL.NvRegisterCombiners2 pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetCombinerStageParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners2)stage, (OpenTK.Graphics.OpenGL.NvRegisterCombiners2)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGetFenceivNV")]
            public static
            void GetFence(Int32 fence, OpenTK.Graphics.OpenGL.NvFence pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGetFenceivNV")]
            public static
            void GetFence(Int32 fence, OpenTK.Graphics.OpenGL.NvFence pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGetFenceivNV")]
            public static
            unsafe void GetFence(Int32 fence, OpenTK.Graphics.OpenGL.NvFence pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGetFenceivNV")]
            public static
            void GetFence(UInt32 fence, OpenTK.Graphics.OpenGL.NvFence pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGetFenceivNV")]
            public static
            void GetFence(UInt32 fence, OpenTK.Graphics.OpenGL.NvFence pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glGetFenceivNV")]
            public static
            unsafe void GetFence(UInt32 fence, OpenTK.Graphics.OpenGL.NvFence pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFenceivNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetFinalCombinerInputParameterfvNV")]
            public static
            void GetFinalCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetFinalCombinerInputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetFinalCombinerInputParameterfvNV")]
            public static
            void GetFinalCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetFinalCombinerInputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetFinalCombinerInputParameterfvNV")]
            public static
            unsafe void GetFinalCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFinalCombinerInputParameterfvNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetFinalCombinerInputParameterivNV")]
            public static
            void GetFinalCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFinalCombinerInputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetFinalCombinerInputParameterivNV")]
            public static
            void GetFinalCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFinalCombinerInputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvRegisterCombiners", Version = "1.1", EntryPoint = "glGetFinalCombinerInputParameterivNV")]
            public static
            unsafe void GetFinalCombinerInputParameter(OpenTK.Graphics.OpenGL.NvRegisterCombiners variable, OpenTK.Graphics.OpenGL.NvRegisterCombiners pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFinalCombinerInputParameterivNV((OpenTK.Graphics.OpenGL.NvRegisterCombiners)variable, (OpenTK.Graphics.OpenGL.NvRegisterCombiners)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterfvNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMapAttribParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterfvNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMapAttribParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterfvNV")]
            public static
            unsafe void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapAttribParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterfvNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMapAttribParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterfvNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMapAttribParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterfvNV")]
            public static
            unsafe void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapAttribParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterivNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMapAttribParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterivNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMapAttribParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterivNV")]
            public static
            unsafe void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapAttribParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterivNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMapAttribParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterivNV")]
            public static
            void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMapAttribParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapAttribParameterivNV")]
            public static
            unsafe void GetMapAttribParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapAttribParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [OutAttribute] IntPtr points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] T6[] points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] T6[,] points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] T6[,,] points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] ref T6 points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                        points = (T6)points_ptr.Target;
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [OutAttribute] IntPtr points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] T6[] points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] T6[,] points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] T6[,,] points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapControlPointsNV")]
            public static
            void GetMapControlPoints<T6>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, bool packed, [InAttribute, OutAttribute] ref T6 points)
                where T6 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                        points = (T6)points_ptr.Target;
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapParameterfvNV")]
            public static
            void GetMapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetMapParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapParameterfvNV")]
            public static
            void GetMapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetMapParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapParameterfvNV")]
            public static
            unsafe void GetMapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapParameterivNV")]
            public static
            void GetMapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetMapParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapParameterivNV")]
            public static
            void GetMapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetMapParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glGetMapParameterivNV")]
            public static
            unsafe void GetMapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMapParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glGetMultisamplefvNV")]
            public static
            void GetMultisample(OpenTK.Graphics.OpenGL.NvExplicitMultisample pname, Int32 index, [OutAttribute] Single[] val)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* val_ptr = val)
                        {
                            Delegates.glGetMultisamplefvNV((OpenTK.Graphics.OpenGL.NvExplicitMultisample)pname, (UInt32)index, (Single*)val_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glGetMultisamplefvNV")]
            public static
            void GetMultisample(OpenTK.Graphics.OpenGL.NvExplicitMultisample pname, Int32 index, [OutAttribute] out Single val)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* val_ptr = &val)
                        {
                            Delegates.glGetMultisamplefvNV((OpenTK.Graphics.OpenGL.NvExplicitMultisample)pname, (UInt32)index, (Single*)val_ptr);
                            val = *val_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glGetMultisamplefvNV")]
            public static
            unsafe void GetMultisample(OpenTK.Graphics.OpenGL.NvExplicitMultisample pname, Int32 index, [OutAttribute] Single* val)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultisamplefvNV((OpenTK.Graphics.OpenGL.NvExplicitMultisample)pname, (UInt32)index, (Single*)val);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glGetMultisamplefvNV")]
            public static
            void GetMultisample(OpenTK.Graphics.OpenGL.NvExplicitMultisample pname, UInt32 index, [OutAttribute] Single[] val)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* val_ptr = val)
                        {
                            Delegates.glGetMultisamplefvNV((OpenTK.Graphics.OpenGL.NvExplicitMultisample)pname, (UInt32)index, (Single*)val_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glGetMultisamplefvNV")]
            public static
            void GetMultisample(OpenTK.Graphics.OpenGL.NvExplicitMultisample pname, UInt32 index, [OutAttribute] out Single val)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* val_ptr = &val)
                        {
                            Delegates.glGetMultisamplefvNV((OpenTK.Graphics.OpenGL.NvExplicitMultisample)pname, (UInt32)index, (Single*)val_ptr);
                            val = *val_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glGetMultisamplefvNV")]
            public static
            unsafe void GetMultisample(OpenTK.Graphics.OpenGL.NvExplicitMultisample pname, UInt32 index, [OutAttribute] Single* val)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetMultisamplefvNV((OpenTK.Graphics.OpenGL.NvExplicitMultisample)pname, (UInt32)index, (Single*)val);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryivNV")]
            public static
            void GetOcclusionQuery(Int32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetOcclusionQueryivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryivNV")]
            public static
            void GetOcclusionQuery(Int32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetOcclusionQueryivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryivNV")]
            public static
            unsafe void GetOcclusionQuery(Int32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetOcclusionQueryivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryivNV")]
            public static
            void GetOcclusionQuery(UInt32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetOcclusionQueryivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryivNV")]
            public static
            void GetOcclusionQuery(UInt32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetOcclusionQueryivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryivNV")]
            public static
            unsafe void GetOcclusionQuery(UInt32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetOcclusionQueryivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryuivNV")]
            public static
            void GetOcclusionQuery(UInt32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetOcclusionQueryuivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryuivNV")]
            public static
            void GetOcclusionQuery(UInt32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetOcclusionQueryuivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glGetOcclusionQueryuivNV")]
            public static
            unsafe void GetOcclusionQuery(UInt32 id, OpenTK.Graphics.OpenGL.NvOcclusionQuery pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetOcclusionQueryuivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvOcclusionQuery)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIivNV")]
            public static
            void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIivNV")]
            public static
            void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIivNV")]
            public static
            unsafe void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIivNV")]
            public static
            void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIivNV")]
            public static
            void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIivNV")]
            public static
            unsafe void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIuivNV")]
            public static
            void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramEnvParameterIuivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIuivNV")]
            public static
            void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramEnvParameterIuivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramEnvParameterIuivNV")]
            public static
            unsafe void GetProgramEnvParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramEnvParameterIuivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramivNV")]
            public static
            void GetProgram(Int32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramivNV")]
            public static
            void GetProgram(Int32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramivNV")]
            public static
            unsafe void GetProgram(Int32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramivNV")]
            public static
            void GetProgram(UInt32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramivNV")]
            public static
            void GetProgram(UInt32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Returns a parameter from a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies the program object to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS, GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_MAX_LENGTH.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested object parameter.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramivNV")]
            public static
            unsafe void GetProgram(UInt32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramivNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIivNV")]
            public static
            void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIivNV")]
            public static
            void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIivNV")]
            public static
            unsafe void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIivNV")]
            public static
            void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIivNV")]
            public static
            void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIivNV")]
            public static
            unsafe void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterIivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIuivNV")]
            public static
            void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetProgramLocalParameterIuivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIuivNV")]
            public static
            void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramLocalParameterIuivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glGetProgramLocalParameterIuivNV")]
            public static
            unsafe void GetProgramLocalParameterI(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramLocalParameterIuivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
            public static
            void GetProgramNamedParameter(Int32 id, Int32 len, ref Byte name, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
            public static
            unsafe void GetProgramNamedParameter(Int32 id, Int32 len, Byte* name, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Double* @params_ptr = @params)
                    {
                        Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)@params_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
            public static
            unsafe void GetProgramNamedParameter(Int32 id, Int32 len, Byte* name, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
            public static
            void GetProgramNamedParameter(UInt32 id, Int32 len, ref Byte name, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
            public static
            unsafe void GetProgramNamedParameter(UInt32 id, Int32 len, Byte* name, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Double* @params_ptr = @params)
                    {
                        Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)@params_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterdvNV")]
            public static
            unsafe void GetProgramNamedParameter(UInt32 id, Int32 len, Byte* name, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramNamedParameterdvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
            public static
            void GetProgramNamedParameter(Int32 id, Int32 len, ref Byte name, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
            public static
            unsafe void GetProgramNamedParameter(Int32 id, Int32 len, Byte* name, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)@params_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
            public static
            unsafe void GetProgramNamedParameter(Int32 id, Int32 len, Byte* name, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
            public static
            void GetProgramNamedParameter(UInt32 id, Int32 len, ref Byte name, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
            public static
            unsafe void GetProgramNamedParameter(UInt32 id, Int32 len, Byte* name, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* @params_ptr = @params)
                    {
                        Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)@params_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glGetProgramNamedParameterfvNV")]
            public static
            unsafe void GetProgramNamedParameter(UInt32 id, Int32 len, Byte* name, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramNamedParameterfvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterdvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetProgramParameterdvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterdvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramParameterdvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterdvNV")]
            public static
            unsafe void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramParameterdvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterdvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Double[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = @params)
                        {
                            Delegates.glGetProgramParameterdvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Double*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterdvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramParameterdvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterdvNV")]
            public static
            unsafe void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramParameterdvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterfvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetProgramParameterfvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterfvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramParameterfvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterfvNV")]
            public static
            unsafe void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramParameterfvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterfvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetProgramParameterfvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterfvNV")]
            public static
            void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetProgramParameterfvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramParameterfvNV")]
            public static
            unsafe void GetProgramParameter(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramParameterfvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramStringNV")]
            public static
            void GetProgramString(Int32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Byte[] program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = program)
                        {
                            Delegates.glGetProgramStringNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Byte*)program_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramStringNV")]
            public static
            void GetProgramString(Int32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Byte program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = &program)
                        {
                            Delegates.glGetProgramStringNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Byte*)program_ptr);
                            program = *program_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramStringNV")]
            public static
            unsafe void GetProgramString(Int32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Byte* program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramStringNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Byte*)program);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramStringNV")]
            public static
            void GetProgramString(UInt32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Byte[] program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = program)
                        {
                            Delegates.glGetProgramStringNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Byte*)program_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramStringNV")]
            public static
            void GetProgramString(UInt32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Byte program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = &program)
                        {
                            Delegates.glGetProgramStringNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Byte*)program_ptr);
                            program = *program_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetProgramStringNV")]
            public static
            unsafe void GetProgramString(UInt32 id, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Byte* program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetProgramStringNV((UInt32)id, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Byte*)program);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetTrackMatrixivNV")]
            public static
            void GetTrackMatrix(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 address, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTrackMatrixivNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)address, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetTrackMatrixivNV")]
            public static
            unsafe void GetTrackMatrix(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 address, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTrackMatrixivNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)address, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetTrackMatrixivNV")]
            public static
            void GetTrackMatrix(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 address, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetTrackMatrixivNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)address, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetTrackMatrixivNV")]
            public static
            unsafe void GetTrackMatrix(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 address, OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTrackMatrixivNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)address, (OpenTK.Graphics.OpenGL.AssemblyProgramParameterArb)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetTransformFeedbackVaryingNV")]
            public static
            void GetTransformFeedbackVarying(Int32 program, Int32 index, [OutAttribute] out Int32 location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* location_ptr = &location)
                        {
                            Delegates.glGetTransformFeedbackVaryingNV((UInt32)program, (UInt32)index, (Int32*)location_ptr);
                            location = *location_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetTransformFeedbackVaryingNV")]
            public static
            unsafe void GetTransformFeedbackVarying(Int32 program, Int32 index, [OutAttribute] Int32* location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTransformFeedbackVaryingNV((UInt32)program, (UInt32)index, (Int32*)location);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetTransformFeedbackVaryingNV")]
            public static
            void GetTransformFeedbackVarying(UInt32 program, UInt32 index, [OutAttribute] out Int32 location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* location_ptr = &location)
                        {
                            Delegates.glGetTransformFeedbackVaryingNV((UInt32)program, (UInt32)index, (Int32*)location_ptr);
                            location = *location_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetTransformFeedbackVaryingNV")]
            public static
            unsafe void GetTransformFeedbackVarying(UInt32 program, UInt32 index, [OutAttribute] Int32* location)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTransformFeedbackVaryingNV((UInt32)program, (UInt32)index, (Int32*)location);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetVaryingLocationNV")]
            public static
            Int32 GetVaryingLocation(Int32 program, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetVaryingLocationNV((UInt32)program, (String)name);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glGetVaryingLocationNV")]
            public static
            Int32 GetVaryingLocation(UInt32 program, String name)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetVaryingLocationNV((UInt32)program, (String)name);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribdvNV")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribdvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribdvNV")]
            public static
            unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribdvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribdvNV")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Double @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribdvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Double*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribdvNV")]
            public static
            unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Double* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribdvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Double*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribfvNV")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribfvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribfvNV")]
            public static
            unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribfvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribfvNV")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribfvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribfvNV")]
            public static
            unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribfvNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribivNV")]
            public static
            void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribivNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribivNV")]
            public static
            unsafe void GetVertexAttrib(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribivNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribivNV")]
            public static
            void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVertexAttribivNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Return a generic vertex attribute parameter
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the generic vertex attribute parameter to be queried.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, or GL_CURRENT_VERTEX_ATTRIB.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// Returns the requested data.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribivNV")]
            public static
            unsafe void GetVertexAttrib(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribivNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(Int32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glGetVertexAttribPointervNV")]
            public static
            void GetVertexAttribPointer<T2>(UInt32 index, OpenTK.Graphics.OpenGL.NvVertexProgram pname, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetVertexAttribPointervNV((UInt32)index, (OpenTK.Graphics.OpenGL.NvVertexProgram)pname, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
            public static
            void GetVideoi64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int64* @params_ptr = @params)
                        {
                            Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
            public static
            void GetVideoi64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int64 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int64* @params_ptr = &@params)
                        {
                            Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
            public static
            unsafe void GetVideoi64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
            public static
            void GetVideoi64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int64* @params_ptr = @params)
                        {
                            Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
            public static
            void GetVideoi64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int64 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int64* @params_ptr = &@params)
                        {
                            Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoi64vNV")]
            public static
            unsafe void GetVideoi64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideoi64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int64*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoivNV")]
            public static
            void GetVideo(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetVideoivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoivNV")]
            public static
            void GetVideo(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVideoivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoivNV")]
            public static
            unsafe void GetVideo(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideoivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoivNV")]
            public static
            void GetVideo(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetVideoivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoivNV")]
            public static
            void GetVideo(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetVideoivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoivNV")]
            public static
            unsafe void GetVideo(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideoivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
            public static
            void GetVideoui64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int64* @params_ptr = @params)
                        {
                            Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
            public static
            void GetVideoui64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out Int64 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int64* @params_ptr = &@params)
                        {
                            Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
            public static
            unsafe void GetVideoui64(Int32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] Int64* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
            public static
            void GetVideoui64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] UInt64[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt64* @params_ptr = @params)
                        {
                            Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
            public static
            void GetVideoui64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out UInt64 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt64* @params_ptr = &@params)
                        {
                            Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideoui64vNV")]
            public static
            unsafe void GetVideoui64(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] UInt64* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideoui64vNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt64*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideouivNV")]
            public static
            void GetVideo(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glGetVideouivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideouivNV")]
            public static
            void GetVideo(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] out UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glGetVideouivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glGetVideouivNV")]
            public static
            unsafe void GetVideo(UInt32 video_slot, OpenTK.Graphics.OpenGL.NvPresentVideo pname, [OutAttribute] UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetVideouivNV((UInt32)video_slot, (OpenTK.Graphics.OpenGL.NvPresentVideo)pname, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glIsFenceNV")]
            public static
            bool IsFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsFenceNV((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glIsFenceNV")]
            public static
            bool IsFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsFenceNV((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glIsOcclusionQueryNV")]
            public static
            bool IsOcclusionQuery(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsOcclusionQueryNV((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvOcclusionQuery", Version = "1.2", EntryPoint = "glIsOcclusionQueryNV")]
            public static
            bool IsOcclusionQuery(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsOcclusionQueryNV((UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determines if a name corresponds to a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies a potential program object.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glIsProgramNV")]
            public static
            bool IsProgram(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsProgramNV((UInt32)id);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Determines if a name corresponds to a program object
            /// </summary>
            /// <param name="program">
            /// <para>
            /// Specifies a potential program object.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glIsProgramNV")]
            public static
            bool IsProgram(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsProgramNV((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glIsTransformFeedbackNV")]
            public static
            bool IsTransformFeedback(Int32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsTransformFeedbackNV((UInt32)id);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glIsTransformFeedbackNV")]
            public static
            bool IsTransformFeedback(UInt32 id)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsTransformFeedbackNV((UInt32)id);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glLoadProgramNV")]
            public static
            void LoadProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id, Int32 len, Byte[] program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = program)
                        {
                            Delegates.glLoadProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Int32)len, (Byte*)program_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glLoadProgramNV")]
            public static
            void LoadProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id, Int32 len, ref Byte program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = &program)
                        {
                            Delegates.glLoadProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Int32)len, (Byte*)program_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glLoadProgramNV")]
            public static
            unsafe void LoadProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 id, Int32 len, Byte* program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLoadProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Int32)len, (Byte*)program);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glLoadProgramNV")]
            public static
            void LoadProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id, Int32 len, Byte[] program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = program)
                        {
                            Delegates.glLoadProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Int32)len, (Byte*)program_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glLoadProgramNV")]
            public static
            void LoadProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id, Int32 len, ref Byte program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* program_ptr = &program)
                        {
                            Delegates.glLoadProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Int32)len, (Byte*)program_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glLoadProgramNV")]
            public static
            unsafe void LoadProgram(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 id, Int32 len, Byte* program)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLoadProgramNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)id, (Int32)len, (Byte*)program);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, IntPtr points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] T8[] points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] T8[,] points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] T8[,,] points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, Int32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] ref T8 points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                        points = (T8)points_ptr.Target;
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, IntPtr points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] T8[] points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] T8[,] points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] T8[,,] points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapControlPointsNV")]
            public static
            void MapControlPoints<T8>(OpenTK.Graphics.OpenGL.NvEvaluators target, UInt32 index, OpenTK.Graphics.OpenGL.NvEvaluators type, Int32 ustride, Int32 vstride, Int32 uorder, Int32 vorder, bool packed, [InAttribute, OutAttribute] ref T8 points)
                where T8 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle points_ptr = GCHandle.Alloc(points, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glMapControlPointsNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (UInt32)index, (OpenTK.Graphics.OpenGL.NvEvaluators)type, (Int32)ustride, (Int32)vstride, (Int32)uorder, (Int32)vorder, (bool)packed, (IntPtr)points_ptr.AddrOfPinnedObject());
                        points = (T8)points_ptr.Target;
                    }
                    finally
                    {
                        points_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapParameterfvNV")]
            public static
            void MapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glMapParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapParameterfvNV")]
            public static
            void MapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glMapParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapParameterfvNV")]
            public static
            unsafe void MapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapParameterfvNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapParameterivNV")]
            public static
            void MapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glMapParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapParameterivNV")]
            public static
            void MapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glMapParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvEvaluators", Version = "1.1", EntryPoint = "glMapParameterivNV")]
            public static
            unsafe void MapParameter(OpenTK.Graphics.OpenGL.NvEvaluators target, OpenTK.Graphics.OpenGL.NvEvaluators pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMapParameterivNV((OpenTK.Graphics.OpenGL.NvEvaluators)target, (OpenTK.Graphics.OpenGL.NvEvaluators)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord1hNV")]
            public static
            void MultiTexCoord1h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half s)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1hNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half)s);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord1hvNV")]
            public static
            unsafe void MultiTexCoord1h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord1hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord2hNV")]
            public static
            void MultiTexCoord2h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half s, OpenTK.Half t)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2hNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half)s, (OpenTK.Half)t);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord2hvNV")]
            public static
            void MultiTexCoord2h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord2hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord2hvNV")]
            public static
            void MultiTexCoord2h(OpenTK.Graphics.OpenGL.TextureUnit target, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord2hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord2hvNV")]
            public static
            unsafe void MultiTexCoord2h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord2hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord3hNV")]
            public static
            void MultiTexCoord3h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half s, OpenTK.Half t, OpenTK.Half r)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3hNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half)s, (OpenTK.Half)t, (OpenTK.Half)r);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord3hvNV")]
            public static
            void MultiTexCoord3h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord3hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord3hvNV")]
            public static
            void MultiTexCoord3h(OpenTK.Graphics.OpenGL.TextureUnit target, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord3hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord3hvNV")]
            public static
            unsafe void MultiTexCoord3h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord3hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord4hNV")]
            public static
            void MultiTexCoord4h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half s, OpenTK.Half t, OpenTK.Half r, OpenTK.Half q)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4hNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half)s, (OpenTK.Half)t, (OpenTK.Half)r, (OpenTK.Half)q);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord4hvNV")]
            public static
            void MultiTexCoord4h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glMultiTexCoord4hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord4hvNV")]
            public static
            void MultiTexCoord4h(OpenTK.Graphics.OpenGL.TextureUnit target, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glMultiTexCoord4hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glMultiTexCoord4hvNV")]
            public static
            unsafe void MultiTexCoord4h(OpenTK.Graphics.OpenGL.TextureUnit target, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glMultiTexCoord4hvNV((OpenTK.Graphics.OpenGL.TextureUnit)target, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glNormal3hNV")]
            public static
            void Normal3h(OpenTK.Half nx, OpenTK.Half ny, OpenTK.Half nz)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormal3hNV((OpenTK.Half)nx, (OpenTK.Half)ny, (OpenTK.Half)nz);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glNormal3hvNV")]
            public static
            void Normal3h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glNormal3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glNormal3hvNV")]
            public static
            void Normal3h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glNormal3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glNormal3hvNV")]
            public static
            unsafe void Normal3h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormal3hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glPauseTransformFeedbackNV")]
            public static
            void PauseTransformFeedback()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPauseTransformFeedbackNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPixelDataRange", Version = "1.2", EntryPoint = "glPixelDataRangeNV")]
            public static
            void PixelDataRange(OpenTK.Graphics.OpenGL.NvPixelDataRange target, Int32 length, [OutAttribute] IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelDataRangeNV((OpenTK.Graphics.OpenGL.NvPixelDataRange)target, (Int32)length, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPixelDataRange", Version = "1.2", EntryPoint = "glPixelDataRangeNV")]
            public static
            void PixelDataRange<T2>(OpenTK.Graphics.OpenGL.NvPixelDataRange target, Int32 length, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glPixelDataRangeNV((OpenTK.Graphics.OpenGL.NvPixelDataRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPixelDataRange", Version = "1.2", EntryPoint = "glPixelDataRangeNV")]
            public static
            void PixelDataRange<T2>(OpenTK.Graphics.OpenGL.NvPixelDataRange target, Int32 length, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glPixelDataRangeNV((OpenTK.Graphics.OpenGL.NvPixelDataRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPixelDataRange", Version = "1.2", EntryPoint = "glPixelDataRangeNV")]
            public static
            void PixelDataRange<T2>(OpenTK.Graphics.OpenGL.NvPixelDataRange target, Int32 length, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glPixelDataRangeNV((OpenTK.Graphics.OpenGL.NvPixelDataRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPixelDataRange", Version = "1.2", EntryPoint = "glPixelDataRangeNV")]
            public static
            void PixelDataRange<T2>(OpenTK.Graphics.OpenGL.NvPixelDataRange target, Int32 length, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glPixelDataRangeNV((OpenTK.Graphics.OpenGL.NvPixelDataRange)target, (Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvPointSprite", Version = "1.2", EntryPoint = "glPointParameteriNV")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.NvPointSprite pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameteriNV((OpenTK.Graphics.OpenGL.NvPointSprite)pname, (Int32)param);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvPointSprite", Version = "1.2", EntryPoint = "glPointParameterivNV")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.NvPointSprite pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glPointParameterivNV((OpenTK.Graphics.OpenGL.NvPointSprite)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPointSprite", Version = "1.2", EntryPoint = "glPointParameterivNV")]
            public static
            unsafe void PointParameter(OpenTK.Graphics.OpenGL.NvPointSprite pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterivNV((OpenTK.Graphics.OpenGL.NvPointSprite)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glPresentFrameDualFillNV")]
            public static
            void PresentFrameDualFill(Int32 video_slot, Int64 minPresentTime, Int32 beginPresentTimeId, Int32 presentDurationId, OpenTK.Graphics.OpenGL.NvPresentVideo type, OpenTK.Graphics.OpenGL.NvPresentVideo target0, Int32 fill0, OpenTK.Graphics.OpenGL.NvPresentVideo target1, Int32 fill1, OpenTK.Graphics.OpenGL.NvPresentVideo target2, Int32 fill2, OpenTK.Graphics.OpenGL.NvPresentVideo target3, Int32 fill3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPresentFrameDualFillNV((UInt32)video_slot, (UInt64)minPresentTime, (UInt32)beginPresentTimeId, (UInt32)presentDurationId, (OpenTK.Graphics.OpenGL.NvPresentVideo)type, (OpenTK.Graphics.OpenGL.NvPresentVideo)target0, (UInt32)fill0, (OpenTK.Graphics.OpenGL.NvPresentVideo)target1, (UInt32)fill1, (OpenTK.Graphics.OpenGL.NvPresentVideo)target2, (UInt32)fill2, (OpenTK.Graphics.OpenGL.NvPresentVideo)target3, (UInt32)fill3);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glPresentFrameDualFillNV")]
            public static
            void PresentFrameDualFill(UInt32 video_slot, UInt64 minPresentTime, UInt32 beginPresentTimeId, UInt32 presentDurationId, OpenTK.Graphics.OpenGL.NvPresentVideo type, OpenTK.Graphics.OpenGL.NvPresentVideo target0, UInt32 fill0, OpenTK.Graphics.OpenGL.NvPresentVideo target1, UInt32 fill1, OpenTK.Graphics.OpenGL.NvPresentVideo target2, UInt32 fill2, OpenTK.Graphics.OpenGL.NvPresentVideo target3, UInt32 fill3)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPresentFrameDualFillNV((UInt32)video_slot, (UInt64)minPresentTime, (UInt32)beginPresentTimeId, (UInt32)presentDurationId, (OpenTK.Graphics.OpenGL.NvPresentVideo)type, (OpenTK.Graphics.OpenGL.NvPresentVideo)target0, (UInt32)fill0, (OpenTK.Graphics.OpenGL.NvPresentVideo)target1, (UInt32)fill1, (OpenTK.Graphics.OpenGL.NvPresentVideo)target2, (UInt32)fill2, (OpenTK.Graphics.OpenGL.NvPresentVideo)target3, (UInt32)fill3);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glPresentFrameKeyedNV")]
            public static
            void PresentFrameKeye(Int32 video_slot, Int64 minPresentTime, Int32 beginPresentTimeId, Int32 presentDurationId, OpenTK.Graphics.OpenGL.NvPresentVideo type, OpenTK.Graphics.OpenGL.NvPresentVideo target0, Int32 fill0, Int32 key0, OpenTK.Graphics.OpenGL.NvPresentVideo target1, Int32 fill1, Int32 key1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPresentFrameKeyedNV((UInt32)video_slot, (UInt64)minPresentTime, (UInt32)beginPresentTimeId, (UInt32)presentDurationId, (OpenTK.Graphics.OpenGL.NvPresentVideo)type, (OpenTK.Graphics.OpenGL.NvPresentVideo)target0, (UInt32)fill0, (UInt32)key0, (OpenTK.Graphics.OpenGL.NvPresentVideo)target1, (UInt32)fill1, (UInt32)key1);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPresentVideo", Version = "1.2", EntryPoint = "glPresentFrameKeyedNV")]
            public static
            void PresentFrameKeye(UInt32 video_slot, UInt64 minPresentTime, UInt32 beginPresentTimeId, UInt32 presentDurationId, OpenTK.Graphics.OpenGL.NvPresentVideo type, OpenTK.Graphics.OpenGL.NvPresentVideo target0, UInt32 fill0, UInt32 key0, OpenTK.Graphics.OpenGL.NvPresentVideo target1, UInt32 fill1, UInt32 key1)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPresentFrameKeyedNV((UInt32)video_slot, (UInt64)minPresentTime, (UInt32)beginPresentTimeId, (UInt32)presentDurationId, (OpenTK.Graphics.OpenGL.NvPresentVideo)type, (OpenTK.Graphics.OpenGL.NvPresentVideo)target0, (UInt32)fill0, (UInt32)key0, (OpenTK.Graphics.OpenGL.NvPresentVideo)target1, (UInt32)fill1, (UInt32)key1);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPrimitiveRestart", Version = "1.2", EntryPoint = "glPrimitiveRestartIndexNV")]
            public static
            void PrimitiveRestartIndex(Int32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPrimitiveRestartIndexNV((UInt32)index);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvPrimitiveRestart", Version = "1.2", EntryPoint = "glPrimitiveRestartIndexNV")]
            public static
            void PrimitiveRestartIndex(UInt32 index)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPrimitiveRestartIndexNV((UInt32)index);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvPrimitiveRestart", Version = "1.2", EntryPoint = "glPrimitiveRestartNV")]
            public static
            void PrimitiveRestart()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPrimitiveRestartNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersfvNV")]
            public static
            void ProgramBufferParameters(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, Int32 buffer, Int32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramBufferParametersfvNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersfvNV")]
            public static
            void ProgramBufferParameters(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, Int32 buffer, Int32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramBufferParametersfvNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersfvNV")]
            public static
            unsafe void ProgramBufferParameters(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, Int32 buffer, Int32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramBufferParametersfvNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersfvNV")]
            public static
            void ProgramBufferParameters(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glProgramBufferParametersfvNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersfvNV")]
            public static
            void ProgramBufferParameters(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glProgramBufferParametersfvNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersfvNV")]
            public static
            unsafe void ProgramBufferParameters(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramBufferParametersfvNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIivNV")]
            public static
            void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, Int32 buffer, Int32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramBufferParametersIivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIivNV")]
            public static
            void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, Int32 buffer, Int32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramBufferParametersIivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIivNV")]
            public static
            unsafe void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, Int32 buffer, Int32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramBufferParametersIivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIivNV")]
            public static
            void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramBufferParametersIivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIivNV")]
            public static
            void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramBufferParametersIivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIivNV")]
            public static
            unsafe void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramBufferParametersIivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIuivNV")]
            public static
            void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glProgramBufferParametersIuivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIuivNV")]
            public static
            void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glProgramBufferParametersIuivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvParameterBufferObject", Version = "1.2", EntryPoint = "glProgramBufferParametersIuivNV")]
            public static
            unsafe void ProgramBufferParametersI(OpenTK.Graphics.OpenGL.NvParameterBufferObject target, UInt32 buffer, UInt32 index, Int32 count, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramBufferParametersIuivNV((OpenTK.Graphics.OpenGL.NvParameterBufferObject)target, (UInt32)buffer, (UInt32)index, (Int32)count, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4iNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameterI4iNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4iNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameterI4iNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4ivNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4ivNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4ivNV")]
            public static
            unsafe void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4ivNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4ivNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4ivNV")]
            public static
            unsafe void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4uiNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameterI4uiNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32)x, (UInt32)y, (UInt32)z, (UInt32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4uivNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParameterI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4uivNV")]
            public static
            void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParameterI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParameterI4uivNV")]
            public static
            unsafe void ProgramEnvParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParameterI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4ivNV")]
            public static
            void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4ivNV")]
            public static
            void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4ivNV")]
            public static
            unsafe void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4ivNV")]
            public static
            void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4ivNV")]
            public static
            void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4ivNV")]
            public static
            unsafe void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4uivNV")]
            public static
            void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glProgramEnvParametersI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4uivNV")]
            public static
            void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glProgramEnvParametersI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramEnvParametersI4uivNV")]
            public static
            unsafe void ProgramEnvParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramEnvParametersI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4iNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameterI4iNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4iNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 x, Int32 y, Int32 z, Int32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameterI4iNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)x, (Int32)y, (Int32)z, (Int32)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4ivNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4ivNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4ivNV")]
            public static
            unsafe void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4ivNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4ivNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4ivNV")]
            public static
            unsafe void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameterI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4uiNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, UInt32 x, UInt32 y, UInt32 z, UInt32 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameterI4uiNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32)x, (UInt32)y, (UInt32)z, (UInt32)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4uivNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParameterI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4uivNV")]
            public static
            void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParameterI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParameterI4uivNV")]
            public static
            unsafe void ProgramLocalParameterI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParameterI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4ivNV")]
            public static
            void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4ivNV")]
            public static
            void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4ivNV")]
            public static
            unsafe void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, Int32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4ivNV")]
            public static
            void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4ivNV")]
            public static
            void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4ivNV")]
            public static
            unsafe void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParametersI4ivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4uivNV")]
            public static
            void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, UInt32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = @params)
                        {
                            Delegates.glProgramLocalParametersI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4uivNV")]
            public static
            void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, ref UInt32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* @params_ptr = &@params)
                        {
                            Delegates.glProgramLocalParametersI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (UInt32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvGpuProgram4", Version = "1.3", EntryPoint = "glProgramLocalParametersI4uivNV")]
            public static
            unsafe void ProgramLocalParametersI4(OpenTK.Graphics.OpenGL.NvGpuProgram4 target, UInt32 index, Int32 count, UInt32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramLocalParametersI4uivNV((OpenTK.Graphics.OpenGL.NvGpuProgram4)target, (UInt32)index, (Int32)count, (UInt32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dNV")]
            public static
            void ProgramNamedParameter4(Int32 id, Int32 len, ref Byte name, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        {
                            Delegates.glProgramNamedParameter4dNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Double)x, (Double)y, (Double)z, (Double)w);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dNV")]
            public static
            unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4dNV((UInt32)id, (Int32)len, (Byte*)name, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dNV")]
            public static
            void ProgramNamedParameter4(UInt32 id, Int32 len, ref Byte name, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        {
                            Delegates.glProgramNamedParameter4dNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Double)x, (Double)y, (Double)z, (Double)w);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dNV")]
            public static
            unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4dNV((UInt32)id, (Int32)len, (Byte*)name, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
            public static
            void ProgramNamedParameter4(Int32 id, Int32 len, ref Byte name, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
            public static
            unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
            public static
            unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
            public static
            void ProgramNamedParameter4(UInt32 id, Int32 len, ref Byte name, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
            public static
            unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Double* v_ptr = v)
                    {
                        Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4dvNV")]
            public static
            unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4dvNV((UInt32)id, (Int32)len, (Byte*)name, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fNV")]
            public static
            void ProgramNamedParameter4(Int32 id, Int32 len, ref Byte name, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        {
                            Delegates.glProgramNamedParameter4fNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Single)x, (Single)y, (Single)z, (Single)w);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fNV")]
            public static
            unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4fNV((UInt32)id, (Int32)len, (Byte*)name, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fNV")]
            public static
            void ProgramNamedParameter4(UInt32 id, Int32 len, ref Byte name, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        {
                            Delegates.glProgramNamedParameter4fNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Single)x, (Single)y, (Single)z, (Single)w);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fNV")]
            public static
            unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4fNV((UInt32)id, (Int32)len, (Byte*)name, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
            public static
            void ProgramNamedParameter4(Int32 id, Int32 len, ref Byte name, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
            public static
            unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
            public static
            unsafe void ProgramNamedParameter4(Int32 id, Int32 len, Byte* name, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
            public static
            void ProgramNamedParameter4(UInt32 id, Int32 len, ref Byte name, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* name_ptr = &name)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
            public static
            unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFragmentProgram", Version = "1.2", EntryPoint = "glProgramNamedParameter4fvNV")]
            public static
            unsafe void ProgramNamedParameter4(UInt32 id, Int32 len, Byte* name, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramNamedParameter4fvNV((UInt32)id, (Int32)len, (Byte*)name, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4dNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4dNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glProgramParameter4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glProgramParameter4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dvNV")]
            public static
            unsafe void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glProgramParameter4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glProgramParameter4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4dvNV")]
            public static
            unsafe void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4fNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4fNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glProgramParameter4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glProgramParameter4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fvNV")]
            public static
            unsafe void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glProgramParameter4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fvNV")]
            public static
            void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glProgramParameter4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameter4fvNV")]
            public static
            unsafe void ProgramParameter4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameter4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4dvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glProgramParameters4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4dvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glProgramParameters4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4dvNV")]
            public static
            unsafe void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameters4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4dvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, UInt32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glProgramParameters4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4dvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, UInt32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glProgramParameters4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4dvNV")]
            public static
            unsafe void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, UInt32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameters4dvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4fvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glProgramParameters4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4fvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glProgramParameters4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4fvNV")]
            public static
            unsafe void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameters4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4fvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, UInt32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glProgramParameters4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4fvNV")]
            public static
            void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, UInt32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glProgramParameters4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glProgramParameters4fvNV")]
            public static
            unsafe void ProgramParameters4(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 index, UInt32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramParameters4fvNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)index, (UInt32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvGeometryProgram4", Version = "2.0", EntryPoint = "glProgramVertexLimitNV")]
            public static
            void ProgramVertexLimit(OpenTK.Graphics.OpenGL.NvGeometryProgram4 target, Int32 limit)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glProgramVertexLimitNV((OpenTK.Graphics.OpenGL.NvGeometryProgram4)target, (Int32)limit);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFramebufferMultisampleCoverage", Version = "1.5", EntryPoint = "glRenderbufferStorageMultisampleCoverageNV")]
            public static
            void RenderbufferStorageMultisampleCoverage(OpenTK.Graphics.OpenGL.RenderbufferTarget target, Int32 coverageSamples, Int32 colorSamples, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glRenderbufferStorageMultisampleCoverageNV((OpenTK.Graphics.OpenGL.RenderbufferTarget)target, (Int32)coverageSamples, (Int32)colorSamples, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glRequestResidentProgramsNV")]
            public static
            void RequestResidentProgram(Int32 n, Int32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = programs)
                        {
                            Delegates.glRequestResidentProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glRequestResidentProgramsNV")]
            public static
            void RequestResidentProgram(Int32 n, ref Int32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* programs_ptr = &programs)
                        {
                            Delegates.glRequestResidentProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glRequestResidentProgramsNV")]
            public static
            unsafe void RequestResidentProgram(Int32 n, Int32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glRequestResidentProgramsNV((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glRequestResidentProgramsNV")]
            public static
            void RequestResidentProgram(Int32 n, UInt32[] programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = programs)
                        {
                            Delegates.glRequestResidentProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glRequestResidentProgramsNV")]
            public static
            void RequestResidentProgram(Int32 n, ref UInt32 programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* programs_ptr = &programs)
                        {
                            Delegates.glRequestResidentProgramsNV((Int32)n, (UInt32*)programs_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glRequestResidentProgramsNV")]
            public static
            unsafe void RequestResidentProgram(Int32 n, UInt32* programs)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glRequestResidentProgramsNV((Int32)n, (UInt32*)programs);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback2", Version = "", EntryPoint = "glResumeTransformFeedbackNV")]
            public static
            void ResumeTransformFeedback()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glResumeTransformFeedbackNV();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glSampleMaskIndexedNV")]
            public static
            void SampleMaskIndexed(Int32 index, Int32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleMaskIndexedNV((UInt32)index, (UInt32)mask);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glSampleMaskIndexedNV")]
            public static
            void SampleMaskIndexed(UInt32 index, UInt32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleMaskIndexedNV((UInt32)index, (UInt32)mask);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glSecondaryColor3hNV")]
            public static
            void SecondaryColor3h(OpenTK.Half red, OpenTK.Half green, OpenTK.Half blue)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3hNV((OpenTK.Half)red, (OpenTK.Half)green, (OpenTK.Half)blue);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glSecondaryColor3hvNV")]
            public static
            void SecondaryColor3h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glSecondaryColor3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glSecondaryColor3hvNV")]
            public static
            void SecondaryColor3h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glSecondaryColor3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glSecondaryColor3hvNV")]
            public static
            unsafe void SecondaryColor3h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSecondaryColor3hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glSetFenceNV")]
            public static
            void SetFence(Int32 fence, OpenTK.Graphics.OpenGL.NvFence condition)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetFenceNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)condition);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glSetFenceNV")]
            public static
            void SetFence(UInt32 fence, OpenTK.Graphics.OpenGL.NvFence condition)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSetFenceNV((UInt32)fence, (OpenTK.Graphics.OpenGL.NvFence)condition);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glTestFenceNV")]
            public static
            bool TestFence(Int32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glTestFenceNV((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvFence", Version = "1.2", EntryPoint = "glTestFenceNV")]
            public static
            bool TestFence(UInt32 fence)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glTestFenceNV((UInt32)fence);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord1hNV")]
            public static
            void TexCoord1h(OpenTK.Half s)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord1hNV((OpenTK.Half)s);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord1hvNV")]
            public static
            unsafe void TexCoord1h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord1hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord2hNV")]
            public static
            void TexCoord2h(OpenTK.Half s, OpenTK.Half t)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2hNV((OpenTK.Half)s, (OpenTK.Half)t);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord2hvNV")]
            public static
            void TexCoord2h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glTexCoord2hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord2hvNV")]
            public static
            void TexCoord2h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glTexCoord2hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord2hvNV")]
            public static
            unsafe void TexCoord2h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord3hNV")]
            public static
            void TexCoord3h(OpenTK.Half s, OpenTK.Half t, OpenTK.Half r)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord3hNV((OpenTK.Half)s, (OpenTK.Half)t, (OpenTK.Half)r);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord3hvNV")]
            public static
            void TexCoord3h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glTexCoord3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord3hvNV")]
            public static
            void TexCoord3h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glTexCoord3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord3hvNV")]
            public static
            unsafe void TexCoord3h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord3hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord4hNV")]
            public static
            void TexCoord4h(OpenTK.Half s, OpenTK.Half t, OpenTK.Half r, OpenTK.Half q)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord4hNV((OpenTK.Half)s, (OpenTK.Half)t, (OpenTK.Half)r, (OpenTK.Half)q);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord4hvNV")]
            public static
            void TexCoord4h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glTexCoord4hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord4hvNV")]
            public static
            void TexCoord4h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glTexCoord4hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glTexCoord4hvNV")]
            public static
            unsafe void TexCoord4h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord4hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glTexRenderbufferNV")]
            public static
            void TexRenderbuffer(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexRenderbufferNV((OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvExplicitMultisample", Version = "", EntryPoint = "glTexRenderbufferNV")]
            public static
            void TexRenderbuffer(OpenTK.Graphics.OpenGL.TextureTarget target, UInt32 renderbuffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexRenderbufferNV((OpenTK.Graphics.OpenGL.TextureTarget)target, (UInt32)renderbuffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glTrackMatrixNV")]
            public static
            void TrackMatrix(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, Int32 address, OpenTK.Graphics.OpenGL.NvVertexProgram matrix, OpenTK.Graphics.OpenGL.NvVertexProgram transform)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTrackMatrixNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)address, (OpenTK.Graphics.OpenGL.NvVertexProgram)matrix, (OpenTK.Graphics.OpenGL.NvVertexProgram)transform);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glTrackMatrixNV")]
            public static
            void TrackMatrix(OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb target, UInt32 address, OpenTK.Graphics.OpenGL.NvVertexProgram matrix, OpenTK.Graphics.OpenGL.NvVertexProgram transform)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTrackMatrixNV((OpenTK.Graphics.OpenGL.AssemblyProgramTargetArb)target, (UInt32)address, (OpenTK.Graphics.OpenGL.NvVertexProgram)matrix, (OpenTK.Graphics.OpenGL.NvVertexProgram)transform);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackAttribsNV")]
            public static
            void TransformFeedbackAttrib(Int32 count, Int32[] attribs, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* attribs_ptr = attribs)
                        {
                            Delegates.glTransformFeedbackAttribsNV((UInt32)count, (Int32*)attribs_ptr, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackAttribsNV")]
            public static
            void TransformFeedbackAttrib(Int32 count, ref Int32 attribs, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* attribs_ptr = &attribs)
                        {
                            Delegates.glTransformFeedbackAttribsNV((UInt32)count, (Int32*)attribs_ptr, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackAttribsNV")]
            public static
            unsafe void TransformFeedbackAttrib(Int32 count, Int32* attribs, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTransformFeedbackAttribsNV((UInt32)count, (Int32*)attribs, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackAttribsNV")]
            public static
            void TransformFeedbackAttrib(UInt32 count, Int32[] attribs, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* attribs_ptr = attribs)
                        {
                            Delegates.glTransformFeedbackAttribsNV((UInt32)count, (Int32*)attribs_ptr, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackAttribsNV")]
            public static
            void TransformFeedbackAttrib(UInt32 count, ref Int32 attribs, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* attribs_ptr = &attribs)
                        {
                            Delegates.glTransformFeedbackAttribsNV((UInt32)count, (Int32*)attribs_ptr, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackAttribsNV")]
            public static
            unsafe void TransformFeedbackAttrib(UInt32 count, Int32* attribs, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTransformFeedbackAttribsNV((UInt32)count, (Int32*)attribs, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackVaryingsNV")]
            public static
            void TransformFeedbackVaryings(Int32 program, Int32 count, String[] varyings, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTransformFeedbackVaryingsNV((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvTransformFeedback", Version = "1.5", EntryPoint = "glTransformFeedbackVaryingsNV")]
            public static
            void TransformFeedbackVaryings(UInt32 program, Int32 count, String[] varyings, OpenTK.Graphics.OpenGL.NvTransformFeedback bufferMode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTransformFeedbackVaryingsNV((UInt32)program, (Int32)count, (String[])varyings, (OpenTK.Graphics.OpenGL.NvTransformFeedback)bufferMode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex2hNV")]
            public static
            void Vertex2h(OpenTK.Half x, OpenTK.Half y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertex2hNV((OpenTK.Half)x, (OpenTK.Half)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex2hvNV")]
            public static
            void Vertex2h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertex2hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex2hvNV")]
            public static
            void Vertex2h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertex2hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex2hvNV")]
            public static
            unsafe void Vertex2h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertex2hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex3hNV")]
            public static
            void Vertex3h(OpenTK.Half x, OpenTK.Half y, OpenTK.Half z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertex3hNV((OpenTK.Half)x, (OpenTK.Half)y, (OpenTK.Half)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex3hvNV")]
            public static
            void Vertex3h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertex3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex3hvNV")]
            public static
            void Vertex3h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertex3hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex3hvNV")]
            public static
            unsafe void Vertex3h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertex3hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex4hNV")]
            public static
            void Vertex4h(OpenTK.Half x, OpenTK.Half y, OpenTK.Half z, OpenTK.Half w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertex4hNV((OpenTK.Half)x, (OpenTK.Half)y, (OpenTK.Half)z, (OpenTK.Half)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex4hvNV")]
            public static
            void Vertex4h(OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertex4hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex4hvNV")]
            public static
            void Vertex4h(ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertex4hvNV((OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertex4hvNV")]
            public static
            unsafe void Vertex4h(OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertex4hvNV((OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexArrayRange", Version = "1.1", EntryPoint = "glVertexArrayRangeNV")]
            public static
            void VertexArrayRange(Int32 length, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexArrayRangeNV((Int32)length, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexArrayRange", Version = "1.1", EntryPoint = "glVertexArrayRangeNV")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeNV((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexArrayRange", Version = "1.1", EntryPoint = "glVertexArrayRangeNV")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeNV((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexArrayRange", Version = "1.1", EntryPoint = "glVertexArrayRangeNV")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] T1[,,] pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeNV((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexArrayRange", Version = "1.1", EntryPoint = "glVertexArrayRangeNV")]
            public static
            void VertexArrayRange<T1>(Int32 length, [InAttribute, OutAttribute] ref T1 pointer)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexArrayRangeNV((Int32)length, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T1)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1dNV")]
            public static
            void VertexAttrib1(Int32 index, Double x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dNV((UInt32)index, (Double)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1dNV")]
            public static
            void VertexAttrib1(UInt32 index, Double x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dNV((UInt32)index, (Double)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1dvNV")]
            public static
            unsafe void VertexAttrib1(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1dvNV")]
            public static
            unsafe void VertexAttrib1(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1fNV")]
            public static
            void VertexAttrib1(Int32 index, Single x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fNV((UInt32)index, (Single)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1fNV")]
            public static
            void VertexAttrib1(UInt32 index, Single x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fNV((UInt32)index, (Single)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1fvNV")]
            public static
            unsafe void VertexAttrib1(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1fvNV")]
            public static
            unsafe void VertexAttrib1(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib1hNV")]
            public static
            void VertexAttrib1h(Int32 index, OpenTK.Half x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1hNV((UInt32)index, (OpenTK.Half)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib1hNV")]
            public static
            void VertexAttrib1h(UInt32 index, OpenTK.Half x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1hNV((UInt32)index, (OpenTK.Half)x);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib1hvNV")]
            public static
            unsafe void VertexAttrib1h(Int32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib1hvNV")]
            public static
            unsafe void VertexAttrib1h(UInt32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1sNV")]
            public static
            void VertexAttrib1(Int32 index, Int16 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1sNV((UInt32)index, (Int16)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1sNV")]
            public static
            void VertexAttrib1(UInt32 index, Int16 x)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1sNV((UInt32)index, (Int16)x);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1svNV")]
            public static
            unsafe void VertexAttrib1(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib1svNV")]
            public static
            unsafe void VertexAttrib1(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib1svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dNV")]
            public static
            void VertexAttrib2(Int32 index, Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dNV((UInt32)index, (Double)x, (Double)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dNV")]
            public static
            void VertexAttrib2(UInt32 index, Double x, Double y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dNV((UInt32)index, (Double)x, (Double)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dvNV")]
            public static
            void VertexAttrib2(Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dvNV")]
            public static
            void VertexAttrib2(Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dvNV")]
            public static
            unsafe void VertexAttrib2(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dvNV")]
            public static
            void VertexAttrib2(UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dvNV")]
            public static
            void VertexAttrib2(UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2dvNV")]
            public static
            unsafe void VertexAttrib2(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fNV")]
            public static
            void VertexAttrib2(Int32 index, Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fNV((UInt32)index, (Single)x, (Single)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fNV")]
            public static
            void VertexAttrib2(UInt32 index, Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fNV((UInt32)index, (Single)x, (Single)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fvNV")]
            public static
            void VertexAttrib2(Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fvNV")]
            public static
            void VertexAttrib2(Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fvNV")]
            public static
            unsafe void VertexAttrib2(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fvNV")]
            public static
            void VertexAttrib2(UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fvNV")]
            public static
            void VertexAttrib2(UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2fvNV")]
            public static
            unsafe void VertexAttrib2(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hNV")]
            public static
            void VertexAttrib2h(Int32 index, OpenTK.Half x, OpenTK.Half y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2hNV((UInt32)index, (OpenTK.Half)x, (OpenTK.Half)y);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hNV")]
            public static
            void VertexAttrib2h(UInt32 index, OpenTK.Half x, OpenTK.Half y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2hNV((UInt32)index, (OpenTK.Half)x, (OpenTK.Half)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hvNV")]
            public static
            void VertexAttrib2h(Int32 index, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hvNV")]
            public static
            void VertexAttrib2h(Int32 index, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hvNV")]
            public static
            unsafe void VertexAttrib2h(Int32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hvNV")]
            public static
            void VertexAttrib2h(UInt32 index, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hvNV")]
            public static
            void VertexAttrib2h(UInt32 index, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib2hvNV")]
            public static
            unsafe void VertexAttrib2h(UInt32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2sNV")]
            public static
            void VertexAttrib2(Int32 index, Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2sNV((UInt32)index, (Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2sNV")]
            public static
            void VertexAttrib2(UInt32 index, Int16 x, Int16 y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2sNV((UInt32)index, (Int16)x, (Int16)y);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2svNV")]
            public static
            void VertexAttrib2(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2svNV")]
            public static
            void VertexAttrib2(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2svNV")]
            public static
            unsafe void VertexAttrib2(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2svNV")]
            public static
            void VertexAttrib2(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib2svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2svNV")]
            public static
            void VertexAttrib2(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib2svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib2svNV")]
            public static
            unsafe void VertexAttrib2(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib2svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dNV")]
            public static
            void VertexAttrib3(Int32 index, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dNV((UInt32)index, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dNV")]
            public static
            void VertexAttrib3(UInt32 index, Double x, Double y, Double z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dNV((UInt32)index, (Double)x, (Double)y, (Double)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dvNV")]
            public static
            void VertexAttrib3(Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dvNV")]
            public static
            void VertexAttrib3(Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dvNV")]
            public static
            unsafe void VertexAttrib3(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dvNV")]
            public static
            void VertexAttrib3(UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dvNV")]
            public static
            void VertexAttrib3(UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3dvNV")]
            public static
            unsafe void VertexAttrib3(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fNV")]
            public static
            void VertexAttrib3(Int32 index, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fNV((UInt32)index, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fNV")]
            public static
            void VertexAttrib3(UInt32 index, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fNV((UInt32)index, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fvNV")]
            public static
            void VertexAttrib3(Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fvNV")]
            public static
            void VertexAttrib3(Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fvNV")]
            public static
            unsafe void VertexAttrib3(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fvNV")]
            public static
            void VertexAttrib3(UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fvNV")]
            public static
            void VertexAttrib3(UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3fvNV")]
            public static
            unsafe void VertexAttrib3(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hNV")]
            public static
            void VertexAttrib3h(Int32 index, OpenTK.Half x, OpenTK.Half y, OpenTK.Half z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3hNV((UInt32)index, (OpenTK.Half)x, (OpenTK.Half)y, (OpenTK.Half)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hNV")]
            public static
            void VertexAttrib3h(UInt32 index, OpenTK.Half x, OpenTK.Half y, OpenTK.Half z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3hNV((UInt32)index, (OpenTK.Half)x, (OpenTK.Half)y, (OpenTK.Half)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hvNV")]
            public static
            void VertexAttrib3h(Int32 index, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hvNV")]
            public static
            void VertexAttrib3h(Int32 index, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hvNV")]
            public static
            unsafe void VertexAttrib3h(Int32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hvNV")]
            public static
            void VertexAttrib3h(UInt32 index, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hvNV")]
            public static
            void VertexAttrib3h(UInt32 index, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib3hvNV")]
            public static
            unsafe void VertexAttrib3h(UInt32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3sNV")]
            public static
            void VertexAttrib3(Int32 index, Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3sNV((UInt32)index, (Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3sNV")]
            public static
            void VertexAttrib3(UInt32 index, Int16 x, Int16 y, Int16 z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3sNV((UInt32)index, (Int16)x, (Int16)y, (Int16)z);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3svNV")]
            public static
            void VertexAttrib3(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3svNV")]
            public static
            void VertexAttrib3(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3svNV")]
            public static
            unsafe void VertexAttrib3(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3svNV")]
            public static
            void VertexAttrib3(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib3svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3svNV")]
            public static
            void VertexAttrib3(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib3svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib3svNV")]
            public static
            unsafe void VertexAttrib3(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib3svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dNV")]
            public static
            void VertexAttrib4(Int32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dNV((UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dNV")]
            public static
            void VertexAttrib4(UInt32 index, Double x, Double y, Double z, Double w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dNV((UInt32)index, (Double)x, (Double)y, (Double)z, (Double)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dvNV")]
            public static
            void VertexAttrib4(Int32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dvNV")]
            public static
            void VertexAttrib4(Int32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dvNV")]
            public static
            unsafe void VertexAttrib4(Int32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dvNV")]
            public static
            void VertexAttrib4(UInt32 index, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dvNV")]
            public static
            void VertexAttrib4(UInt32 index, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4dvNV((UInt32)index, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4dvNV")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4dvNV((UInt32)index, (Double*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fNV")]
            public static
            void VertexAttrib4(Int32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fNV((UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fNV")]
            public static
            void VertexAttrib4(UInt32 index, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fNV((UInt32)index, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fvNV")]
            public static
            void VertexAttrib4(Int32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fvNV")]
            public static
            void VertexAttrib4(Int32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fvNV")]
            public static
            unsafe void VertexAttrib4(Int32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fvNV")]
            public static
            void VertexAttrib4(UInt32 index, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fvNV")]
            public static
            void VertexAttrib4(UInt32 index, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4fvNV((UInt32)index, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4fvNV")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4fvNV((UInt32)index, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hNV")]
            public static
            void VertexAttrib4h(Int32 index, OpenTK.Half x, OpenTK.Half y, OpenTK.Half z, OpenTK.Half w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4hNV((UInt32)index, (OpenTK.Half)x, (OpenTK.Half)y, (OpenTK.Half)z, (OpenTK.Half)w);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hNV")]
            public static
            void VertexAttrib4h(UInt32 index, OpenTK.Half x, OpenTK.Half y, OpenTK.Half z, OpenTK.Half w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4hNV((UInt32)index, (OpenTK.Half)x, (OpenTK.Half)y, (OpenTK.Half)z, (OpenTK.Half)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hvNV")]
            public static
            void VertexAttrib4h(Int32 index, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hvNV")]
            public static
            void VertexAttrib4h(Int32 index, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hvNV")]
            public static
            unsafe void VertexAttrib4h(Int32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hvNV")]
            public static
            void VertexAttrib4h(UInt32 index, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hvNV")]
            public static
            void VertexAttrib4h(UInt32 index, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4hvNV((UInt32)index, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttrib4hvNV")]
            public static
            unsafe void VertexAttrib4h(UInt32 index, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4hvNV((UInt32)index, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4sNV")]
            public static
            void VertexAttrib4(Int32 index, Int16 x, Int16 y, Int16 z, Int16 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4sNV((UInt32)index, (Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4sNV")]
            public static
            void VertexAttrib4(UInt32 index, Int16 x, Int16 y, Int16 z, Int16 w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4sNV((UInt32)index, (Int16)x, (Int16)y, (Int16)z, (Int16)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4svNV")]
            public static
            void VertexAttrib4(Int32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4svNV")]
            public static
            void VertexAttrib4(Int32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4svNV")]
            public static
            unsafe void VertexAttrib4(Int32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4svNV")]
            public static
            void VertexAttrib4(UInt32 index, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4svNV")]
            public static
            void VertexAttrib4(UInt32 index, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4svNV((UInt32)index, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4svNV")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4svNV((UInt32)index, (Int16*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubNV")]
            public static
            void VertexAttrib4(Int32 index, Byte x, Byte y, Byte z, Byte w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ubNV((UInt32)index, (Byte)x, (Byte)y, (Byte)z, (Byte)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubNV")]
            public static
            void VertexAttrib4(UInt32 index, Byte x, Byte y, Byte z, Byte w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ubNV((UInt32)index, (Byte)x, (Byte)y, (Byte)z, (Byte)w);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubvNV")]
            public static
            void VertexAttrib4(Int32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4ubvNV((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubvNV")]
            public static
            void VertexAttrib4(Int32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4ubvNV((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubvNV")]
            public static
            unsafe void VertexAttrib4(Int32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ubvNV((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubvNV")]
            public static
            void VertexAttrib4(UInt32 index, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttrib4ubvNV((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubvNV")]
            public static
            void VertexAttrib4(UInt32 index, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttrib4ubvNV((UInt32)index, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specifies the value of a generic vertex attribute
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="v0">
            /// <para>
            /// Specifies the new values to be used for the specified vertex attribute.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttrib4ubvNV")]
            public static
            unsafe void VertexAttrib4(UInt32 index, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttrib4ubvNV((UInt32)index, (Byte*)v);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer(Int32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(Int32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(Int32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(Int32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(Int32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer(UInt32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(UInt32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] T4[] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(UInt32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] T4[,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(UInt32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] T4[,,] pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define an array of generic vertex attribute data
            /// </summary>
            /// <param name="index">
            /// <para>
            /// Specifies the index of the generic vertex attribute to be modified.
            /// </para>
            /// </param>
            /// <param name="size">
            /// <para>
            /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, or 4. The initial value is 4.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// Specifies the data type of each component in the array. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
            /// </para>
            /// </param>
            /// <param name="normalized">
            /// <para>
            /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.
            /// </para>
            /// </param>
            /// <param name="stride">
            /// <para>
            /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.
            /// </para>
            /// </param>
            /// <param name="pointer">
            /// <para>
            /// Specifies a pointer to the first component of the first generic vertex attribute in the array. The initial value is 0.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribPointerNV")]
            public static
            void VertexAttribPointer<T4>(UInt32 index, Int32 fsize, OpenTK.Graphics.OpenGL.VertexAttribParameterArb type, Int32 stride, [InAttribute, OutAttribute] ref T4 pointer)
                where T4 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glVertexAttribPointerNV((UInt32)index, (Int32)fsize, (OpenTK.Graphics.OpenGL.VertexAttribParameterArb)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T4)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1dvNV")]
            public static
            void VertexAttribs1(Int32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1dvNV")]
            public static
            void VertexAttribs1(Int32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1dvNV")]
            public static
            unsafe void VertexAttribs1(Int32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1dvNV")]
            public static
            void VertexAttribs1(UInt32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1dvNV")]
            public static
            void VertexAttribs1(UInt32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1dvNV")]
            public static
            unsafe void VertexAttribs1(UInt32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1fvNV")]
            public static
            void VertexAttribs1(Int32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1fvNV")]
            public static
            void VertexAttribs1(Int32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1fvNV")]
            public static
            unsafe void VertexAttribs1(Int32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1fvNV")]
            public static
            void VertexAttribs1(UInt32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1fvNV")]
            public static
            void VertexAttribs1(UInt32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1fvNV")]
            public static
            unsafe void VertexAttribs1(UInt32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs1hvNV")]
            public static
            void VertexAttribs1h(Int32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs1hvNV")]
            public static
            void VertexAttribs1h(Int32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs1hvNV")]
            public static
            unsafe void VertexAttribs1h(Int32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs1hvNV")]
            public static
            void VertexAttribs1h(UInt32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs1hvNV")]
            public static
            void VertexAttribs1h(UInt32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs1hvNV")]
            public static
            unsafe void VertexAttribs1h(UInt32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1svNV")]
            public static
            void VertexAttribs1(Int32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1svNV")]
            public static
            void VertexAttribs1(Int32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1svNV")]
            public static
            unsafe void VertexAttribs1(Int32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1svNV")]
            public static
            void VertexAttribs1(UInt32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs1svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1svNV")]
            public static
            void VertexAttribs1(UInt32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs1svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs1svNV")]
            public static
            unsafe void VertexAttribs1(UInt32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs1svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2dvNV")]
            public static
            void VertexAttribs2(Int32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2dvNV")]
            public static
            void VertexAttribs2(Int32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2dvNV")]
            public static
            unsafe void VertexAttribs2(Int32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2dvNV")]
            public static
            void VertexAttribs2(UInt32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2dvNV")]
            public static
            void VertexAttribs2(UInt32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2dvNV")]
            public static
            unsafe void VertexAttribs2(UInt32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2fvNV")]
            public static
            void VertexAttribs2(Int32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2fvNV")]
            public static
            void VertexAttribs2(Int32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2fvNV")]
            public static
            unsafe void VertexAttribs2(Int32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2fvNV")]
            public static
            void VertexAttribs2(UInt32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2fvNV")]
            public static
            void VertexAttribs2(UInt32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2fvNV")]
            public static
            unsafe void VertexAttribs2(UInt32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs2hvNV")]
            public static
            void VertexAttribs2h(Int32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs2hvNV")]
            public static
            void VertexAttribs2h(Int32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs2hvNV")]
            public static
            unsafe void VertexAttribs2h(Int32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs2hvNV")]
            public static
            void VertexAttribs2h(UInt32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs2hvNV")]
            public static
            void VertexAttribs2h(UInt32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs2hvNV")]
            public static
            unsafe void VertexAttribs2h(UInt32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2svNV")]
            public static
            void VertexAttribs2(Int32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2svNV")]
            public static
            void VertexAttribs2(Int32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2svNV")]
            public static
            unsafe void VertexAttribs2(Int32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2svNV")]
            public static
            void VertexAttribs2(UInt32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs2svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2svNV")]
            public static
            void VertexAttribs2(UInt32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs2svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs2svNV")]
            public static
            unsafe void VertexAttribs2(UInt32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs2svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3dvNV")]
            public static
            void VertexAttribs3(Int32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3dvNV")]
            public static
            void VertexAttribs3(Int32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3dvNV")]
            public static
            unsafe void VertexAttribs3(Int32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3dvNV")]
            public static
            void VertexAttribs3(UInt32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3dvNV")]
            public static
            void VertexAttribs3(UInt32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3dvNV")]
            public static
            unsafe void VertexAttribs3(UInt32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3fvNV")]
            public static
            void VertexAttribs3(Int32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3fvNV")]
            public static
            void VertexAttribs3(Int32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3fvNV")]
            public static
            unsafe void VertexAttribs3(Int32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3fvNV")]
            public static
            void VertexAttribs3(UInt32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3fvNV")]
            public static
            void VertexAttribs3(UInt32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3fvNV")]
            public static
            unsafe void VertexAttribs3(UInt32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs3hvNV")]
            public static
            void VertexAttribs3h(Int32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs3hvNV")]
            public static
            void VertexAttribs3h(Int32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs3hvNV")]
            public static
            unsafe void VertexAttribs3h(Int32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs3hvNV")]
            public static
            void VertexAttribs3h(UInt32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs3hvNV")]
            public static
            void VertexAttribs3h(UInt32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs3hvNV")]
            public static
            unsafe void VertexAttribs3h(UInt32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3svNV")]
            public static
            void VertexAttribs3(Int32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3svNV")]
            public static
            void VertexAttribs3(Int32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3svNV")]
            public static
            unsafe void VertexAttribs3(Int32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3svNV")]
            public static
            void VertexAttribs3(UInt32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs3svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3svNV")]
            public static
            void VertexAttribs3(UInt32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs3svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs3svNV")]
            public static
            unsafe void VertexAttribs3(UInt32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs3svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4dvNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4dvNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4dvNV")]
            public static
            unsafe void VertexAttribs4(Int32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4dvNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, Double[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4dvNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, ref Double v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4dvNV((UInt32)index, (Int32)count, (Double*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4dvNV")]
            public static
            unsafe void VertexAttribs4(UInt32 index, Int32 count, Double* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4dvNV((UInt32)index, (Int32)count, (Double*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4fvNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4fvNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4fvNV")]
            public static
            unsafe void VertexAttribs4(Int32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4fvNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4fvNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4fvNV((UInt32)index, (Int32)count, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4fvNV")]
            public static
            unsafe void VertexAttribs4(UInt32 index, Int32 count, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4fvNV((UInt32)index, (Int32)count, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs4hvNV")]
            public static
            void VertexAttribs4h(Int32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs4hvNV")]
            public static
            void VertexAttribs4h(Int32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs4hvNV")]
            public static
            unsafe void VertexAttribs4h(Int32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs4hvNV")]
            public static
            void VertexAttribs4h(UInt32 index, Int32 n, OpenTK.Half[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs4hvNV")]
            public static
            void VertexAttribs4h(UInt32 index, Int32 n, ref OpenTK.Half v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (OpenTK.Half* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexAttribs4hvNV")]
            public static
            unsafe void VertexAttribs4h(UInt32 index, Int32 n, OpenTK.Half* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4hvNV((UInt32)index, (Int32)n, (OpenTK.Half*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4svNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4svNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4svNV")]
            public static
            unsafe void VertexAttribs4(Int32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4svNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, Int16[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4svNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, ref Int16 v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4svNV((UInt32)index, (Int32)count, (Int16*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4svNV")]
            public static
            unsafe void VertexAttribs4(UInt32 index, Int32 count, Int16* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4svNV((UInt32)index, (Int32)count, (Int16*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4ubvNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4ubvNV((UInt32)index, (Int32)count, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4ubvNV")]
            public static
            void VertexAttribs4(Int32 index, Int32 count, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4ubvNV((UInt32)index, (Int32)count, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4ubvNV")]
            public static
            unsafe void VertexAttribs4(Int32 index, Int32 count, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4ubvNV((UInt32)index, (Int32)count, (Byte*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4ubvNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, Byte[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = v)
                        {
                            Delegates.glVertexAttribs4ubvNV((UInt32)index, (Int32)count, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4ubvNV")]
            public static
            void VertexAttribs4(UInt32 index, Int32 count, ref Byte v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* v_ptr = &v)
                        {
                            Delegates.glVertexAttribs4ubvNV((UInt32)index, (Int32)count, (Byte*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvVertexProgram", Version = "1.2", EntryPoint = "glVertexAttribs4ubvNV")]
            public static
            unsafe void VertexAttribs4(UInt32 index, Int32 count, Byte* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexAttribs4ubvNV((UInt32)index, (Int32)count, (Byte*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexWeighthNV")]
            public static
            void VertexWeighth(OpenTK.Half weight)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexWeighthNV((OpenTK.Half)weight);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "NvHalfFloat", Version = "1.2", EntryPoint = "glVertexWeighthvNV")]
            public static
            unsafe void VertexWeighth(OpenTK.Half* weight)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glVertexWeighthvNV((OpenTK.Half*)weight);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Pgi
        {
            /// <summary>
            /// Specify implementation-specific hints
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Specifies a symbolic constant indicating the behavior to be controlled. GL_FOG_HINT, GL_GENERATE_MIPMAP_HINT, GL_LINE_SMOOTH_HINT, GL_PERSPECTIVE_CORRECTION_HINT, GL_POINT_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.
            /// </para>
            /// </param>
            /// <param name="mode">
            /// <para>
            /// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "PgiMiscHints", Version = "1.1", EntryPoint = "glHintPGI")]
            public static
            void Hint(OpenTK.Graphics.OpenGL.PgiMiscHints target, Int32 mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glHintPGI((OpenTK.Graphics.OpenGL.PgiMiscHints)target, (Int32)mode);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Sgi
        {
            /// <summary>
            /// Set color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameters are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableParameterfvSGI")]
            public static
            void ColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glColorTableParameterfvSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameters are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableParameterfvSGI")]
            public static
            void ColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, ref Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glColorTableParameterfvSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameters are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableParameterfvSGI")]
            public static
            unsafe void ColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorTableParameterfvSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameters are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableParameterivSGI")]
            public static
            void ColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glColorTableParameterivSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameters are stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableParameterivSGI")]
            public static
            void ColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, ref Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glColorTableParameterivSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Set color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or GL_COLOR_TABLE_BIAS.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameters are stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableParameterivSGI")]
            public static
            unsafe void ColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorTableParameterivSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableSGI")]
            public static
            void ColorTable(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr table)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableSGI")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[] table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableSGI")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,] table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableSGI")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T5[,,] table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Define a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, and GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The number of entries in the color lookup table specified by data.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
            /// </para>
            /// </param>
            /// <param name="data">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data that is processed to build the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glColorTableSGI")]
            public static
            void ColorTable<T5>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T5 table)
                where T5 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                        table = (T5)table_ptr.Target;
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Copy pixels into a color table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="internalformat">
            /// <para>
            /// The internal storage format of the texture image. Must be one of the following symbolic constants: GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
            /// </para>
            /// </param>
            /// <param name="x">
            /// <para>
            /// The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.
            /// </para>
            /// </param>
            /// <param name="y">
            /// <para>
            /// The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color table.
            /// </para>
            /// </param>
            /// <param name="width">
            /// <para>
            /// The width of the pixel rectangle.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glCopyColorTableSGI")]
            public static
            void CopyColorTable(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 x, Int32 y, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glCopyColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)x, (Int32)y, (Int32)width);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableParameterfvSGI")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetColorTableParameterfvSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableParameterfvSGI")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetColorTableParameterfvSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableParameterfvSGI")]
            public static
            unsafe void GetColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetColorTableParameterfvSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableParameterivSGI")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetColorTableParameterivSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableParameterivSGI")]
            public static
            void GetColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetColorTableParameterivSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Get color lookup table parameters
            /// </summary>
            /// <param name="target">
            /// <para>
            /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="pname">
            /// <para>
            /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS, GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE, GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE, GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
            /// </para>
            /// </param>
            /// <param name="params">
            /// <para>
            /// A pointer to an array where the values of the parameter will be stored.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableParameterivSGI")]
            public static
            unsafe void GetColorTableParameter(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.SgiColorTable pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetColorTableParameterivSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.SgiColorTable)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableSGI")]
            public static
            void GetColorTable(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [OutAttribute] IntPtr table)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableSGI")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[] table)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableSGI")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,] table)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableSGI")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T3[,,] table)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Retrieve contents of a color lookup table
            /// </summary>
            /// <param name="target">
            /// <para>
            /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
            /// </para>
            /// </param>
            /// <param name="format">
            /// <para>
            /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
            /// </para>
            /// </param>
            /// <param name="type">
            /// <para>
            /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
            /// </para>
            /// </param>
            /// <param name="table">
            /// <para>
            /// Pointer to a one-dimensional array of pixel data containing the contents of the color table.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgiColorTable", Version = "1.0", EntryPoint = "glGetColorTableSGI")]
            public static
            void GetColorTable<T3>(OpenTK.Graphics.OpenGL.SgiColorTable target, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T3 table)
                where T3 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle table_ptr = GCHandle.Alloc(table, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glGetColorTableSGI((OpenTK.Graphics.OpenGL.SgiColorTable)target, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)table_ptr.AddrOfPinnedObject());
                        table = (T3)table_ptr.Target;
                    }
                    finally
                    {
                        table_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }
        }

        public static partial class Sgis
        {
            [AutoGenerated(Category = "SgisDetailTexture", Version = "1.0", EntryPoint = "glDetailTexFuncSGIS")]
            public static
            void DetailTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 n, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glDetailTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)n, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisDetailTexture", Version = "1.0", EntryPoint = "glDetailTexFuncSGIS")]
            public static
            void DetailTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 n, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glDetailTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)n, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisDetailTexture", Version = "1.0", EntryPoint = "glDetailTexFuncSGIS")]
            public static
            unsafe void DetailTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 n, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDetailTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)n, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisFogFunction", Version = "1.1", EntryPoint = "glFogFuncSGIS")]
            public static
            void FogFunc(Int32 n, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glFogFuncSGIS((Int32)n, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisFogFunction", Version = "1.1", EntryPoint = "glFogFuncSGIS")]
            public static
            void FogFunc(Int32 n, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glFogFuncSGIS((Int32)n, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisFogFunction", Version = "1.1", EntryPoint = "glFogFuncSGIS")]
            public static
            unsafe void FogFunc(Int32 n, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFogFuncSGIS((Int32)n, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisDetailTexture", Version = "1.0", EntryPoint = "glGetDetailTexFuncSGIS")]
            public static
            void GetDetailTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, [OutAttribute] Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glGetDetailTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisDetailTexture", Version = "1.0", EntryPoint = "glGetDetailTexFuncSGIS")]
            public static
            void GetDetailTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, [OutAttribute] out Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glGetDetailTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Single*)points_ptr);
                            points = *points_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisDetailTexture", Version = "1.0", EntryPoint = "glGetDetailTexFuncSGIS")]
            public static
            unsafe void GetDetailTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, [OutAttribute] Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetDetailTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisFogFunction", Version = "1.1", EntryPoint = "glGetFogFuncSGIS")]
            public static
            void GetFogFunc([OutAttribute] Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glGetFogFuncSGIS((Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisFogFunction", Version = "1.1", EntryPoint = "glGetFogFuncSGIS")]
            public static
            void GetFogFunc([OutAttribute] out Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glGetFogFuncSGIS((Single*)points_ptr);
                            points = *points_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisFogFunction", Version = "1.1", EntryPoint = "glGetFogFuncSGIS")]
            public static
            unsafe void GetFogFunc([OutAttribute] Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFogFuncSGIS((Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glGetPixelTexGenParameterfvSGIS")]
            public static
            void GetPixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetPixelTexGenParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glGetPixelTexGenParameterfvSGIS")]
            public static
            void GetPixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetPixelTexGenParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glGetPixelTexGenParameterfvSGIS")]
            public static
            unsafe void GetPixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPixelTexGenParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glGetPixelTexGenParameterivSGIS")]
            public static
            void GetPixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetPixelTexGenParameterivSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glGetPixelTexGenParameterivSGIS")]
            public static
            void GetPixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetPixelTexGenParameterivSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glGetPixelTexGenParameterivSGIS")]
            public static
            unsafe void GetPixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetPixelTexGenParameterivSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisSharpenTexture", Version = "1.0", EntryPoint = "glGetSharpenTexFuncSGIS")]
            public static
            void GetSharpenTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, [OutAttribute] Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glGetSharpenTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisSharpenTexture", Version = "1.0", EntryPoint = "glGetSharpenTexFuncSGIS")]
            public static
            void GetSharpenTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, [OutAttribute] out Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glGetSharpenTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Single*)points_ptr);
                            points = *points_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisSharpenTexture", Version = "1.0", EntryPoint = "glGetSharpenTexFuncSGIS")]
            public static
            unsafe void GetSharpenTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, [OutAttribute] Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetSharpenTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTextureFilter4", Version = "1.0", EntryPoint = "glGetTexFilterFuncSGIS")]
            public static
            void GetTexFilterFunc(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.SgisTextureFilter4 filter, [OutAttribute] Single[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* weights_ptr = weights)
                        {
                            Delegates.glGetTexFilterFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.SgisTextureFilter4)filter, (Single*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTextureFilter4", Version = "1.0", EntryPoint = "glGetTexFilterFuncSGIS")]
            public static
            void GetTexFilterFunc(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.SgisTextureFilter4 filter, [OutAttribute] out Single weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* weights_ptr = &weights)
                        {
                            Delegates.glGetTexFilterFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.SgisTextureFilter4)filter, (Single*)weights_ptr);
                            weights = *weights_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisTextureFilter4", Version = "1.0", EntryPoint = "glGetTexFilterFuncSGIS")]
            public static
            unsafe void GetTexFilterFunc(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.SgisTextureFilter4 filter, [OutAttribute] Single* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetTexFilterFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.SgisTextureFilter4)filter, (Single*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenParameterfSGIS")]
            public static
            void PixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTexGenParameterfSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenParameterfvSGIS")]
            public static
            void PixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glPixelTexGenParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenParameterfvSGIS")]
            public static
            unsafe void PixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTexGenParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenParameteriSGIS")]
            public static
            void PixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTexGenParameteriSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenParameterivSGIS")]
            public static
            void PixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glPixelTexGenParameterivSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenParameterivSGIS")]
            public static
            unsafe void PixelTexGenParameter(OpenTK.Graphics.OpenGL.SgisPixelTexture pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTexGenParameterivSGIS((OpenTK.Graphics.OpenGL.SgisPixelTexture)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgisPointParameters", Version = "1.0", EntryPoint = "glPointParameterfSGIS")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.SgisPointParameters pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterfSGIS((OpenTK.Graphics.OpenGL.SgisPointParameters)pname, (Single)param);
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [AutoGenerated(Category = "SgisPointParameters", Version = "1.0", EntryPoint = "glPointParameterfvSGIS")]
            public static
            void PointParameter(OpenTK.Graphics.OpenGL.SgisPointParameters pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glPointParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPointParameters)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }


            /// <summary>
            /// Specify point parameters
            /// </summary>
            /// <param name="pname">
            /// <para>
            /// Specifies a single-valued point parameter. GL_POINT_SIZE_MIN, GL_POINT_SIZE_MAX, GL_POINT_FADE_THRESHOLD_SIZE, and GL_POINT_SPRITE_COORD_ORIGIN are accepted.
            /// </para>
            /// </param>
            /// <param name="param">
            /// <para>
            /// Specifies the value that pname will be set to.
            /// </para>
            /// </param>
            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisPointParameters", Version = "1.0", EntryPoint = "glPointParameterfvSGIS")]
            public static
            unsafe void PointParameter(OpenTK.Graphics.OpenGL.SgisPointParameters pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPointParameterfvSGIS((OpenTK.Graphics.OpenGL.SgisPointParameters)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisMultisample", Version = "1.1", EntryPoint = "glSampleMaskSGIS")]
            public static
            void SampleMask(Single value, bool invert)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSampleMaskSGIS((Single)value, (bool)invert);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisMultisample", Version = "1.0", EntryPoint = "glSamplePatternSGIS")]
            public static
            void SamplePattern(OpenTK.Graphics.OpenGL.SgisMultisample pattern)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSamplePatternSGIS((OpenTK.Graphics.OpenGL.SgisMultisample)pattern);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisSharpenTexture", Version = "1.0", EntryPoint = "glSharpenTexFuncSGIS")]
            public static
            void SharpenTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 n, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glSharpenTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)n, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisSharpenTexture", Version = "1.0", EntryPoint = "glSharpenTexFuncSGIS")]
            public static
            void SharpenTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 n, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glSharpenTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)n, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisSharpenTexture", Version = "1.0", EntryPoint = "glSharpenTexFuncSGIS")]
            public static
            unsafe void SharpenTexFunc(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 n, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSharpenTexFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)n, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTextureFilter4", Version = "1.0", EntryPoint = "glTexFilterFuncSGIS")]
            public static
            void TexFilterFunc(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.SgisTextureFilter4 filter, Int32 n, Single[] weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* weights_ptr = weights)
                        {
                            Delegates.glTexFilterFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.SgisTextureFilter4)filter, (Int32)n, (Single*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTextureFilter4", Version = "1.0", EntryPoint = "glTexFilterFuncSGIS")]
            public static
            void TexFilterFunc(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.SgisTextureFilter4 filter, Int32 n, ref Single weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* weights_ptr = &weights)
                        {
                            Delegates.glTexFilterFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.SgisTextureFilter4)filter, (Int32)n, (Single*)weights_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgisTextureFilter4", Version = "1.0", EntryPoint = "glTexFilterFuncSGIS")]
            public static
            unsafe void TexFilterFunc(OpenTK.Graphics.OpenGL.TextureTarget target, OpenTK.Graphics.OpenGL.SgisTextureFilter4 filter, Int32 n, Single* weights)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexFilterFuncSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (OpenTK.Graphics.OpenGL.SgisTextureFilter4)filter, (Int32)n, (Single*)weights);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexImage4DSGIS")]
            public static
            void TexImage4D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 size4d, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexImage4DSGIS")]
            public static
            void TexImage4D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 size4d, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexImage4DSGIS")]
            public static
            void TexImage4D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 size4d, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexImage4DSGIS")]
            public static
            void TexImage4D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 size4d, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T10[,,] pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexImage4DSGIS")]
            public static
            void TexImage4D<T10>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, OpenTK.Graphics.OpenGL.PixelInternalFormat internalformat, Int32 width, Int32 height, Int32 depth, Int32 size4d, Int32 border, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T10 pixels)
                where T10 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (OpenTK.Graphics.OpenGL.PixelInternalFormat)internalformat, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (Int32)border, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T10)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexSubImage4DSGIS")]
            public static
            void TexSubImage4D(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 woffset, Int32 width, Int32 height, Int32 depth, Int32 size4d, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, IntPtr pixels)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexSubImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)woffset, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexSubImage4DSGIS")]
            public static
            void TexSubImage4D<T12>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 woffset, Int32 width, Int32 height, Int32 depth, Int32 size4d, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T12[] pixels)
                where T12 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)woffset, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexSubImage4DSGIS")]
            public static
            void TexSubImage4D<T12>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 woffset, Int32 width, Int32 height, Int32 depth, Int32 size4d, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T12[,] pixels)
                where T12 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)woffset, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexSubImage4DSGIS")]
            public static
            void TexSubImage4D<T12>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 woffset, Int32 width, Int32 height, Int32 depth, Int32 size4d, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] T12[,,] pixels)
                where T12 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)woffset, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTexture4D", Version = "1.0", EntryPoint = "glTexSubImage4DSGIS")]
            public static
            void TexSubImage4D<T12>(OpenTK.Graphics.OpenGL.TextureTarget target, Int32 level, Int32 xoffset, Int32 yoffset, Int32 zoffset, Int32 woffset, Int32 width, Int32 height, Int32 depth, Int32 size4d, OpenTK.Graphics.OpenGL.PixelFormat format, OpenTK.Graphics.OpenGL.PixelType type, [InAttribute, OutAttribute] ref T12 pixels)
                where T12 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pixels_ptr = GCHandle.Alloc(pixels, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glTexSubImage4DSGIS((OpenTK.Graphics.OpenGL.TextureTarget)target, (Int32)level, (Int32)xoffset, (Int32)yoffset, (Int32)zoffset, (Int32)woffset, (Int32)width, (Int32)height, (Int32)depth, (Int32)size4d, (OpenTK.Graphics.OpenGL.PixelFormat)format, (OpenTK.Graphics.OpenGL.PixelType)type, (IntPtr)pixels_ptr.AddrOfPinnedObject());
                        pixels = (T12)pixels_ptr.Target;
                    }
                    finally
                    {
                        pixels_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgisTextureColorMask", Version = "1.1", EntryPoint = "glTextureColorMaskSGIS")]
            public static
            void TextureColorMask(bool red, bool green, bool blue, bool alpha)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTextureColorMaskSGIS((bool)red, (bool)green, (bool)blue, (bool)alpha);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Sgix
        {
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glAsyncMarkerSGIX")]
            public static
            void AsyncMarker(Int32 marker)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAsyncMarkerSGIX((UInt32)marker);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glAsyncMarkerSGIX")]
            public static
            void AsyncMarker(UInt32 marker)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glAsyncMarkerSGIX((UInt32)marker);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformationMap3dSGIX")]
            public static
            void DeformationMap3(OpenTK.Graphics.OpenGL.SgixPolynomialFfd target, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double w1, Double w2, Int32 wstride, Int32 worder, Double[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = points)
                        {
                            Delegates.glDeformationMap3dSGIX((OpenTK.Graphics.OpenGL.SgixPolynomialFfd)target, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double)w1, (Double)w2, (Int32)wstride, (Int32)worder, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformationMap3dSGIX")]
            public static
            void DeformationMap3(OpenTK.Graphics.OpenGL.SgixPolynomialFfd target, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double w1, Double w2, Int32 wstride, Int32 worder, ref Double points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* points_ptr = &points)
                        {
                            Delegates.glDeformationMap3dSGIX((OpenTK.Graphics.OpenGL.SgixPolynomialFfd)target, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double)w1, (Double)w2, (Int32)wstride, (Int32)worder, (Double*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformationMap3dSGIX")]
            public static
            unsafe void DeformationMap3(OpenTK.Graphics.OpenGL.SgixPolynomialFfd target, Double u1, Double u2, Int32 ustride, Int32 uorder, Double v1, Double v2, Int32 vstride, Int32 vorder, Double w1, Double w2, Int32 wstride, Int32 worder, Double* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeformationMap3dSGIX((OpenTK.Graphics.OpenGL.SgixPolynomialFfd)target, (Double)u1, (Double)u2, (Int32)ustride, (Int32)uorder, (Double)v1, (Double)v2, (Int32)vstride, (Int32)vorder, (Double)w1, (Double)w2, (Int32)wstride, (Int32)worder, (Double*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformationMap3fSGIX")]
            public static
            void DeformationMap3(OpenTK.Graphics.OpenGL.SgixPolynomialFfd target, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single w1, Single w2, Int32 wstride, Int32 worder, Single[] points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = points)
                        {
                            Delegates.glDeformationMap3fSGIX((OpenTK.Graphics.OpenGL.SgixPolynomialFfd)target, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single)w1, (Single)w2, (Int32)wstride, (Int32)worder, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformationMap3fSGIX")]
            public static
            void DeformationMap3(OpenTK.Graphics.OpenGL.SgixPolynomialFfd target, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single w1, Single w2, Int32 wstride, Int32 worder, ref Single points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* points_ptr = &points)
                        {
                            Delegates.glDeformationMap3fSGIX((OpenTK.Graphics.OpenGL.SgixPolynomialFfd)target, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single)w1, (Single)w2, (Int32)wstride, (Int32)worder, (Single*)points_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformationMap3fSGIX")]
            public static
            unsafe void DeformationMap3(OpenTK.Graphics.OpenGL.SgixPolynomialFfd target, Single u1, Single u2, Int32 ustride, Int32 uorder, Single v1, Single v2, Int32 vstride, Int32 vorder, Single w1, Single w2, Int32 wstride, Int32 worder, Single* points)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeformationMap3fSGIX((OpenTK.Graphics.OpenGL.SgixPolynomialFfd)target, (Single)u1, (Single)u2, (Int32)ustride, (Int32)uorder, (Single)v1, (Single)v2, (Int32)vstride, (Int32)vorder, (Single)w1, (Single)w2, (Int32)wstride, (Int32)worder, (Single*)points);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformSGIX")]
            public static
            void Deform(Int32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeformSGIX((UInt32)mask);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glDeformSGIX")]
            public static
            void Deform(UInt32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeformSGIX((UInt32)mask);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glDeleteAsyncMarkersSGIX")]
            public static
            void DeleteAsyncMarkers(Int32 marker, Int32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteAsyncMarkersSGIX((UInt32)marker, (Int32)range);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glDeleteAsyncMarkersSGIX")]
            public static
            void DeleteAsyncMarkers(UInt32 marker, Int32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDeleteAsyncMarkersSGIX((UInt32)marker, (Int32)range);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glFinishAsyncSGIX")]
            public static
            Int32 FinishAsync([OutAttribute] out Int32 markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* markerp_ptr = &markerp)
                        {
                            Int32 retval = Delegates.glFinishAsyncSGIX((UInt32*)markerp_ptr);
                            markerp = *markerp_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glFinishAsyncSGIX")]
            public static
            unsafe Int32 FinishAsync([OutAttribute] Int32* markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glFinishAsyncSGIX((UInt32*)markerp);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glFinishAsyncSGIX")]
            public static
            Int32 FinishAsync([OutAttribute] out UInt32 markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* markerp_ptr = &markerp)
                        {
                            Int32 retval = Delegates.glFinishAsyncSGIX((UInt32*)markerp_ptr);
                            markerp = *markerp_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glFinishAsyncSGIX")]
            public static
            unsafe Int32 FinishAsync([OutAttribute] UInt32* markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glFinishAsyncSGIX((UInt32*)markerp);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFlushRaster", Version = "1.0", EntryPoint = "glFlushRasterSGIX")]
            public static
            void FlushRaster()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFlushRasterSGIX();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentColorMaterialSGIX")]
            public static
            void FragmentColorMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentColorMaterialSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightfSGIX")]
            public static
            void FragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightfSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightfvSGIX")]
            public static
            void FragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glFragmentLightfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightfvSGIX")]
            public static
            unsafe void FragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightiSGIX")]
            public static
            void FragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightiSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightivSGIX")]
            public static
            void FragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glFragmentLightivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightivSGIX")]
            public static
            unsafe void FragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightModelfSGIX")]
            public static
            void FragmentLightModel(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightModelfSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightModelfvSGIX")]
            public static
            void FragmentLightModel(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glFragmentLightModelfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightModelfvSGIX")]
            public static
            unsafe void FragmentLightModel(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightModelfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightModeliSGIX")]
            public static
            void FragmentLightModel(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightModeliSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightModelivSGIX")]
            public static
            void FragmentLightModel(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glFragmentLightModelivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentLightModelivSGIX")]
            public static
            unsafe void FragmentLightModel(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentLightModelivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentMaterialfSGIX")]
            public static
            void FragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentMaterialfSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentMaterialfvSGIX")]
            public static
            void FragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glFragmentMaterialfvSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentMaterialfvSGIX")]
            public static
            unsafe void FragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentMaterialfvSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentMaterialiSGIX")]
            public static
            void FragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentMaterialiSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentMaterialivSGIX")]
            public static
            void FragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glFragmentMaterialivSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glFragmentMaterialivSGIX")]
            public static
            unsafe void FragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFragmentMaterialivSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFramezoom", Version = "1.0", EntryPoint = "glFrameZoomSGIX")]
            public static
            void FrameZoom(Int32 factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFrameZoomSGIX((Int32)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glGenAsyncMarkersSGIX")]
            public static
            Int32 GenAsyncMarkers(Int32 range)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGenAsyncMarkersSGIX((Int32)range);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentLightfvSGIX")]
            public static
            void GetFragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetFragmentLightfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentLightfvSGIX")]
            public static
            void GetFragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetFragmentLightfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentLightfvSGIX")]
            public static
            unsafe void GetFragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFragmentLightfvSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentLightivSGIX")]
            public static
            void GetFragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFragmentLightivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentLightivSGIX")]
            public static
            void GetFragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFragmentLightivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentLightivSGIX")]
            public static
            unsafe void GetFragmentLight(OpenTK.Graphics.OpenGL.SgixFragmentLighting light, OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFragmentLightivSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)light, (OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentMaterialfvSGIX")]
            public static
            void GetFragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetFragmentMaterialfvSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentMaterialfvSGIX")]
            public static
            void GetFragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetFragmentMaterialfvSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentMaterialfvSGIX")]
            public static
            unsafe void GetFragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFragmentMaterialfvSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentMaterialivSGIX")]
            public static
            void GetFragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetFragmentMaterialivSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentMaterialivSGIX")]
            public static
            void GetFragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetFragmentMaterialivSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glGetFragmentMaterialivSGIX")]
            public static
            unsafe void GetFragmentMaterial(OpenTK.Graphics.OpenGL.MaterialFace face, OpenTK.Graphics.OpenGL.MaterialParameter pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetFragmentMaterialivSGIX((OpenTK.Graphics.OpenGL.MaterialFace)face, (OpenTK.Graphics.OpenGL.MaterialParameter)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glGetInstrumentsSGIX")]
            public static
            Int32 GetInstruments()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glGetInstrumentsSGIX();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterfvSGIX")]
            public static
            void GetListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterfvSGIX")]
            public static
            void GetListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterfvSGIX")]
            public static
            unsafe void GetListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterfvSGIX")]
            public static
            void GetListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glGetListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterfvSGIX")]
            public static
            void GetListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] out Single @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = &@params)
                        {
                            Delegates.glGetListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterfvSGIX")]
            public static
            unsafe void GetListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterivSGIX")]
            public static
            void GetListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterivSGIX")]
            public static
            void GetListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterivSGIX")]
            public static
            unsafe void GetListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterivSGIX")]
            public static
            void GetListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glGetListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterivSGIX")]
            public static
            void GetListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] out Int32 @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = &@params)
                        {
                            Delegates.glGetListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params_ptr);
                            @params = *@params_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glGetListParameterivSGIX")]
            public static
            unsafe void GetListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, [OutAttribute] Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGetListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixIglooInterface", Version = "1.0", EntryPoint = "glIglooInterfaceSGIX")]
            public static
            void IglooInterface(OpenTK.Graphics.OpenGL.All pname, IntPtr @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glIglooInterfaceSGIX((OpenTK.Graphics.OpenGL.All)pname, (IntPtr)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixIglooInterface", Version = "1.0", EntryPoint = "glIglooInterfaceSGIX")]
            public static
            void IglooInterface<T1>(OpenTK.Graphics.OpenGL.All pname, [InAttribute, OutAttribute] T1[] @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIglooInterfaceSGIX((OpenTK.Graphics.OpenGL.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixIglooInterface", Version = "1.0", EntryPoint = "glIglooInterfaceSGIX")]
            public static
            void IglooInterface<T1>(OpenTK.Graphics.OpenGL.All pname, [InAttribute, OutAttribute] T1[,] @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIglooInterfaceSGIX((OpenTK.Graphics.OpenGL.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixIglooInterface", Version = "1.0", EntryPoint = "glIglooInterfaceSGIX")]
            public static
            void IglooInterface<T1>(OpenTK.Graphics.OpenGL.All pname, [InAttribute, OutAttribute] T1[,,] @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIglooInterfaceSGIX((OpenTK.Graphics.OpenGL.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixIglooInterface", Version = "1.0", EntryPoint = "glIglooInterfaceSGIX")]
            public static
            void IglooInterface<T1>(OpenTK.Graphics.OpenGL.All pname, [InAttribute, OutAttribute] ref T1 @params)
                where T1 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle @params_ptr = GCHandle.Alloc(@params, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glIglooInterfaceSGIX((OpenTK.Graphics.OpenGL.All)pname, (IntPtr)@params_ptr.AddrOfPinnedObject());
                        @params = (T1)@params_ptr.Target;
                    }
                    finally
                    {
                        @params_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glInstrumentsBufferSGIX")]
            public static
            void InstrumentsBuffer(Int32 size, [OutAttribute] Int32[] buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* buffer_ptr = buffer)
                        {
                            Delegates.glInstrumentsBufferSGIX((Int32)size, (Int32*)buffer_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glInstrumentsBufferSGIX")]
            public static
            void InstrumentsBuffer(Int32 size, [OutAttribute] out Int32 buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* buffer_ptr = &buffer)
                        {
                            Delegates.glInstrumentsBufferSGIX((Int32)size, (Int32*)buffer_ptr);
                            buffer = *buffer_ptr;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glInstrumentsBufferSGIX")]
            public static
            unsafe void InstrumentsBuffer(Int32 size, [OutAttribute] Int32* buffer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glInstrumentsBufferSGIX((Int32)size, (Int32*)buffer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glIsAsyncMarkerSGIX")]
            public static
            bool IsAsyncMarker(Int32 marker)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsAsyncMarkerSGIX((UInt32)marker);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glIsAsyncMarkerSGIX")]
            public static
            bool IsAsyncMarker(UInt32 marker)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glIsAsyncMarkerSGIX((UInt32)marker);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixFragmentLighting", Version = "1.0", EntryPoint = "glLightEnviSGIX")]
            public static
            void LightEnv(OpenTK.Graphics.OpenGL.SgixFragmentLighting pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLightEnviSGIX((OpenTK.Graphics.OpenGL.SgixFragmentLighting)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterfSGIX")]
            public static
            void ListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameterfSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterfSGIX")]
            public static
            void ListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameterfSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterfvSGIX")]
            public static
            void ListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterfvSGIX")]
            public static
            unsafe void ListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterfvSGIX")]
            public static
            void ListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterfvSGIX")]
            public static
            unsafe void ListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameterfvSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameteriSGIX")]
            public static
            void ListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameteriSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameteriSGIX")]
            public static
            void ListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameteriSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterivSGIX")]
            public static
            void ListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterivSGIX")]
            public static
            unsafe void ListParameter(Int32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterivSGIX")]
            public static
            void ListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixListPriority", Version = "1.0", EntryPoint = "glListParameterivSGIX")]
            public static
            unsafe void ListParameter(UInt32 list, OpenTK.Graphics.OpenGL.ListParameterName pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glListParameterivSGIX((UInt32)list, (OpenTK.Graphics.OpenGL.ListParameterName)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glLoadIdentityDeformationMapSGIX")]
            public static
            void LoadIdentityDeformationMap(Int32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLoadIdentityDeformationMapSGIX((UInt32)mask);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixPolynomialFfd", Version = "1.0", EntryPoint = "glLoadIdentityDeformationMapSGIX")]
            public static
            void LoadIdentityDeformationMap(UInt32 mask)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glLoadIdentityDeformationMapSGIX((UInt32)mask);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixPixelTexture", Version = "1.0", EntryPoint = "glPixelTexGenSGIX")]
            public static
            void PixelTexGen(OpenTK.Graphics.OpenGL.SgixPixelTexture mode)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glPixelTexGenSGIX((OpenTK.Graphics.OpenGL.SgixPixelTexture)mode);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glPollAsyncSGIX")]
            public static
            Int32 PollAsync([OutAttribute] out Int32 markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* markerp_ptr = &markerp)
                        {
                            Int32 retval = Delegates.glPollAsyncSGIX((UInt32*)markerp_ptr);
                            markerp = *markerp_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glPollAsyncSGIX")]
            public static
            unsafe Int32 PollAsync([OutAttribute] Int32* markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glPollAsyncSGIX((UInt32*)markerp);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glPollAsyncSGIX")]
            public static
            Int32 PollAsync([OutAttribute] out UInt32 markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* markerp_ptr = &markerp)
                        {
                            Int32 retval = Delegates.glPollAsyncSGIX((UInt32*)markerp_ptr);
                            markerp = *markerp_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixAsync", Version = "1.0", EntryPoint = "glPollAsyncSGIX")]
            public static
            unsafe Int32 PollAsync([OutAttribute] UInt32* markerp)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glPollAsyncSGIX((UInt32*)markerp);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glPollInstrumentsSGIX")]
            public static
            Int32 PollInstruments([OutAttribute] out Int32 marker_p)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* marker_p_ptr = &marker_p)
                        {
                            Int32 retval = Delegates.glPollInstrumentsSGIX((Int32*)marker_p_ptr);
                            marker_p = *marker_p_ptr;
                            return retval;
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glPollInstrumentsSGIX")]
            public static
            unsafe Int32 PollInstruments([OutAttribute] Int32* marker_p)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    return Delegates.glPollInstrumentsSGIX((Int32*)marker_p);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glReadInstrumentsSGIX")]
            public static
            void ReadInstruments(Int32 marker)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReadInstrumentsSGIX((Int32)marker);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixReferencePlane", Version = "1.0", EntryPoint = "glReferencePlaneSGIX")]
            public static
            void ReferencePlane(Double[] equation)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* equation_ptr = equation)
                        {
                            Delegates.glReferencePlaneSGIX((Double*)equation_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixReferencePlane", Version = "1.0", EntryPoint = "glReferencePlaneSGIX")]
            public static
            void ReferencePlane(ref Double equation)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Double* equation_ptr = &equation)
                        {
                            Delegates.glReferencePlaneSGIX((Double*)equation_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixReferencePlane", Version = "1.0", EntryPoint = "glReferencePlaneSGIX")]
            public static
            unsafe void ReferencePlane(Double* equation)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReferencePlaneSGIX((Double*)equation);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixSprite", Version = "1.0", EntryPoint = "glSpriteParameterfSGIX")]
            public static
            void SpriteParameter(OpenTK.Graphics.OpenGL.SgixSprite pname, Single param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSpriteParameterfSGIX((OpenTK.Graphics.OpenGL.SgixSprite)pname, (Single)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixSprite", Version = "1.0", EntryPoint = "glSpriteParameterfvSGIX")]
            public static
            void SpriteParameter(OpenTK.Graphics.OpenGL.SgixSprite pname, Single[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* @params_ptr = @params)
                        {
                            Delegates.glSpriteParameterfvSGIX((OpenTK.Graphics.OpenGL.SgixSprite)pname, (Single*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixSprite", Version = "1.0", EntryPoint = "glSpriteParameterfvSGIX")]
            public static
            unsafe void SpriteParameter(OpenTK.Graphics.OpenGL.SgixSprite pname, Single* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSpriteParameterfvSGIX((OpenTK.Graphics.OpenGL.SgixSprite)pname, (Single*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixSprite", Version = "1.0", EntryPoint = "glSpriteParameteriSGIX")]
            public static
            void SpriteParameter(OpenTK.Graphics.OpenGL.SgixSprite pname, Int32 param)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSpriteParameteriSGIX((OpenTK.Graphics.OpenGL.SgixSprite)pname, (Int32)param);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixSprite", Version = "1.0", EntryPoint = "glSpriteParameterivSGIX")]
            public static
            void SpriteParameter(OpenTK.Graphics.OpenGL.SgixSprite pname, Int32[] @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* @params_ptr = @params)
                        {
                            Delegates.glSpriteParameterivSGIX((OpenTK.Graphics.OpenGL.SgixSprite)pname, (Int32*)@params_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SgixSprite", Version = "1.0", EntryPoint = "glSpriteParameterivSGIX")]
            public static
            unsafe void SpriteParameter(OpenTK.Graphics.OpenGL.SgixSprite pname, Int32* @params)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glSpriteParameterivSGIX((OpenTK.Graphics.OpenGL.SgixSprite)pname, (Int32*)@params);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glStartInstrumentsSGIX")]
            public static
            void StartInstruments()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glStartInstrumentsSGIX();
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixInstruments", Version = "1.0", EntryPoint = "glStopInstrumentsSGIX")]
            public static
            void StopInstruments(Int32 marker)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glStopInstrumentsSGIX((Int32)marker);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SgixTagSampleBuffer", Version = "1.0", EntryPoint = "glTagSampleBufferSGIX")]
            public static
            void TagSampleBuffer()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTagSampleBufferSGIX();
#if DEBUG
                }
#endif
            }
        }

        public static partial class Sun
        {
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor3fVertex3fSUN")]
            public static
            void Color3fVertex3(Single r, Single g, Single b, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor3fVertex3fSUN((Single)r, (Single)g, (Single)b, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor3fVertex3fvSUN")]
            public static
            void Color3fVertex3(Single[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* c_ptr = c)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glColor3fVertex3fvSUN((Single*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor3fVertex3fvSUN")]
            public static
            void Color3fVertex3(ref Single c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glColor3fVertex3fvSUN((Single*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor3fVertex3fvSUN")]
            public static
            unsafe void Color3fVertex3(Single* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor3fVertex3fvSUN((Single*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4fNormal3fVertex3fSUN")]
            public static
            void Color4fNormal3fVertex3(Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4fNormal3fVertex3fSUN((Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4fNormal3fVertex3fvSUN")]
            public static
            void Color4fNormal3fVertex3(Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* c_ptr = c)
                        fixed (Single* n_ptr = n)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glColor4fNormal3fVertex3fvSUN((Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4fNormal3fVertex3fvSUN")]
            public static
            void Color4fNormal3fVertex3(ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glColor4fNormal3fVertex3fvSUN((Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void Color4fNormal3fVertex3(Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4fNormal3fVertex3fvSUN((Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex2fSUN")]
            public static
            void Color4ubVertex2(Byte r, Byte g, Byte b, Byte a, Single x, Single y)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4ubVertex2fSUN((Byte)r, (Byte)g, (Byte)b, (Byte)a, (Single)x, (Single)y);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex2fvSUN")]
            public static
            void Color4ubVertex2(Byte[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* c_ptr = c)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glColor4ubVertex2fvSUN((Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex2fvSUN")]
            public static
            void Color4ubVertex2(ref Byte c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glColor4ubVertex2fvSUN((Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex2fvSUN")]
            public static
            unsafe void Color4ubVertex2(Byte* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4ubVertex2fvSUN((Byte*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex3fSUN")]
            public static
            void Color4ubVertex3(Byte r, Byte g, Byte b, Byte a, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4ubVertex3fSUN((Byte)r, (Byte)g, (Byte)b, (Byte)a, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex3fvSUN")]
            public static
            void Color4ubVertex3(Byte[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* c_ptr = c)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glColor4ubVertex3fvSUN((Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex3fvSUN")]
            public static
            void Color4ubVertex3(ref Byte c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glColor4ubVertex3fvSUN((Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glColor4ubVertex3fvSUN")]
            public static
            unsafe void Color4ubVertex3(Byte* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glColor4ubVertex3fvSUN((Byte*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunMeshArray", Version = "1.1", EntryPoint = "glDrawMeshArraysSUN")]
            public static
            void DrawMeshArrays(OpenTK.Graphics.OpenGL.BeginMode mode, Int32 first, Int32 count, Int32 width)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glDrawMeshArraysSUN((OpenTK.Graphics.OpenGL.BeginMode)mode, (Int32)first, (Int32)count, (Int32)width);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactorbSUN")]
            public static
            void GlobalAlphaFactor(SByte factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactorbSUN((SByte)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactordSUN")]
            public static
            void GlobalAlphaFactor(Double factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactordSUN((Double)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactorfSUN")]
            public static
            void GlobalAlphaFactor(Single factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactorfSUN((Single)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactoriSUN")]
            public static
            void GlobalAlphaFactor(Int32 factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactoriSUN((Int32)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactorsSUN")]
            public static
            void GlobalAlphaFactors(Int16 factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactorsSUN((Int16)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactorubSUN")]
            public static
            void GlobalAlphaFactor(Byte factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactorubSUN((Byte)factor);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactoruiSUN")]
            public static
            void GlobalAlphaFactor(UInt32 factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactoruiSUN((UInt32)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactorusSUN")]
            public static
            void GlobalAlphaFactor(Int16 factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactorusSUN((UInt16)factor);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunGlobalAlpha", Version = "1.1", EntryPoint = "glGlobalAlphaFactorusSUN")]
            public static
            void GlobalAlphaFactor(UInt16 factor)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glGlobalAlphaFactorusSUN((UInt16)factor);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glNormal3fVertex3fSUN")]
            public static
            void Normal3fVertex3(Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormal3fVertex3fSUN((Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glNormal3fVertex3fvSUN")]
            public static
            void Normal3fVertex3(Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* n_ptr = n)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glNormal3fVertex3fvSUN((Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glNormal3fVertex3fvSUN")]
            public static
            void Normal3fVertex3(ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glNormal3fVertex3fvSUN((Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glNormal3fVertex3fvSUN")]
            public static
            unsafe void Normal3fVertex3(Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glNormal3fVertex3fvSUN((Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodePointerSUN")]
            public static
            void ReplacementCodePointer(OpenTK.Graphics.OpenGL.SunTriangleList type, Int32 stride, IntPtr pointer)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodePointerSUN((OpenTK.Graphics.OpenGL.SunTriangleList)type, (Int32)stride, (IntPtr)pointer);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodePointerSUN")]
            public static
            void ReplacementCodePointer<T2>(OpenTK.Graphics.OpenGL.SunTriangleList type, Int32 stride, [InAttribute, OutAttribute] T2[] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glReplacementCodePointerSUN((OpenTK.Graphics.OpenGL.SunTriangleList)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodePointerSUN")]
            public static
            void ReplacementCodePointer<T2>(OpenTK.Graphics.OpenGL.SunTriangleList type, Int32 stride, [InAttribute, OutAttribute] T2[,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glReplacementCodePointerSUN((OpenTK.Graphics.OpenGL.SunTriangleList)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodePointerSUN")]
            public static
            void ReplacementCodePointer<T2>(OpenTK.Graphics.OpenGL.SunTriangleList type, Int32 stride, [InAttribute, OutAttribute] T2[,,] pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glReplacementCodePointerSUN((OpenTK.Graphics.OpenGL.SunTriangleList)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodePointerSUN")]
            public static
            void ReplacementCodePointer<T2>(OpenTK.Graphics.OpenGL.SunTriangleList type, Int32 stride, [InAttribute, OutAttribute] ref T2 pointer)
                where T2 : struct
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    GCHandle pointer_ptr = GCHandle.Alloc(pointer, GCHandleType.Pinned);
                    try
                    {
                        Delegates.glReplacementCodePointerSUN((OpenTK.Graphics.OpenGL.SunTriangleList)type, (Int32)stride, (IntPtr)pointer_ptr.AddrOfPinnedObject());
                        pointer = (T2)pointer_ptr.Target;
                    }
                    finally
                    {
                        pointer_ptr.Free();
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeubSUN")]
            public static
            void ReplacementCode(Byte code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeubSUN((Byte)code);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeubvSUN")]
            public static
            void ReplacementCode(Byte[] code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Byte* code_ptr = code)
                        {
                            Delegates.glReplacementCodeubvSUN((Byte*)code_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeubvSUN")]
            public static
            unsafe void ReplacementCode(Byte* code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeubvSUN((Byte*)code);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fSUN")]
            public static
            void ReplacementCodeuiColor3fVertex3(Int32 rc, Single r, Single g, Single b, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor3fVertex3fSUN((UInt32)rc, (Single)r, (Single)g, (Single)b, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fSUN")]
            public static
            void ReplacementCodeuiColor3fVertex3(UInt32 rc, Single r, Single g, Single b, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor3fVertex3fSUN((UInt32)rc, (Single)r, (Single)g, (Single)b, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiColor3fVertex3(ref Int32 rc, ref Single c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor3fVertex3(Int32* rc, Single[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* c_ptr = c)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor3fVertex3(Int32* rc, Single* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc, (Single*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiColor3fVertex3(ref UInt32 rc, ref Single c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor3fVertex3(UInt32* rc, Single[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* c_ptr = c)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor3fVertex3(UInt32* rc, Single* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor3fVertex3fvSUN((UInt32*)rc, (Single*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiColor4fNormal3fVertex3(Int32 rc, Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4fNormal3fVertex3fSUN((UInt32)rc, (Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiColor4fNormal3fVertex3(UInt32 rc, Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4fNormal3fVertex3fSUN((UInt32)rc, (Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiColor4fNormal3fVertex3(ref Int32 rc, ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4fNormal3fVertex3(Int32* rc, Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* c_ptr = c)
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4fNormal3fVertex3(Int32* rc, Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiColor4fNormal3fVertex3(ref UInt32 rc, ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4fNormal3fVertex3(UInt32* rc, Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* c_ptr = c)
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4fNormal3fVertex3(UInt32* rc, Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fSUN")]
            public static
            void ReplacementCodeuiColor4ubVertex3(Int32 rc, Byte r, Byte g, Byte b, Byte a, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4ubVertex3fSUN((UInt32)rc, (Byte)r, (Byte)g, (Byte)b, (Byte)a, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fSUN")]
            public static
            void ReplacementCodeuiColor4ubVertex3(UInt32 rc, Byte r, Byte g, Byte b, Byte a, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4ubVertex3fSUN((UInt32)rc, (Byte)r, (Byte)g, (Byte)b, (Byte)a, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
            public static
            void ReplacementCodeuiColor4ubVertex3(ref Int32 rc, ref Byte c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Byte* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc_ptr, (Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4ubVertex3(Int32* rc, Byte[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Byte* c_ptr = c)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc, (Byte*)c_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4ubVertex3(Int32* rc, Byte* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc, (Byte*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
            public static
            void ReplacementCodeuiColor4ubVertex3(ref UInt32 rc, ref Byte c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Byte* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc_ptr, (Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4ubVertex3(UInt32* rc, Byte[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Byte* c_ptr = c)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc, (Byte*)c_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiColor4ubVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiColor4ubVertex3(UInt32* rc, Byte* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiColor4ubVertex3fvSUN((UInt32*)rc, (Byte*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiNormal3fVertex3(Int32 rc, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiNormal3fVertex3fSUN((UInt32)rc, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiNormal3fVertex3(UInt32 rc, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiNormal3fVertex3fSUN((UInt32)rc, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiNormal3fVertex3(ref Int32 rc, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiNormal3fVertex3(Int32* rc, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiNormal3fVertex3(Int32* rc, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiNormal3fVertex3(ref UInt32 rc, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiNormal3fVertex3(UInt32* rc, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiNormal3fVertex3(UInt32* rc, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiNormal3fVertex3fvSUN((UInt32*)rc, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeuiSUN")]
            public static
            void ReplacementCode(Int32 code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiSUN((UInt32)code);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeuiSUN")]
            public static
            void ReplacementCode(UInt32 code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiSUN((UInt32)code);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(Int32 rc, Single s, Single t, Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN((UInt32)rc, (Single)s, (Single)t, (Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(UInt32 rc, Single s, Single t, Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN((UInt32)rc, (Single)s, (Single)t, (Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(ref Int32 rc, ref Single tc, ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(Int32* rc, Single[] tc, Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* tc_ptr = tc)
                    fixed (Single* c_ptr = c)
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(Int32* rc, Single* tc, Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc, (Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(ref UInt32 rc, ref Single tc, ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(UInt32* rc, Single[] tc, Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* tc_ptr = tc)
                    fixed (Single* c_ptr = c)
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3(UInt32* rc, Single* tc, Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc, (Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiTexCoord2fNormal3fVertex3(Int32 rc, Single s, Single t, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN((UInt32)rc, (Single)s, (Single)t, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN")]
            public static
            void ReplacementCodeuiTexCoord2fNormal3fVertex3(UInt32 rc, Single s, Single t, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN((UInt32)rc, (Single)s, (Single)t, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiTexCoord2fNormal3fVertex3(ref Int32 rc, ref Single tc, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3(Int32* rc, Single[] tc, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* tc_ptr = tc)
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3(Int32* rc, Single* tc, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
            public static
            void ReplacementCodeuiTexCoord2fNormal3fVertex3(ref UInt32 rc, ref Single tc, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc_ptr, (Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3(UInt32* rc, Single[] tc, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* tc_ptr = tc)
                    fixed (Single* n_ptr = n)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fNormal3fVertex3(UInt32* rc, Single* tc, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN((UInt32*)rc, (Single*)tc, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fSUN")]
            public static
            void ReplacementCodeuiTexCoord2fVertex3(Int32 rc, Single s, Single t, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fVertex3fSUN((UInt32)rc, (Single)s, (Single)t, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fSUN")]
            public static
            void ReplacementCodeuiTexCoord2fVertex3(UInt32 rc, Single s, Single t, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fVertex3fSUN((UInt32)rc, (Single)s, (Single)t, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
            public static
            void ReplacementCodeuiTexCoord2fVertex3(ref Int32 rc, ref Single tc, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc_ptr, (Single*)tc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fVertex3(Int32* rc, Single[] tc, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* tc_ptr = tc)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fVertex3(Int32* rc, Single* tc, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc, (Single*)tc, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
            public static
            void ReplacementCodeuiTexCoord2fVertex3(ref UInt32 rc, ref Single tc, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc_ptr, (Single*)tc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fVertex3(UInt32* rc, Single[] tc, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* tc_ptr = tc)
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc, (Single*)tc_ptr, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiTexCoord2fVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiTexCoord2fVertex3(UInt32* rc, Single* tc, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiTexCoord2fVertex3fvSUN((UInt32*)rc, (Single*)tc, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fSUN")]
            public static
            void ReplacementCodeuiVertex3(Int32 rc, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiVertex3fSUN((UInt32)rc, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fSUN")]
            public static
            void ReplacementCodeuiVertex3(UInt32 rc, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiVertex3fSUN((UInt32)rc, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
            public static
            void ReplacementCodeuiVertex3(ref Int32 rc, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* rc_ptr = &rc)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiVertex3(Int32* rc, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiVertex3(Int32* rc, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc, (Single*)v);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
            public static
            void ReplacementCodeuiVertex3(ref UInt32 rc, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* rc_ptr = &rc)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiVertex3(UInt32* rc, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    fixed (Single* v_ptr = v)
                    {
                        Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc, (Single*)v_ptr);
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glReplacementCodeuiVertex3fvSUN")]
            public static
            unsafe void ReplacementCodeuiVertex3(UInt32* rc, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuiVertex3fvSUN((UInt32*)rc, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeuivSUN")]
            public static
            void ReplacementCode(Int32[] code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int32* code_ptr = code)
                        {
                            Delegates.glReplacementCodeuivSUN((UInt32*)code_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeuivSUN")]
            public static
            unsafe void ReplacementCode(Int32* code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuivSUN((UInt32*)code);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeuivSUN")]
            public static
            void ReplacementCode(UInt32[] code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt32* code_ptr = code)
                        {
                            Delegates.glReplacementCodeuivSUN((UInt32*)code_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeuivSUN")]
            public static
            unsafe void ReplacementCode(UInt32* code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeuivSUN((UInt32*)code);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeusSUN")]
            public static
            void ReplacementCode(Int16 code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeusSUN((UInt16)code);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeusSUN")]
            public static
            void ReplacementCode(UInt16 code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeusSUN((UInt16)code);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeusvSUN")]
            public static
            void ReplacementCode(Int16[] code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Int16* code_ptr = code)
                        {
                            Delegates.glReplacementCodeusvSUN((UInt16*)code_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeusvSUN")]
            public static
            unsafe void ReplacementCode(Int16* code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeusvSUN((UInt16*)code);
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeusvSUN")]
            public static
            void ReplacementCode(UInt16[] code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (UInt16* code_ptr = code)
                        {
                            Delegates.glReplacementCodeusvSUN((UInt16*)code_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunTriangleList", Version = "1.1", EntryPoint = "glReplacementCodeusvSUN")]
            public static
            unsafe void ReplacementCode(UInt16* code)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glReplacementCodeusvSUN((UInt16*)code);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor3fVertex3fSUN")]
            public static
            void TexCoord2fColor3fVertex3(Single s, Single t, Single r, Single g, Single b, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fColor3fVertex3fSUN((Single)s, (Single)t, (Single)r, (Single)g, (Single)b, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor3fVertex3fvSUN")]
            public static
            void TexCoord2fColor3fVertex3(Single[] tc, Single[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Single* c_ptr = c)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord2fColor3fVertex3fvSUN((Single*)tc_ptr, (Single*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor3fVertex3fvSUN")]
            public static
            void TexCoord2fColor3fVertex3(ref Single tc, ref Single c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord2fColor3fVertex3fvSUN((Single*)tc_ptr, (Single*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor3fVertex3fvSUN")]
            public static
            unsafe void TexCoord2fColor3fVertex3(Single* tc, Single* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fColor3fVertex3fvSUN((Single*)tc, (Single*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4fNormal3fVertex3fSUN")]
            public static
            void TexCoord2fColor4fNormal3fVertex3(Single s, Single t, Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fColor4fNormal3fVertex3fSUN((Single)s, (Single)t, (Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            void TexCoord2fColor4fNormal3fVertex3(Single[] tc, Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Single* c_ptr = c)
                        fixed (Single* n_ptr = n)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord2fColor4fNormal3fVertex3fvSUN((Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            void TexCoord2fColor4fNormal3fVertex3(ref Single tc, ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord2fColor4fNormal3fVertex3fvSUN((Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4fNormal3fVertex3fvSUN")]
            public static
            unsafe void TexCoord2fColor4fNormal3fVertex3(Single* tc, Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fColor4fNormal3fVertex3fvSUN((Single*)tc, (Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4ubVertex3fSUN")]
            public static
            void TexCoord2fColor4ubVertex3(Single s, Single t, Byte r, Byte g, Byte b, Byte a, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fColor4ubVertex3fSUN((Single)s, (Single)t, (Byte)r, (Byte)g, (Byte)b, (Byte)a, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4ubVertex3fvSUN")]
            public static
            void TexCoord2fColor4ubVertex3(Single[] tc, Byte[] c, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Byte* c_ptr = c)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord2fColor4ubVertex3fvSUN((Single*)tc_ptr, (Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4ubVertex3fvSUN")]
            public static
            void TexCoord2fColor4ubVertex3(ref Single tc, ref Byte c, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Byte* c_ptr = &c)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord2fColor4ubVertex3fvSUN((Single*)tc_ptr, (Byte*)c_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fColor4ubVertex3fvSUN")]
            public static
            unsafe void TexCoord2fColor4ubVertex3(Single* tc, Byte* c, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fColor4ubVertex3fvSUN((Single*)tc, (Byte*)c, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fNormal3fVertex3fSUN")]
            public static
            void TexCoord2fNormal3fVertex3(Single s, Single t, Single nx, Single ny, Single nz, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fNormal3fVertex3fSUN((Single)s, (Single)t, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fNormal3fVertex3fvSUN")]
            public static
            void TexCoord2fNormal3fVertex3(Single[] tc, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Single* n_ptr = n)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord2fNormal3fVertex3fvSUN((Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fNormal3fVertex3fvSUN")]
            public static
            void TexCoord2fNormal3fVertex3(ref Single tc, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord2fNormal3fVertex3fvSUN((Single*)tc_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fNormal3fVertex3fvSUN")]
            public static
            unsafe void TexCoord2fNormal3fVertex3(Single* tc, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fNormal3fVertex3fvSUN((Single*)tc, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fVertex3fSUN")]
            public static
            void TexCoord2fVertex3(Single s, Single t, Single x, Single y, Single z)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fVertex3fSUN((Single)s, (Single)t, (Single)x, (Single)y, (Single)z);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fVertex3fvSUN")]
            public static
            void TexCoord2fVertex3(Single[] tc, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord2fVertex3fvSUN((Single*)tc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fVertex3fvSUN")]
            public static
            void TexCoord2fVertex3(ref Single tc, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord2fVertex3fvSUN((Single*)tc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord2fVertex3fvSUN")]
            public static
            unsafe void TexCoord2fVertex3(Single* tc, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord2fVertex3fvSUN((Single*)tc, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fColor4fNormal3fVertex4fSUN")]
            public static
            void TexCoord4fColor4fNormal3fVertex4(Single s, Single t, Single p, Single q, Single r, Single g, Single b, Single a, Single nx, Single ny, Single nz, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord4fColor4fNormal3fVertex4fSUN((Single)s, (Single)t, (Single)p, (Single)q, (Single)r, (Single)g, (Single)b, (Single)a, (Single)nx, (Single)ny, (Single)nz, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fColor4fNormal3fVertex4fvSUN")]
            public static
            void TexCoord4fColor4fNormal3fVertex4(Single[] tc, Single[] c, Single[] n, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Single* c_ptr = c)
                        fixed (Single* n_ptr = n)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord4fColor4fNormal3fVertex4fvSUN((Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fColor4fNormal3fVertex4fvSUN")]
            public static
            void TexCoord4fColor4fNormal3fVertex4(ref Single tc, ref Single c, ref Single n, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* c_ptr = &c)
                        fixed (Single* n_ptr = &n)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord4fColor4fNormal3fVertex4fvSUN((Single*)tc_ptr, (Single*)c_ptr, (Single*)n_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fColor4fNormal3fVertex4fvSUN")]
            public static
            unsafe void TexCoord4fColor4fNormal3fVertex4(Single* tc, Single* c, Single* n, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord4fColor4fNormal3fVertex4fvSUN((Single*)tc, (Single*)c, (Single*)n, (Single*)v);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fVertex4fSUN")]
            public static
            void TexCoord4fVertex4(Single s, Single t, Single p, Single q, Single x, Single y, Single z, Single w)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord4fVertex4fSUN((Single)s, (Single)t, (Single)p, (Single)q, (Single)x, (Single)y, (Single)z, (Single)w);
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fVertex4fvSUN")]
            public static
            void TexCoord4fVertex4(Single[] tc, Single[] v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = tc)
                        fixed (Single* v_ptr = v)
                        {
                            Delegates.glTexCoord4fVertex4fvSUN((Single*)tc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fVertex4fvSUN")]
            public static
            void TexCoord4fVertex4(ref Single tc, ref Single v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    unsafe
                    {
                        fixed (Single* tc_ptr = &tc)
                        fixed (Single* v_ptr = &v)
                        {
                            Delegates.glTexCoord4fVertex4fvSUN((Single*)tc_ptr, (Single*)v_ptr);
                        }
                    }
#if DEBUG
                }
#endif
            }

            [System.CLSCompliant(false)]
            [AutoGenerated(Category = "SunVertex", Version = "1.1", EntryPoint = "glTexCoord4fVertex4fvSUN")]
            public static
            unsafe void TexCoord4fVertex4(Single* tc, Single* v)
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glTexCoord4fVertex4fvSUN((Single*)tc, (Single*)v);
#if DEBUG
                }
#endif
            }
        }

        public static partial class Sunx
        {
            [AutoGenerated(Category = "SunxConstantData", Version = "1.1", EntryPoint = "glFinishTextureSUNX")]
            public static
            void FinishTexture()
            {
#if DEBUG
                using (new ErrorHelper(GraphicsContext.CurrentContext))
                {
#endif
                    Delegates.glFinishTextureSUNX();
#if DEBUG
                }
#endif
            }
        }
    }
}
#endif